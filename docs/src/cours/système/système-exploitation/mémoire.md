---
layout: layout/post.njk

title: Mémoire

eleventyComputed:
  eleventyNavigation:
    key: "{{ page.url }}"
    title: "{{ title | safe }}"
    parent: "{{ '../' | siteUrl(page.url) }}"
---

La mémoire est une partie fondamentale d'un ordinateur et d'un système d'exploitation. C'est dans la mémoire que **tout** est stocké :

- les instructions de chaque process
- le noyau
- des tables de fonctions utilisées par le processeurs (interruptions, tables des pages mémoires)

Son accès est plus rapide que les autres devices, mais est plus lent que la mémoire (beaucoup plus chère) cache du processeur.

{% note "**définition**" %}
La mémoire est tableau de taille $2^{64}-1$ contenant des [byte](https://fr.wikipedia.org/wiki/Byte)
{% endnote %}

Un byte correspond à 8 [bit](https://fr.wikipedia.org/wiki/Bit), que l'on range par convention de droite à gauche, pour pouvoir facilement lire sa valeur. Le byte ci-dessous correspond au nombre binaire :0b11001101, c'est à dire 205 :

```
index  : 76543210
valeur : 11001101
```

Si le bit représente la quantité d'information minimale (0 ou 1), le byte est l'unité fondamentale de stockage. On ne pourra jamais véhiculer moins d'un byte et toute donnée sera constituée d'un multiple de byte.

## Objets manipulés

Il ne faut pas confondre l'adresse en mémoire, souvent donnée en bit et son contenu, donné en byte.

{% attention %}
Pour stocker un tableau adressé sur 8bits il faut $2^8 = 256$ byte, c'est à dire $2^8 \cdot 8 = 2048$ bits.
{% endattention %}

### Unités

Attentions aux unités :

- l'abréviation d'un bit est b
- l'abréviation d'un byte est B

64b correspond à 8B.

On a coutume de considérer les quantités suivantes :

- 1b, l'unité fondamentale
- 8b qui forment un byte (octet), d’abréviation B
- 16b, donc 2B qui forment un word (mot), d'abréviation W 
- 32b, donc 4B et 2 word qui forment un dword (double word, double mot), d'abréviation DW
- 64b, donc 8B, 2 dword et 4 word forment un qword (quad word, quadruple mot), d'abréviation QW

### Multiples

Les taille de mémoire sont grande, on ne peut les manipuler directement en byte. Le système décimal nous permet de parler de multiples en kilo, méga, giga et tera :

- un ***kilo byte***, kB, pour $10^3$ byte et ***kilo bit***, kb, pour $10^3$ bits
- Un ***méga byte***, MB, qui vaut $10^3 \cdot 10^3 = 10^{2 \cdot 3} = 10^{6}$ byte et un ***méga bit***, Mb, qui vaut $10^{6}$ bit
- un ***giga byte***, GB et ***giga bit***, Gb, qui valent $10^9$ byte ou bit
- un ***tera byte***, TB et ***tera bit***, Tb, qui valent $10^{12}$ byte ou bit

Mais lorsque l'on parle de mémoire, on a coutume de chercher à voir la taille en byte de mémoire d'objets selon une quantité d'adresses exprimé en bit. De là 1 KB n'a que peu de sens. C'est 1024B qui en a (le nombre de byte adressable par 10 bits).

C'est pourquoi, on parlera de multiple binaires comme le ***kibi  byte***, pour **ki**lo **bi**naire d'unité kiB, qui vaut $2^{10} = 1024$ byte.

La différence n'est pas grande mais autant être précis.

On peut ainsi progresser dans les multiples :

- un ***kibi byte***, KiB, qui vaut $2^{10} \cdot 2^{10} = 2^{2 \cdot 10} = 2^{20}$ byte
- un ***mébi byte***, MiB, qui vaut $2^{10} \cdot 2^{10} = 2^{2 \cdot 10} = 2^{20}$ byte
- un ***gibi byte***,GiB, qui vaut $2^{30}$ byte (attention, ne cofondez pas avec un [Gibi](https://www.youtube.com/watch?v=3EhIQSUU4Fk&list=PLsbtzZi9n5PtE3M1zlzwQByojW7xDhExY&index=70), ça n'a rien à voir)
- un ***tebi byte***, TiB, qui vaut $2^{40}$ byte

## Valeurs

La valeur de ce qu'il y a en mémoire dépend du contexte. Un byte peut être :

- un entier entre 0 et 255
- un entier relatif entre -128 et 127 (en [complément à deux](https://fr.wikipedia.org/wiki/Compl%C3%A9ment_%C3%A0_deux))
- un caractère [ascii](https://fr.wikipedia.org/wiki/American_Standard_Code_for_Information_Interchange) si le dernier bit est à 0.
- le début (ou la fin) d'un entier plus grand
- ...

{% note %}
La signification d'un byte ou d'un ensemble de byte contiguës (dans un tableau) est **toujours** dépendant du contexte.
{% endnote %}

```
index          : 76543210
valeur binaire : 11001101
int > 0        : 205
int < 0        : -51
ASCII 8b       : Í
```

C'est encore pire lorsque l'on considère des valeurs sur plusieurs adresses consécutives :

```
Indice   :        1       2
Valeur b : 0000110010010001
       B :       12     145 
```

Sa valeur en word va dépendre de selon qu'on lire la valeur par indice croissant ou décroissant.

Si on lit par indice décroissant (sens commun de lecture) on trouvera l'entier binaire : `0000110010010001` qui correspond à l'entier décimal 3217.

Et si on lit par indice décroissant, on trouvera l'entier binaire : `1001000100001100` qui lui correspond à l'entier décimal 37132.

{% attention %}
L'unité fondamentale de lecture est **toujours** le byte, on inverse donc les bytes, pas les bits qui le compose.
{% endattention %}

Ceci est loin d'être anecdotique et s'appelle l'[Endianness](https://fr.wikipedia.org/wiki/Boutisme) :

- les processeurs ARM, tout comme les protocoles réseau ou PCIe sont dit *big endian* les bytes sont lu de droite à gauche (sens de lecture usuel)
- les processeur intel sont dit *little endian* les byte sont lu de gauche à droite (sens non usuel)

Un word étant composé de deux byte, le byte des 8 premiers bits est dit de poids faible et le byte des 8 derniers bits est dit byte de poids fort. Les système big endian mette le byte de poids fort à l'adresse la plus petite et les systèmes little endian à l'adresse la plus forte.

{% note %}
Il est important de connaître la taille des objets que l'on manipule et de laisser le système gérer l'Endianness pour nous.
{% endnote %}
{% info %}
L'Endianness est un exemple parmi tant d'autre que s'il existe une convention vous pouvez être sur que les deux choix seront choisis (écrire de gauche à droite, nord vers le haut, etc)
{% endinfo %}

## Mémoire dans les OS

Dans les OS actuels, la mémoire s'adresse sur 64b. C'est à dire qu'il est théoriquement possible d'adresser $2^{64}$ byte, c'est à dire 16[EiB](https://fr.wikipedia.org/wiki/Pr%C3%A9fixe_binaire#Tableaux_des_pr%C3%A9fixes_binaires_et_d%C3%A9cimaux) et donc 16777216 TiB.

### Adressage logique et physique

Cette limite est actuellement inatteignable en pratique, c'est pourquoi pour limiter la complexité de l'adressage les processeurs actuels autorise moins d'adresse. Pour un (https://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details) par exemple (pour un ARM, c'est pareil):

- seule 48bit sont adressables, des bit 0 à 47
- les bits 47 à 63 doivent être identiques (0 ou 1)

{% info %}
Cet adressage est dit ***logique*** (ou virtuel) car c'est l'adressage vu depuis le processeur. L'adressage ***physique***, directement sur la RAM, est lui autorisé sur 52bits.
{% endinfo %}

### Types de données

Les données manipulées sont **toutes** des tableaux de bytes en mémoire.

Les processeurs actuels sont (quasi) tous basé sur une architecture 64b. C'est à dire que ses différentes instructions prennent comme paramètres des qword par défaut, et que les transferts de données sont optimisées pour cette taille.

Ces instructions peuvent souvent être déclinées en instructions sur des dword, des word ou même des bytes mais jamais rien d'autre (vous ne trouverez jamais aucune instruction dont les paramètres sont des nombres sur 3 bytes).

Cette organisation en puissance de deux de byte est au cœur de tout l'organisation d'un ordinateur.
