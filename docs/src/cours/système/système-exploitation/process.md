---
layout: layout/post.njk

title: Process

eleventyComputed:
  eleventyNavigation:
    key: "{{ page.url }}"
    title: "{{ title | safe }}"
    parent: "{{ '../' | siteUrl(page.url) }}"
---

Un process est l'unité de base d'un programme. Un process contient des données et des instructions pour être exécuté, le tout étant stocké en mémoire.

## Exécution d'un process

Nous n'allons pas rentrer dans les détails sur ce qu'est une instruction. On y reviendra lorsque l'on parlera précisément des cores.

On va uniquement considérer ici qu'à chaque instruction est associé un byte et que le code d'un process, c'est à dire la suite d'instructions que devra effectuer le processeur, est un tableau $C$ de byte.

L'exécution du process est alors déterminée par un entier $I$ tel que :

1. `IP` vaut initialement 0
2. on lit l'instruction `C[IP]` qui est exécutée par le processeur
3. le processeur exécute l'instruction `C[IP]`
4. si `C[IP]` est :
   - l'instruction de fin on stope l'exécution du process
   - une instruction de saut on affecte à I la valeur du saut
   - sinon on incrémente $I$
5. retour en 2.

## Organisation en mémoire

### Instructions simples

Si la seule instruction est d'afficher un retour à la ligne à l'écran, le code serait quelque chose du genre :

```
6 : .
5 : .
4 : .
3 : .
2 : .
1 : exit
0 : print
```

### Instructions avec paramètre

Si l'on veut afficher "Hello World" à l'écran, il faut pouvoir stocker la chaîne de caractère "Hello World" dans la mémoire et demander à notre programme de l'afficher. Il ne peut en effet pas y avoir d'instruction différente pour chaque chaîne de caractère à afficher.

```
15  : .
14  : .
13  : 0
12  : 'd'
11  : 'l'
10  : 'r'
 9  : 'o' 
 8  : 'W'
 7  : ' ' 
 6  : 'o'
 5  : 'l'
 4  : 'l'
 3  : 'e'
 2  : 'H'
 1  : exit
 0  : print 2
```

L'instruction print est maintenant différente. Elle indique que le paramètre commence à l'adresse 2.

Ce paramètre est nécessairement séparé du code pour éviter qu'il puisse être exécuté (c'est à dire convertir la chaîne de caractère en instruction).

{% info %}
On a fait terminer la chaîne à afficher par le caractère 0, qui est une convention (en C) pour dire que c'est la fin de la chaîne de caractères.
{% endinfo %}

Le process doit donc avoir au moins 2 parties distinctes :

```
paramètres
code
```

Chaque constante est adressée par son indice. Il faut donc que le code connaissent exactement la position de la constante en mémoire. Ceci n'est pas toujours possible car peut-être que le code n'est pas exécuté à partir de 0, ce qui casserait tout :

```
20     : .
19     : .
18     : .
17     : .
 5-16  : 'Hello World\0'
 4     : exit
 3     : print 2
 2     : .
 1     : .
 0     : .
```

En revanche, le code connaît la position relative de la constante par rapport à son exécution, ici 3 + 2. Comme le pointeur IP pointe sur la **prochaine instruction**, le code suivant fonctionne donc toujours, le paramètre se trouve 2 cases plus loin que l'instruction courante donc 1 de plus que la prochaine instruction :

```
20     : .
19     : .
18     : .
17     : .
 5-16  : 'Hello World\0'
 4     : exit
 3     : print IP+1
 2     : .
 1     : .
 0     : .
```

Vous pourrez m'objecter, qu'il n'est pas possible d'avoir une commande différente pour chaque saut de paramètre. Cela ferait trop de commande.

Effectivement, ce n'est pas comme ça que c'est géré. On utilise des commandes de taille variables où :

- le premier byte détermine toujours l'instruction
- le second contient le premier paramètre
- le troisième le deuxième paramètre s'il y en a
- ainsi de suite

Comme le processeur les connaît, il incrémentera automatiquement le compteur d'instruction de la taille de l'instruction plus le nombre de ses paramètres. Notre code devient :

```
21     : .
20     : .
19     : .
18     : .
 6-17  : 'Hello World\0'
 5     : exit
 4     : 3                             // +3 car l'instruction courante est en 3
 3     : print avec un paramètre
 2     : .
 1     : .
 0     : .
```

{% info %}
Notez que le paramètre doit être de taille fixe (ici 1 byte) pour que tout fonctionne. Il n'est pas possible pour cette commande de faire des sauts de plus de 255 byte (il faudrait une autre commande qui prend un word à la place d'un byte comme paramètre)
{% endinfo %}

Pour des raisons de lisibilité, nous n'allons pas recopier directement le code dans ce qui suit. On va utiliser des règles qui vont faciliter la lecture des programme et qui sont immédiatement transposable :

- nous n'allons plus numéroter les cases de la mémoire et écrire le programme dans l'ordre de lecture, de haut en bas
- nous allons continuer à placer les paramètres dans le corps des commandes
- nous allons marquer des labels dans le code pour nous rappeler de l'endroit où aller
- on sépare clairement la partie code (nommée .text) de la partie donnée (nommée .data)
- nous allons oublier l'instruction exit, lorsque l'on arrive à la fin du code, programme s'arrête

```
section .data

Hello DB "Hello World", 0

section .text

main:
    print chaîne
```

Le code précédent devient alors plus lisible sans perdre de sa généralité :

- les données sont listées les unes à la suite des autres et ont des noms (qui seront transcrit en décalage dans l'exécution) et des types : DB signifie un tableau de bytes.
- le label `main:` est le label vers le début du code.

## Du fichier au programme

A priori tout programme peut fonctionner uniquement avec des instructions et des valeurs initiales, le étant déterminé pendant l'exécution.

Le fichier stockant le programme est donc uniquement composé des constantes et des instructions. S'il suit exactement ce principe :

```
code
données
```

et que les appels aux constantes sont des déplacements relatifs, le code exécuté peut être stocké directement dans un fichier pour être réutilisé plus tard sans aucun changement.

{% note %}
Le code en mémoire et le code fichier est identique identique
{% endnote %}

## Instructions avec variables

Regardons le code python suivant :

```python
for i in range(10):
  print(i)
```

{% faire %}
Écrivez le code comme précédemment. En ajoutant des instructions

Rappelez-vous que le code :

- ne peut pas posséder de constantes.
- les paramètres sont placés après l'appel à l'instruction

{% endfaire %}
{% details "solution", "open" %}

```
section .data

i B 0

section .text

main:
    place 0 dans i
    print i
    incrémente i
    si i < 10 saute en main
```

{% enddetails  %}

Outre le fait d'inventer des commandes plausibles, on a utilisé une case consacrée à nos données pour stocker une variable (la variable `i`{.language-} du code python)

On remarque que la position de la variable dans la pile ne bouge pas

Ce nest pas très optimisé puisqu'on devra sauvegarder cette variable dans le fichier du code et alourdira inutilement notre fichier. de plus, `i`{.language-} est une variable, elle ne devrait pas être présente dans le code "en dur" mais créée à la volé par le programme.

### Utilisation d'une pile

La gestion des variable est faite par une [pile](https://fr.wikipedia.org/wiki/Pile_(informatique))

Commençons par voir comment tout ceci est fait avant de voir comment l'implémenter en mémoire.

{% note %}
Une ***pile*** est une structure de donnée qui comprend deux fonctions :

- empilage(d) : ajoute l'élément d à la pile et rend son indice de stockage
- dépilage() : supprime un élément à la pile
- accès(i) : accède au i+1 ème élément de la pile en lecture ou en écriture

{% endnote %}

Exemple :

```python
empile(1)
empile(2)
print(accès(0))  # rendra 2
print(accès(1))  # rendra 1
dépile()
print(accès(0))  # rendra 1
```

Cette structure permet deux choses fondamentale :

- stocker et supprimer des choses
- utiliser les éléments stockés car les accès ne vont pas bouger

C'est exactement ce qu'il faut pour gérer des variables.

De plus, une pile se gère comme un tableau ! Soit SP un indice de la mémoire qui contient le dernier élément de la pile.

- Empiler le byte $x$ dans la pile revient à :
  - décrémenter l'indice SP
  - placer la valeur $x$ à l'endroit de la mémoire adressée par SP
- Accéder au $i+1$ élément de la pile revient à accéder à l'élément placé à SP + i dans la mémoire
- Dépiler un élément de la pile revient à incrémenter SP

Après les deux premières lignes du programme précédent on a :

```
SP-1 :         1
SP   :         2
SP+1 :
```

De là le code complet est :

```
section .text

main:
    empile 0
    empile 2
    print [SP]
    print [SP-1]
    dépile
    print [SP]
```

Pour continuer nos [sucres syntaxiques](https://fr.wikipedia.org/wiki/Sucre_syntaxique) on utilise :

- SP pour donner la valeur de SP (c'est à dire un indice d'une case mémoire)
- [SP] pour donner la valeur de la case mémoire d'indice SP (M[SP] si M est le tableau de mémoire)

Ce concept est fondamental. Si vous avez compris, félicitations vous avez compris les pointeurs :

- SP est un pointeur (une adresse)
- [SP] est la valeur pointée

## Process en mémoire avec pile

```
pile
données
code
```

La pile se remplit en diminuant de valeur.

Sa taille est de l'ordre de 10MiB et est déterminée par le système d'exploitation.

La pile est nécessaire à l'exécution du programme mais pas pour sa conception. Le fichier contenant le programme ne contient pas la pile.

### Gestion des variables avec la pile

Reprenons notre petite boucle python :

```python
for i in range(10):
  print(i)
```

Et utilisons la pile pour gérer i :

```
section .text

main:
    empile 0
    print [SP]
    incrémente [SP] 
    si [SP] < 10 saute en main
    dépile
```

Où `incrémente [SP]` signifie $M[SP] += 1$

- la variable i est créée par empilage et supprimée par dépilage.
- c'est toujours le même accès au 1er élément de la pile

Cette façon de faire se généralise pour toutes les variables. A chaque bloc de code :

- au début du bloc on crée toutes les variables du bloc par empilement
- pendant le bloc : on accède aux variables toujours avec le même indice
- à la fin du bloc : on supprime toutes les variables par dépilage

{% faire %}
Écrivez le code suivant avec la pile et en utilisant les règles de création et de suppression des variables :

```python
for i in range(10):
  for j in range(20):
    print(i+j)
```

{% endfaire %}
{% details "solution" %}
On crée une variable pour chaque bloc :

```
section .text

main:
    empile 0
boucle:
    empile 0
    print [SP+1] + [SP]
    incrémente [SP] 
    si [SP] < 10 saute en boucle
    dépile
    incrémente [SP]
    si [SP] < 20 saute en main
    dépile
```

On aurait aussi pu créer les deux variables en une fois :

```
section .text

main:
    empile 0
    empile 0
boucle:
    print [SP+1] + [SP]
    incrémente [SP] 
    si [SP] < 10 saute en boucle
    place dans [SP] la valeur 0
    incrémente [SP+1]
    si [SP+1] < 20 saute en main
    dépile
```

Cette dernière implémentation est cependant moins élégante.

{% enddetails %}

Toutes les variables sont

### Appels de fonctions

La pile, si pratique pour gérer toutes nos variables est également d'une efficacité redoutable pour gérer les appels de fonctions.

Prenons le code python :

```python
def ma_fct(x);
  for i in range(20):
    print(x+i)

for i in range(10):
  ma_boucle(i)
```

Et écrivons ce programme avec la pile :

```
section .text

main:
    empile 0
boucle:
    empile retour
    empile [SP]
    saut ma_fct
retour:
    dépile 
    dépile
    incrémente [SP]
    si [SP] < 10 saute en main
    dépile
    saute en fin
ma_fct:
fct_boucle:
    empile 0
    print [SP+1] + [SP]
    incrémente [SP] 
    si [SP] < 20 saute en fct_boucle
    dépile
    saute en [SP + 2]
fin:
```

La pile nous a permis de stocker les paramètres et le saut de retour de la fonction. En appliquant le même principe pour toutes les fonctions :

- empilage du saut de retour
- empilage des paramètres
- saut vers la fonction
- dépilage des paramètres
- dépilage de la valeur de saut de retour

On a crée un moyen simple et efficace de gérer des fonctions (c'est même récursif !) C'est ce qu'o appelle une [ABI](https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_conventions).

{% info %}
Les appelles et retour de fonctions ont souvent leurs propres instructions qui gèrent le saut, l'empilage et le dépilage de la valeur de retour.
{% endinfo %}

### Limitation de la pile

La pile est un moyen efficace de gérer les variables et les appels de fonctions. Elle possède cependant un inconvénient :

- on ne peut y placer que des élément dont on connaît la taille
- une fois la variable dans la pile, sa taille ne peut plus changer.

On ne peut mettre que des choses pas trop grosse, la taille globale de la pile est relativement petite (10MiB), et dont on connaît la taille. De plus une fois que la donnée est dans la pile on ne peut plus modifier sa taille.

#### Chaîne de caractères

Si l'on demande à un utilisateur de taper un texte, ou 
> TBD faire exemple
>
#### Taille changeante

for i 
  for j

et i passe au dessus de 255

## Tas

Allocation dynamique de mémoire

> le tas


+1 toute les milliseconde. Taille va augmenter. On ne peut pas connaître la taille amx avant de l'exécuter

### tas plus pile en mémoire

<https://en.wikipedia.org/wiki/Data_segment#Program_memory>

## bibliothèque partagée

<https://en.wikipedia.org/wiki/Shared_library>

## forme finale d'un process

> TBD :Chose que l'on peut lire/ecrire/exécuter.

### sur le disque dur

relocation des bibliothèques partagées

- mémoire
- fichier

### en mémoire

en vrai :

```
noyau
pile
bibliothèques partagées : read only
heap
données
code : lecture seule
```

relocation des la bibliothèque partagée

### pile et tas quand les utiliser

- tas gros et/ou pas connu au départ
- tas partageable entre fonctions : modifie des pointeurs
- pile rapide mais : taille connu et petit (10MiB)
- copie (push avant de passer les fonctions)

différence entre tableau de QW et tableau de POInteur (python vs C).

## thread

> TBD : On associe à chaque process une unité d'exécution qui exécute les instruction du code une à une. On appelle ça un thread.
> Un process peut avoir plusieurs thread.
> TBD process et thread. Un contexte d'exécution par thread et la mémoire pour le process.


ce qui exécute le code unique, mais ce n'est pas toujours le cas.

Exemple calcul matriciel.

Il peut y en avoir plusieurs exécution par process.

process = organisation
thread = exécution
