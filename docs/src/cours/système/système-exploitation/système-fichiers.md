---
layout: layout/post.njk

title: Système de fichiers

eleventyComputed:
  eleventyNavigation:
    key: "{{ page.url }}"
    title: "{{ title | safe }}"
    parent: "{{ '../' | siteUrl(page.url) }}"
---

> TBD : en super chantier.

> Plan de <https://www.youtube.com/watch?v=jpKpbyYjAWU&list=PL2Yggtk_pK6-R9ehjj0AoTnWrNOLChuld&index=66>

- fichier = ensemble de byte sur le disque dur
- le système ajoute des métas data :
  - nom
  - propriétaire
  - son groupe
  - permissions
  - dernière fois que le fichier a été ouvert
  - ...
  - extension :
    - (attention, c'est juste une convention Ca n'a aucune incidence sur le fichier en lui-même. Ca permet juste à l'OS de chercher des applications par défaut à exécuter. Mais rien ne vous empêche d'appeler vos images `mon_image.py`, ça ne la transformera pas par magie un fichier python)
    - pour les fichiers qui ne sont pas du texte, le créateur du format va ajouter une [signature](https://en.wikipedia.org/wiki/List_of_file_signatures) en début de fichier (on appelle ça des *magic number*) pour caractériser son format. C'est encore une fois une convention, seule la négative est assurée (si cela ne commence pas par les 5 bytes `25 50 44 46 2D` c'est sur que ce n'est pas un fichier pdf)

lien : faire ça après les inodes

- symbolique
- physique

Un système de fichier est organisée en arbre :

- fichiers sont les feuilles
- les nœuds internes sont des dossiers : les enfants d'un nœud interne ont tous des noms différents
- un nœud interne a toujours au moins deux enfants :
  - lui-même (.)
  - son parent (..) (le parent est lui-même pour la racine)

Cette structure permet de voyager dans tout l'arbre en descendant les enfant ou en remontant les parent et ce de la même manière (avec ..)

Opérations que l'on peut faire sur les fichiers, selon les permissions :

- créer / supprimer : dépend des droits du dossier parent
- ouvrir / fermer / seek
- lire en seek
- écrire (remplacer) / append (écrit à la fin)
- changer des méta-datas

Opérations que l'on peut faire sur les dossiers, selon les permissions :

- créer / supprimer : dépend des droits du dossier parent
- ouvrir / fermer
- lire
- changer des méta-datas

Le système doit connaître tous les fichiers utilisés. C'est une liste où chaque entrée est un [descripteur de fichier](https://en.wikipedia.org/wiki/File_descriptor) qui contient :

- quel fichier est concerné
- type d'accès lecture, écriture, etc.
- le nombre de threads qui utilisent cette entrée
- la position dans le fichier

Un même fichier peut apparaître plusieurs fois, mais si c'est deux accès en écriture, ou un accès en lecture et un autre en écriture, il peut se passer des choses bizarres. Ouvrir un fichier en écriture commençant par créer un nouveau fichier.

Plusieurs thread peuvent se partager la même entrée.


Le disque est séparé en bloc (pages) de taille 8 KiB, un fichier est une liste chaînée de ces blocs.

Taille min d'un fichier = 1 bloc logique

Il faut avoir sur le disque dur à la fois les fichiers, leurs méta-data et l'organisations (dossier/ fichier, mais aussi la liste chaînée des blocs de chaque fichier).

On réserve des blocs pour la gestions et d'autres pour le contenu de chaque fichier.

On a une table de taille le nombre de bloc et chaque entrée possède le bloc suivant dans le fichier.

Une fois qu'on a le premier bloc d'un fichier, on a les suivants. On a un disque dur de 8 blocs (codé sur 3b).

Si on sait que le fichier commence en 4, on connaît ses 3 blocs.

```
0 :
1 :  X       ; avec un flag
2 :
3 :
4 :  7
5 :
6 :
7 :  1
```

Cette liste est un bloc (opu plusieurs blocs) du disque dur. Que l'on peut garder en mémoire, ce qui rend les accès plus rapide.

Ex : 

- disque dur de 1 TiB
- taille d'un bloc 8 KiB
- il y a : $2^{40} / ( 8 \cdot 2^{10}) = 137438953472$ pages
- il faut 37b pour encoder les nombres allant de 0 à 137438953472
- la taille de la table vaut $37 \cdot 137438953472 \simeq 600 GiB$

> TBD : c'est beaucoup de trop. Il faut faire autrement
> Structure en Arbre : inode pour fichier
> -> blocks
> -> 1-indirect -> blocs
> -> 2-indirect -> 1-indirect -> blocs
> -> 3-indirect -> 2-indirect -> 1-indirect -> blocs

Le cache fait que l'accès va aller vite, on a les tables en mémoire.

<https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout>

> logique. Physique = 512B ?

<https://tldp.org/LDP/sag/html/filesystems.html>


un fichier peut être un dossier ou un vra
i fichier

Fichiers et liens : 

- fichier sur le disque dur
- lien est un
> TBD disque dur/ partitions
> notion de fichier, et de système de fichier (avec table)
> il y en a plein.

> TBD disque dur/ partitions
> notion de fichier, et de système de fichier (avec table)
> il y en a plein.


> TBD : Disques dur, USB
> TBD : Formatage et accès. Tout un tas (FAT, NTFS windows, zfs, btrfs)...
> copy on write
> journalisé
> partitions
>
> <https://wiki.debian.org/ZFS>
> <https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout>
>
> <https://blogs.oracle.com/linux/post/understanding-ext4-disk-layout-part-1>
>
> zfs : <https://opensolaris-discuss.opensolaris.narkive.com/86NkhwTm/inode-numbers-on-zfs> ?

<https://medium.com/@boutnaru/linux-what-is-an-inode-7ba47a519940>

<https://tldp.org/LDP/tlk/fs/filesystem.html>
diff entre ext2, 3 et 4 : <https://www.easeus.fr/partition-manager-tips/systeme-de-fichiers-ext2-ext3-ext4.html>