---
layout: layout/post.njk

title: Système de fichiers

eleventyComputed:
  eleventyNavigation:
    key: "{{ page.url }}"
    title: "{{ title | safe }}"
    parent: "{{ '../' | siteUrl(page.url) }}"
---

> TBD : journalisation : faire des dessins.

Un système de fichiers est une structure permettant de stocker de l'information sur un disque dur. Un système a donc habituellement plusieurs systèmes de fichiers : un pour chaque disque dur et un pour chaque clé usb insérée.

Il est possible d'avoir plusieurs systèmes de fichier par disque dur en le [partitionnant](https://fr.wikipedia.org/wiki/Partition_(informatique)).

Un [système de fichier](/tutoriels/fichiers-navigation) est organisé en arbre :

- chaque nœud est appelé dossier (ou répertoire, *directory* en anglais)
- chaque nœud possède toujours au moins deux enfants :
  - `'.'`{.fichier} qui représente lui-même
  - `'..'`{.fichier} qui représente son parent
- les fichiers sont les feuilles de l'arbre, ce sont eux qui contiennent l'informations stockée

Les dossiers et les fichiers possèdent des meta-données qui les spécifient :

- leur nom
- leur propriétaire et leur groupe d'appartenance
- leurs permissions (lire/écrire et exécuter) pour leur propriétaire, leur groupe et le reste des utilisateurs
- la dernière fois qu'ils ont été utilisé
- la date de leur création
- ...

## Utilisation d'un système de fichier

Opérations que l'on peut faire sur les fichiers, selon les permissions :

- créer / supprimer : dépend des droits du dossier parent
- ouvrir / fermer / seek
- lire en seek
- écrire (remplacer) / append (écrit à la fin)
- changer des méta-datas

Opérations que l'on peut faire sur les dossiers, selon les permissions :

- créer / supprimer : dépend des droits du dossier parent
- ouvrir / fermer
- lire
- changer des méta-datas

Le système doit connaître tous les fichiers utilisés. C'est une liste où chaque entrée est un [descripteur de fichier](https://en.wikipedia.org/wiki/File_descriptor) qui contient :

- quel fichier est concerné
- type d'accès lecture, écriture, etc.
- le nombre de threads qui utilisent cette entrée
- la position dans le fichier

Un même fichier peut apparaître plusieurs fois, mais si c'est deux accès en écriture, ou un accès en lecture et un autre en écriture, il peut se passer des choses bizarres. Ouvrir un fichier en écriture commençant par créer un nouveau fichier.

Plusieurs thread peuvent se partager la même entrée.

## Journalisation

{% lien %}
<https://en.wikipedia.org/wiki/Journaling_file_system>
{% endlien %}

Stocker ses données sur le disque est ue opération courante mais intrinsèquement dangereuse, la moindre erreur peut invalider des données ce qui peut se révéler catastrophique.

Des mécanisme de [journalisation](https://fr.wikipedia.org/wiki/Journal_(syst%C3%A8me_de_fichiers)) sont présent dans tous les systèmes de fichiers utilisés pour des ordinateurs de bureau ou serveurs. Ils permettent de ne pas perdre de données en cas de crash système.

Ils fonctionnent de la même manière :

1. ils regroupent les opérations effectuées sur le disque en [transaction](https://en.wikipedia.org/wiki/Transaction_processing) : une suite d'opérations de lecture/écriture à faire séquentiellement et sans interruption
2. la transaction n'est effectuée que si elle est au préalable sauvée sur le disque dur

Ceci nécessite un espace dédié sur le disque dur où les transactions sont stockées. Comme la suite de transactions à effectuer est séquentielle, l'espace de stockage est une liste circulaire.

Chaque transaction est un intervalle de cette liste comprenant un bloc de départ, une suite de blocs d'opérations à effectuer, un bloc de fin. Une fois le bloc de fin écrit dans la liste, la transaction est considérée comme terminée et peut être effectuée sur le système.

Liste circulaire :

```
init A |  opération 1 | opération 2 | ... | opération n | bloc fin A | init B | ...

```

Si un crash intervient au milieu de la transaction, elle peut être intégralement rejouée pour être complétée.

## Formats

Cette organisation logique d'un système de fichier cache une grande variété d'implémentations possibles pour stocker effectivement les données sur un disque dur.

Cette structure n'est pas gratuite et prend couramment plus de $1\\%$ de la taille totale du disque.

De plus, la nécessaire rétro-compatibilité des systèmes les rend souvent difficile à comprendre.

### Formats courants

Tous les formats sont contraints par la structure d'un disque dur qui lit ses données par page (pour les vieux disques dur non SSD, on parle de secteur) qui est habituellement de 4KiB. Traditionnellement, la taille d'un bloc est de 512B (c'est parfois cette valeur qui est rendue par un disque [même si en interne la taille est plus importante](https://wiki.archlinux.org/title/Advanced_Format#NVMe_solid_state_drives)), c'est pourquoi nombre de format découpent leurs structures en paquets de 512B.

Nous allons étudier plus avant 2 grandes structures, utilisées couramment :

- format FAT : utilisées pour les partitions de boot et les disques USB
- format extfs : format Linux

Ces formats stockent dans le même espace les données (les fichiers) et l'organisation hiérarchique du système (les dossiers). Leurs deux approches diffèrent peu (l'un a une structure linéaire, l'autre arborée), mais cela suffit à les rendre très différent à l'usage.

### Format FAT

{% aller %}
[Format FAT](./FAT){.interne}
{% endaller %}

### Format ext4

{% aller %}
[Format ext4](./ext){.interne}
{% endaller %}

### Autres formats

- [NTFS](https://en.wikipedia.org/wiki/NTFS) (windows)
- [zfs](https://fr.wikipedia.org/wiki/ZFS) (l'avenir au présent)
