% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Algorithmes gloutons},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifluatex
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\title{Algorithmes gloutons}
\author{}
\date{}

\begin{document}
\maketitle

\hypertarget{but}{%
\subsection{But}\label{but}}

Un \href{https://fr.wikipedia.org/wiki/Algorithme_glouton}{algorithme
glouton} choisi à chaque étape la meilleure possibilité localement. Ce
type d'algorithme est très utilisé pour résoudre des problèmes où l'on
veut une réponse rapide à un problème, mais pas forcment une réponse
optimale. D'un point de vue théorique, ces algorithmes extrêmement
important, il sont par exemple en bijection avec la
\href{https://fr.wikipedia.org/wiki/Matro\%C3\%AFde}{structure de
matroïde}.

Intérêt :

\begin{itemize}
\tightlist
\item
  donne toujours un résultat
\item
  souvent de complexité faible
\end{itemize}

Problème :

\begin{itemize}
\tightlist
\item
  ne donne pas forcément le meilleur résultat : une \emph{heursitique}
\item
  pas forcément de solution unique
\end{itemize}

Pour beaucoup de problèmes d'optimisation, un algorithme glouton est
optimal pour une version simplifiée du problème. Comme l'algorithme va
vite, on peut recommencer plusieurs fois pour trouver une meilleure
solution.


\hypertarget{optimalituxe9-et-glouton}{%
\subsection{optimalité et glouton}\label{optimalituxe9-et-glouton}}

Les problèmes d'optimalité demandent de trouver, parmi un ensemble de
solutions possible, une solution minimisant (ou maximisant) un critère.
Par exemple :

\begin{itemize}
\tightlist
\item
  pour un ensemble de coûts de constructions possibles d'une voiture,
  trouver celle qui minimise le coûts tout en maximisant la qualité
  totale des pièces,
\item
  parmis tous les parcours passant par un ensemble de villes données,
  choisir celui qui minimise le nombre de kilomètres parcourus
\item
  maximiser le nombre de films projetés dans un multiplexe de cinéma
\item
  \ldots{}
\end{itemize}

La difficulté de ces problèmes vient du fait que l'on ne peut a priori
pas trouver la meilleure solution sans les examiner toutes. Et s'il y a
beaucoup de solutions ça peut prendre vraiment beaucoup de temps.

Certains problèmes cependant permettent d'être résolus en construisant
petit à petit une solution, sans jamais remettre en cause ses choix. On
peut alors souvent trouver très rapidement la meilleurs solution
possible. On peut également utiliser cette solution construite petit à
petit pour trouver une solution approchée à un problème plus général.
Cette classe d'algorithme qui construit itérativement d'une solution est
appelée \emph{algorithmes gloutons}.

\hypertarget{exercice-1-le-gradient}{%
\subsubsection{exercice 1 : le gradient}\label{exercice-1-le-gradient}}

On suppose que l'on feuille trouver le minimum d'une fonction $f$
dérivable.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Décrivez l'algorithme du gradient sous la forme d'un algorithme
  glouton
\item
  montrer qu'il peut converger vers la solution
\item
  montrer qu'il peut ne pas converger vers la solution
\end{enumerate}

L'algorithme de la descente de gradiant : qu'un minimum local.

\hypertarget{condition-nuxe9cessaire-et-suffisante-doptimalituxe9.}{%
\subsubsection{condition nécessaire et suffisante
d'optimalité.}\label{condition-nuxe9cessaire-et-suffisante-doptimalituxe9.}}

Pour qu'un algorithme glouton \textbf{trouve une solution optimale} il
faut :

\begin{itemize}
\tightlist
\item
  \textbf{initialisation} : montrer qu'il existe une solution optimale
  contenant le 1er choix de l'algorithme
\item
  \textbf{récurrence} : montrer que la première différence entre une
  solution optimale et la solution de l'algorithme ne peut résulter en
  une meilleure solution. Pour cela on cherchera une solution optimale
  dont les choix coïncident le plus longtemps possible avec la solution
  donnée par notre algorithme et on prouvera qu'elles coïncident jusqu'à
  la fin.
\end{itemize}

\hypertarget{ordonnancement}{%
\subsection{ordonnancement}\label{ordonnancement}}

Les problèmes d'ordonnancement son multiples. Certains sont durs
d'autres faciles. Mais un algorithme glouton permet de trouver souvent
une solution acceptable pour beaucoup d'entres eux et même parfois
optimale pour certains problèmes.

Celui ci est résoluble par un algorithme glouton : On considère \(m\)
produits de durée 1 à fabriquer. Si le produit \(i\) est réalisée avant
la date \(d_i\) on peut le vendre pour un prix \(p_i\), sinon il est
invendable. Proposez un algorithme permettant de maximiser les profits
en considérant que l'on a qu'un seul ouvrier.

\hypertarget{ensemble-compatible}{%
\subsubsection{ensemble compatible}\label{ensemble-compatible}}

Un ensemble de produit est dit \emph{compatible} s'il existe un
ordonnancement de leur de production permettant de tous les vendre
(chaque produit est fabriqué avant sa date de péremption).

Montrer qu'un ensemble de produits est compatible si et seulement
l'ordonnancement par date \(d_i\) croissante permet de tous les vendre.

\hypertarget{algorithme}{%
\subsubsection{algorithme}\label{algorithme}}

Montrer que l'algorithme glouton suivant est optimal :

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  on trie les produits par prix décroissant
\item
  ensemble = \{\}
\item
  pour chaque produit x dans cet ordre : on ajoute x à ensemble s'il
  reste compatible
\item
  rendre ensemble (qui est un ensemble de profit maximal)
\end{enumerate}

\emph{Nota bene} : pour la preuve, on pourra comparer une solution
optimale et la solution donnée par notre algorithme en regardant la
première différence.

\hypertarget{application-le-rendu-de-piuxe8ces}{%
\subsection{Application le rendu de
pièces}\label{application-le-rendu-de-piuxe8ces}}

Proposez un algorithme glouton permettant de rendre la monnaie d'un
achat en un nombre minimum de pièces valant 5, 3 et 1 pokédollar.

Démontrez que votre algorithme est bien optimal.

\hypertarget{systuxe8me-de-piuxe8ces-quelconque}{%
\subsubsection{système de pièces quelconque
?}\label{systuxe8me-de-piuxe8ces-quelconque}}

\begin{itemize}
\tightlist
\item
  donnez une version générale de votre algorithme de rendu de pièce,
  c'est à dire où l'on a $n$ pièces valant
  $p_1 < p_2 < \dots < p_n$.
\item
  Cet algorithme glouton de va pas donner de solution optimale quelque
  soit le système de pièce, donnez un exemple pour lequel ça ne
  fonctionne pas.
\item
  montrer que l'algorithme glouton fonctionne pour un système de pièces
  supercroissant, c'est à dire où $p_i \geq \sum_{j< i} p_j$ avec
  \(_i\) les valeurs de pièces rangés par ordre croissant.
\item
  donnez un exemple de système de pièce supercroissant.
\end{itemize}

\hypertarget{probluxe8mes-de-salles-de-cinuxe9ma}{%
\subsection{Problèmes de salles de
cinéma}\label{probluxe8mes-de-salles-de-cinuxe9ma}}

Un gérant de cinéma a en sa possession \(m\) films caractérisés chacun
par un couple (\(d_i\), \(f_i\)) où \(d_i\) est l'heure de début du film
et \(f_i\) l'heure de fin. Il se pose 2 problèmes

\hypertarget{voir-un-maximum-de-films}{%
\subsubsection{voir un maximum de
films}\label{voir-un-maximum-de-films}}

Proposez (et prouvez) un algorithme permettant de rendre une liste
maximale de film à voir en une journée.

\hypertarget{nombre-minium-de-salles-pour-placer-tous-les-films-en-stock}{%
\subsubsection{nombre minium de salles pour placer tous les films en
stock}\label{nombre-minium-de-salles-pour-placer-tous-les-films-en-stock}}

Proposez (et prouvez) un algorithme permettant de rendre le nombre
minium de salle et son organisation permettant de projeter tous les
films.

\hypertarget{le-probluxe8me-du-sac-uxe0-dos}{%
\subsection{Le problème du sac à
dos}\label{le-probluxe8me-du-sac-uxe0-dos}}

Le
\href{https://fr.wikipedia.org/wiki/Probl\%C3\%A8me_du_sac_\%C3\%A0_dos}{problème
du sac à dos} est un exemple de problème d'optimisation. Il fait parti
des problèmes les plus dur du monde car les solutions n'entretiennent
pas de relation les unes avec les autres, il faut a priori toutes les
regarder pour trouver la meilleur, et il y en a beaucoup.

Il est possible de modéliser beaucoup de problèmes courant par un
problème de sac dos, en particuliers les:

\begin{itemize}
\tightlist
\item
  problème de découpe pour minimiser les chutes
\item
  problème de remplissage (déménagement)
\end{itemize}

\hypertarget{uxe9noncuxe9-du-probluxe8me}{%
\subsubsection{énoncé du problème}\label{uxe9noncuxe9-du-probluxe8me}}

On dispose de :

\begin{itemize}
\tightlist
\item
  $n$ objets ayant chacun un poids $w_i$ (\emph{weight}) et une
  valeur nutritionnelle $p_i$ ($1 \leq i \leq n$)
\item
  d'un sac à dos d'une contenance de W
\end{itemize}

On veut maximiser la valeur nutritionnelle que l'on peut emporter avec
notre sac.

\hypertarget{on-essaie}{%
\subsubsection{On essaie}\label{on-essaie}}

On suppose que l'on est un voleur et que l'on peut voler 3 produits :

\begin{itemize}
\tightlist
\item
  produit A, 2kg, 100€
\item
  produit B, 2kg, 10€
\item
  produit C, 3kg, 120€
\end{itemize}

Selon la valeur du sac à dos quel est la quantité maximale d'argent que
le voleur peut se faire ?

\hypertarget{sac-uxe0-doc-fractionnel}{%
\subsubsection{sac à doc fractionnel}\label{sac-uxe0-doc-fractionnel}}

Si l'on peut prendre qu'une partie des objets (comme pour une poudre ou
un liquide), le problème peut être résolu par un algorithme glouton.

Problème :

\begin{itemize}
\tightlist
\item
  entrée :

  \begin{itemize}
  \tightlist
  \item
    liste de produits décrit par leur masse et le prix total
  \item
    une masse totale transportable
  \end{itemize}
\item
  sortie : une liste une de produit et leur masse qui maximise le prix
  pour une masse ne dépassant pas la masse transportable
\end{itemize}

\hypertarget{ruxe9solvez-le-probluxe8me-avec-les-donnuxe9es-pruxe9cuxe9dentes}{%
\paragraph{résolvez le problème avec les données
précédentes}\label{ruxe9solvez-le-probluxe8me-avec-les-donnuxe9es-pruxe9cuxe9dentes}}

On suppose que l'on peut découper les objet pour obtenir une fraction de
leurs valeurs et que notre sac à une capacité de 4kg et de 5kg.

\hypertarget{algorithme-glouton}{%
\paragraph{algorithme glouton}\label{algorithme-glouton}}

Proposez un algorithme glouton pour résoudre ce problème et montrer
qu'il est optimal.

\hypertarget{si-on-ne-peut-pas-couper}{%
\paragraph{si on ne peut pas couper ?}\label{si-on-ne-peut-pas-couper}}

Monter un exemple où le glouton ne marche pas si l'on ne peut pas
prendre une partie fractionnelle d'un produit.

\hypertarget{sac-uxe0-dos-non-fractionnel-optimal}{%
\subsubsection{sac à dos non fractionnel
optimal}\label{sac-uxe0-dos-non-fractionnel-optimal}}

On peut trouver un algorithme optimal pour le problème du sac à dos en
remarquant que l'on peut construire une solution optimale avec \(i\)
objets à partir d'une solution optimale à \$i-1 objets.

En effet la solution optimale à $i$ objets pour une capacité $W$ est
soit :

\begin{itemize}
\tightlist
\item
  une solution optimale à $i-1$ objets pour une capacité $W$ si on
  ne prend pas l'objet \(i\),
\item
  une solution optimale à $i-1$ objets pour une capacité $W - w_i$
  si on prend l'objet \(i\).
\end{itemize}

\hypertarget{algorithme-1}{%
\paragraph{algorithme}\label{algorithme-1}}

Ecrivez l'algorithme permettant de résoudre le problème.

Et explicitez pourquoi cet algorithme n'est pas glouton.

\hypertarget{on-maurait-menti}{%
\paragraph{on m'aurait menti ?}\label{on-maurait-menti}}

Quel est la complexité de cet algorithme.

\hypertarget{hein}{%
\paragraph{hein ?}\label{hein}}

Quel est le piège ?

\end{document}
