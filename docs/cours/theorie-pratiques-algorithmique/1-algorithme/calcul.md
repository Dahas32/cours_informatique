---
layout: page
title:  "Algorithme : calcul"
category: cours
---

> [Théorie et pratiques algorithmique]({% link cours/theorie-pratiques-algorithmique/index.md %}) / [algorithme]({% link cours/theorie-pratiques-algorithmique/1-algorithme/index.md %}) / [calcul]({% link cours/theorie-pratiques-algorithmique/1-algorithme/calcul.md %})
{: .chemin}

Dans [la partie précédente]({% link cours/theorie-pratiques-algorithmique/1-algorithme/pseudo-code.md %}), on a donné unefaçon d'écrire des pseudo-codes. Mais est-ce la seule façon de faire ? Et, au final, que peut-on réellement faire avec un algorithme ?

## expressivité du formalisme

Lorsque nous avons défini un pseudo-code dans la partie précédente on a demandé à ce qu'il permette , entre autres :

* de lire et d'affecter des entiers à des variables
* d'avoir l'opérateur d'égalité
* d'exécuter un bloc d'instruction puis un autre
* exécuter un bloc d'instruction si une expression booléenne est vraie et un autre bloc sinon
* exécuter un un bloc d'instruction tant qu'une expression booléenne est vraie

On peut montrer que s'il n'a que les 5 conditions ci-avant, il est équivalent à tout ce qu'on 

Alors il pourra écrire 
<https://www.cs.odu.edu/~zeil/cs390/latest/Public/turing-complete/index.html>


<https://fr.wikipedia.org/wiki/Brainfuck>, même si j'aime assez le whitespace.
<https://fr.wikipedia.org/wiki/Langage_de_programmation_exotique>


## machine de turing

passer d'un pseudo code à la machine. entier/réels/chaine de caractères.

-> pas réels.

reprendre les propriétés de turing

* que peut-on calculer ? 
* de pseudo code à calcul de f(N) -> N
* ce qu'on peut calculer ne dépend pas de comment on l'écrit (thèse de church) et plein d'équivalence. 


pour l'instant tous les pseudo-code qu'on a écrit s'arrêtent tout le temps. Mais celui là ? syracuse. On ne sais pas. 