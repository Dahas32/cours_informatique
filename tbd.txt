## site :

- dépendances cours MPCI avec un json
- mettre escape html latex avec un shortcode 

- NAVIGATION PLUGIN pour remonter la hiérarchie automatiquement

## autres
- ajoute code recuit simulé au projet glouton voyageur de commerce.
- ajout solution exacte programmation dynamique voyageur de commerce à la fin.
- voyageur commerce : recroisement faux.

- séparer clairement le cours objet ? En ajoutant ce qu'il faut.

- cours base/code ajout prérequis au cours
- faire un tuto seaborn. 
	-utiliser le projet-tris comme base
	- parler des palettes

- notions python :
	* mutable et non mutable
	* itérateurs ?
	* dictionnaires
	* lambda
	* list comprehension

- système de fichier : 
	* liens
	* permissions
	* unix et tout est fichier
	* fichiers spéciaux (comme `/dev/audio` par exemple)
	* une application mac est un dossier.
	* comment écrire sur le disque dur, le [file system](https://en.wikipedia.org/wiki/Comparison_of_file_systems)

- graphes : 
	- prés-requis complexité, algo et python pour le cours.
		- encodage.md
	- arbres : combien d'arbre ? Encodage prüfer et application à un arbre aléatoire (!= différent de la structure).

-caractères unicode : <http://ressources.univ-lemans.fr/AccesLibre/UM/Pedago/physique/02/divers/unicode.html>

- parie code :  poetry et venv à ajouter quelque part.

- partie théorie : 
	* logique = formule logique = sat
	* problème de décision : sous ensemble vrai d'un ensemble. se dérive de langage décidable
	* refs : 
		poly de Pascal.

		<https://en.wikipedia.org/wiki/List_of_undecidable_problems>
		<https://plato.stanford.edu/entries/church-turing/>
		<http://pageperso.lif.univ-mrs.fr/~kevin.perrot/documents/2016/calculabilite/Cours_16.pdf>
		<https://www.cs.odu.edu/~zeil/cs390/latest/Public/turing-complete/index.html>


- ressource dans la partie url :
	* curl : utilisation
	* un serveur en python avec des fichiers en chroot.
	* faire du telnet : pour illustrer les protocoles
	* RFC
	* autre protocole (genre envoyer un mail ?)


## MPCI

- faire démo master theorem
- faire mélange juste avant tri.

- projet exponentiation : trop court ?

- trier un tableau : ne faire que les compliqués.

- figures : utiliser seaborn + approximation courbes pour les calculs de complexités

- changer nom par variable partout dans le cours mémoire et objets
- utf8 table à changer https://www.compart.com/en/unicode/block
- utf8 hex converter online à trouver
- play -traw -r44100 -b16 -c1 -eunsigned <file> (fait parti du package sox) pour écouter ses fichiers
- schema des block de fichiers dans le disque dur (avec les MZ pour dos ?)
- parler de la fat ? La voir avec un explorateur de disque ?
- données : 
    - séparer fichier texte du reste
    - faire un fichier binaire (image ?)
    - enregistrer fichier texte en byte
- faire un cours juste sur fichier texte (après dictionnaire t set ?)
- faire un cours juste sur les données csv et json

- voyageur de commerce : trop dur à remplacer.
- pourquoi pas sac à dos avec bourrinage pour résoudre puis l'algo avec preuve fine.

- faire plus de glouton avec du code en classes et des exo d'approximation (p600 Kleinberg et Tardos).

- cours sous-chaines : 
	1. naif
	2. amélioration "à la marge"
	2.1 BMH avec amélioration complexité min 
	2.2 naif avec break pour complexité en moyenne
	3. rabin-Karp
	4. KMP
	4.1 naif avec idée de l'amélioration KMP
	4.2 KMP
	
- sous-chaines : mettre des exemples vrais et pas de aaa?aaa 

- ajouter théorie
	- clauses logiques
	- sat
	- ajouter théorie thm de cook / NPC 
	- SAT -> 3-SAT
- ajouter : hasard en informatique

- ajouter exemple d'utilisation pour projet alignement. En particulier l'utilisation de la classe Alignement



Remarques élèves :

- faire des qcm
- des dm en groupes

- si les tests sont trop durs ça démotive (faire des étapes dans les tests ?)
