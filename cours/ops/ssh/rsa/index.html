<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <title>rsa</title>

    <link href=/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css rel="stylesheet">
    <link href=/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css rel="stylesheet">

    <link href=/cours_informatique/assets/stylesheets/main.css rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
  src=/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js></script>
  
    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1000px] mx-auto px-4">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
          <a class="mx-2" href="/cours_informatique/about">About</a>
        </div>
      </div>
    </header>

    <main class="max-w-[1000px] mx-auto px-4">
      
<article>

  <h1  class="mb-1">rsa</h1>
  <div class="mb-4">
    

    
      <div class=" px-4 flex items-center">
        
          <div class="font-bold">Auteurs : </div>
        
        <ul class="flex not-prose list-none my-0 last:after:content-['•'] last:after:px-1 mx-0 px-1">
          
            <li class="before:content-['•'] before:px-1">Herbelleau Romain</li>
          
            <li class="before:content-['•'] before:px-1">Laurent Léo</li>
          
            <li class="before:content-['•'] before:px-1">Dégeorges Laurie</li>
          
        </ul>
      </div>
    
  </div>

  
    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z" />
</svg>
<div class="pl-8 mr-8">

<a href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a href="/cours_informatique/cours/ops/">Ops</a><span class="px-1">/</span><a href="/cours_informatique/cours/ops/ssh/">ssh</a><span class="px-1">/</span><a href="/cours_informatique/cours/ops/ssh/rsa/">rsa</a>

</div></div>

  

  <!-- début résumé -->
<p>Algorithme rsa, de chiffrement asymétrique utilisé par défaut avec ssh.</p>
<!-- fin résumé -->
<p>Cet algorithme a été présenté en 1977 par Ronald Rivest, Adi Shamir et Leonard Adleman.</p>
<p>Le chiffrement RSA s’appuie sur le fait que factoriser un produit de deux nombres premiers distincts est difficile.</p>
<p>La clé publique et la clé secrète sont calculées grâce a l'<strong>algorithme d’Euclide</strong> et aux <strong>coefficients de Bézout</strong>, et le déchiffrement grâce au <strong>petit théorème de Fermat</strong>.</p>
<p>Quelques outils mathématiques et algorithmiques nécessaires :</p>
<ul>
<li>Le <strong>petit théorème de Fermat</strong> dit :Si $p$ est un nombre premier et $a$ un entier alors <em>$$a^p = a \mod p$$</em>.<strong>Corollaire</strong> : si $p$ ne divise pas $a$ alors <em>$$a^{p-1} = 1 \mod p$$</em>.</li>
<li>La <strong>version améliorée du petit théorème de Fermat</strong> nous donne : Soient $p$ et $q$ deux nombres premiers distincts et soit $$n = pq$$. Pour tout $a$ entier tel que $$pgcd(a,n) = 1$$ (cad $n$ ne divise pas $a$) alors : <em>$$a^{(p-1)(q-1)} = 1 \mod n$$</em>.</li>
<li>L’<strong>algorithme d’Euclide</strong> permet de retourner facilement le reste d’une division euclidienne.</li>
<li>L’<strong>algorithme d’Euclide étendu</strong> permet d’obtenir les coefficients de Bézout.</li>
<li>Soit $a$ un entier, on dit que $x$ entier est un <strong>inverse de $a$ modulo $n$</strong> si <em>$$ax = 1 \mod n$$</em>. $a$ admet un inverse modulo $n$ si et seulement si $$pgcd(a,n)=1$$. De plus si $$au + nv = 1$$ (coefficient de bézout) alors $u$ est un inverse de $a$ modulo $n$.</li>
</ul>
<h2>Générer une paire de clés</h2>
<ul>
<li>Choix de deux nombres premiers distincts $p$ et $q$.</li>
<li>Calcul de $$n = pq$$.</li>
<li>Calcul de <strong>l’indicatrice d’Euler</strong> $$\Phi(n) = (p-1)(q-1)$$. <em>Pour calculer cette fonction il faut connaître $p$ et $q$, d'où son caractère privé</em>.</li>
<li>Choix d’un exposant $e$ tq $$pgcd(e,\Phi(n))=1$$.</li>
<li>Calcul de l’inverse $d$ de $$e \mod \Phi(n)$$ par l’<strong>algorithme d’Euclide étendu</strong>, on a $$de = 1 \mod \Phi(n)$$</li>
<li>La clé publique est constituée de <strong>$n$ et $e$</strong> et la clé privée de <strong>$d$</strong> .</li>
</ul>
<h2>Chiffrement du message</h2>
<ul>
<li>Il faut décomposer le message secret en paquets de taille <strong>$m &lt;n$</strong>.</li>
<li>Calcul du message chiffré <strong>$$x =  m^e \mod n$$</strong>. <em>$n$ et $e$ sont connus car on dispose de la clé publique</em>.</li>
</ul>
<h2>Déchiffrement du message</h2>
<ul>
<li>le message $x$ est décrypté à l’aide de sa clé privée $d$ : $m = x^d \mod n$</li>
<li>En effet le <strong>petit théorème de Fermat amélioré</strong> permet d’écrire : Soit $d$ l’inverse de $e$ modulo $\Phi(n)$ avec $$n = pq$$. Si <strong>$$x = m^e \mod n$$</strong> alors <strong>$$m=x^d \mod n$$</strong>.</li>
</ul>
<h2>Preuve</h2>
<ul>
<li>$d$ est l’inverse de $$e \mod \Phi(n)$$ <em>donc</em> $$d \cdot e = 1 \mod \Phi(n)$$ <em>donc</em> il existe $k$ entier tq $$d*e = 1+ k \Phi(n)$$</li>
<li>Le petit th de Fermat amélioré donne : si $$pgcd(m,n)=1$$ alors $$m^{\Phi(n)}=m^{(p-1)(q-1)}= 1 \mod n$$.</li>
<li>Si $$pgcd(m,n) = 1$$ alors modulo $n$ :<br>
<strong>$x$</strong> $$= (m^e)^d = m^{1+k Phi(n)} = m \cdot m^{k \Phi(n)} = m \cdot (m^{\Phi(n)})^k = $$(Fermat) $$m \cdot 1^k$$ $$= m \mod n$$</li>
<li>Si $$pgcd(m,n) \ne 1$$, alors $$pgcd(m,n)=p$$ et $$pgcd(m,q)=1$$ ou inversement.<br>
Si $p$ divise $m$, alors modulo $p$ : $$m = 0$$, $$x = m^{ed} = 0 \mod p$$, donc $$m^{ed} = m \mod p$$.<br>
Et modulo <em>q</em> : $$x = m^{ed} = m \cdot (m^{\Phi(n)})^k = m \cdot (m^{q-1})^{k (p-1)} =$$(Fermat) $$m \mod q$$.</li>
</ul>
<p>$pgcd(p,q)=1$ permet de conclure $$x=m^{ed}=m \mod n$$.</p>
<h2>Conclusion</h2>
<p>On a donc des algorithmes permettant de générer une paire de clés, et on peut chiffrer un message avec une clé, déchiffrable uniquement avec l’autre clé.</p>
<p>Pour plus d'informations voir cette vidéo sur le <a href="https://www.youtube.com/watch?v=Xlal_d4zyfo">chiffrement RSA</a>.</p>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1000px] mx-auto px-4">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
      </div>
    </footer>

  <script>
    MathJax.startup.document.getMathItemsWithin(document.body);
  </script>

  </body>
</html>