<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>circuits eulérien | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="circuits eulérien">
<meta name="author" content="François Brucker">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<meta property="og:description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<link rel="canonical" href="/cours_informatique/cours/graphes/circuits-euleriens.html">
<meta property="og:url" content="/cours_informatique/cours/graphes/circuits-euleriens.html">
<meta property="og:site_name" content="cours d’informatique">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="circuits eulérien">
<script type="application/ld+json">
{"description":"Support de cours/td d’informatique à l’école centrale marseille.","@type":"WebPage","headline":"circuits eulérien","url":"/cours_informatique/cours/graphes/circuits-euleriens.html","author":{"@type":"Person","name":"François Brucker"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">circuits eulérien</h1>Auteur : <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">François Brucker</span></span>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/graphes/">graphes</a> / <a href="/cours_informatique/cours/graphes/circuits-euleriens.html">euleriens</a></p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>Le but de ce cours est d’apprendre à coder un (multi-)graphe dirigé et de s’en servir pour trouver un circuit eulérien d’un de ces graphes (s’il existe).</p>

<p>Le code complet de ce tutoriel est disponible sur <a href="https://github.com/FrancoisBrucker/cours_informatique/tree/master/docs/cours/graphes/circuits-euleriens-code">le github du projet</a>. Essayez tout de même de résoudre les questions par vous-même, vous apprendrez plus que juste lire le corrigé.</p>

<h2 id="outils">Outils</h2>

<p>Vous aurez besoin de connaitre un peu de python et que vous sachiez faire des tests. Suivez les 4 premières parties du <a href="/cours_informatique/cours/developpement/">cours de développement</a></p>

<p>Les tests vont s’ajouter petit à petit et à la fin de la séance votre fichier <em>“test_multi_graph.py”</em> contiendra plus d’une vingtaine de tests !</p>

<h2 id="plan">Plan</h2>

<ol>
  <li>modéliser un multi-graphe dirigé en python</li>
  <li>algorithme du circuit eulérien</li>
  <li>suppression itératives de circuits à un multi-graphe eulérien</li>
  <li>création d’un multi-graphe à partir d’une suite de circuits</li>
  <li>le programme qui trouve un circuit eulérien d’un multi-graphe donné.</li>
</ol>

<h2 id="code-du-projet">code du projet</h2>

<p>Les fonctions que l’on vous demande de coder sont la plupart du temps simples, mais certaines nécessitent de réfléchir et — surtout — de se tromper un peu avant de voir la lumière. Comme cous avez le corrigé et les tests que l’on vous demande de faire passer, vous savez lorsque vous avez bon. On vous demande donc :</p>

<ul>
  <li>de ne pas regarder la solution avant que vous ayez fait passer les tests</li>
  <li>de vous creuser la tête pour faire marcher l’algorithme</li>
  <li>de bien nommer vos variables et de séparer par des retours à la lignes les différentes parties de l’algorithme</li>
</ul>

<h2 id="multi-graphe-dirigé">multi-graphe dirigé</h2>

<p>Un multi-graphe dirigé est un couple $G = (V, E)$ tel que soit une liste de couples $(x, y)$ (que l’on notera $xy$) appartenant à $V^2$. Cette structure de graphe permet :</p>

<ul>
  <li>d’avoir des arêtes dirigées ($xy$ étant différent de $yx$),</li>
  <li>d’avoir plusieurs fois la même arête (\(E\) est une liste et non un ensemble)</li>
</ul>

<h3 id="structure-python">structure python</h3>

<p>La structure python que nous utiliserons pour créer un graphe sera la liste d’adjacence. On va donc avoir besoin :</p>

<ul>
  <li>d’une liste <code class="language-plaintext highlighter-rouge">vertices</code> de noms de sommets. On identifiera le sommet avec son indice dans cette liste.</li>
  <li>une liste <code class="language-plaintext highlighter-rouge">edges</code> de listes de voisins.</li>
</ul>

<p>Par exemple, on pourra coder le graphe suivant :</p>

<p><img src="/cours_informatique/assets/cours/graphes/graphe_oriente_boucle.png" alt="un graphe orienté" style="margin: auto;display: block;"></p>

<p>Par la liste de sommets :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">,</span> <span class="s">'d'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">]</span>
</code></pre></div></div>

<p>Et les arcs codées sous forme de <a href="/cours_informatique/cours/graphes/encodage.html#liste-adjacence">liste d’adjacence</a> :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">edges</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">3</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
</code></pre></div></div>

<p><strong>Exemple :</strong> le sommet d’indice 4 (c’est à dire le sommet de nom <code class="language-plaintext highlighter-rouge">vertices[4]</code>; donc <code class="language-plaintext highlighter-rouge">'e'</code>) à 2 voisins qui correspondent à <code class="language-plaintext highlighter-rouge">edges[4]</code>, c’est à dire les sommets d’indice 3 (<code class="language-plaintext highlighter-rouge">'d'</code>) et d’indice 0 (<code class="language-plaintext highlighter-rouge">'a</code>’).</p>

<h4 id="codage-de-la-structure">codage de la structure</h4>

<p>Créez une méthode python <code class="language-plaintext highlighter-rouge">create_multi_graph(number_vertices, edges)</code> qui prend en paramètre une liste de couples et rend un multi-graphe. On supposera que les sommets sont déjà codés par des entiers allant de <code class="language-plaintext highlighter-rouge">0</code> à <code class="language-plaintext highlighter-rouge">number_vertices-1</code>.</p>

<p>On s’assurera de la validité de la structure choisie en faisant en sorte que les tests suivants passent.</p>

<p>Pour bien faire, créez votre structure de façon itérative en commençant par faire une structure qui fait passer le 1er test. Puis améliorez votre structure pour qu’elle fasse passer les 2 premiers tests, et ainsi de suite jusqu’à avoir une structure qui fasse passer tous les tests.</p>

<h4 id="code">code</h4>

<p>La structure de votre projet sera :</p>

<ul>
  <li>un fichier <em>“multi_graph.py”</em> contenant tout le code relatif à la structure de multi-graphe,</li>
  <li>le fichier <em>“main.py”</em> contiendra le programme principal avec l’exemple finalisé</li>
</ul>

<p>Tout ce qui concerne la structure de multi-graphe doit être stockée dans un fichier nommé <em>“multi_graph.py”</em>. Ce fichier sera importé dans le fichier <em>“main.py”</em> pour l’exécution du programme ou importé dans les fichiers de tests.</p>

<h4 id="points-critiques--tests-et-code">points critiques : tests et code</h4>

<ul>
  <li>les tests vous montrent l’implémentation demandée, sous la forme d’une liste de istes de sommets.</li>
  <li>on essaie (dans la mesure du possible) de coder en anglais. Vous aurez dans votre vie professionnels à travailler avec des personnes de nationalités différentes et l’anglais est la langue de communication.</li>
</ul>

<h4 id="tests">tests</h4>

<p>Les tests doivent être exécutés dans le fichier <em>test_multi_graph.py</em>, n’oubliez pas d’importer de <em>multi_graph.ph</em> les fonction que vous voulez tester, par exemple :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">multi_graph</span> <span class="kn">import</span> <span class="n">create_multi_graph</span>
</code></pre></div></div>

<blockquote>
  <p>On déconseille fortement d’importer <code class="language-plaintext highlighter-rouge">*</code> (<em>ie.</em> toutes les fonctions), importez les une à une. Ca ne prend pas de temps avec <em>pycharm</em> et ça permet de savoir précisément ce qui est testé.</p>
</blockquote>

<p>Les différents tests vont montrer comment organiser votre structure.</p>

<h5 id="multi-graphe-vide">multi-graphe vide</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_create_multi_graph_empty</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">[])</span> <span class="o">==</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">test_create_multi_graph_empty_three_vertices</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[])</span> <span class="o">==</span> <span class="p">[[],</span> <span class="p">[],</span> <span class="p">[]]</span>
</code></pre></div></div>

<h5 id="multi-graphe-une-arête">multi-graphe une arête</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_multi_graph_one_edge</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span> <span class="o">==</span> <span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[]]</span>
</code></pre></div></div>

<h5 id="multi-graphe-des-arêtes">multi-graphe des arêtes</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_multi_graph_several_edges</span><span class="p">():</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]</span>
    <span class="k">assert</span> <span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span> <span class="o">==</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
</code></pre></div></div>

<h4 id="usage">usage</h4>

<p>On a utilisé une structure sous la forme de listes pour stocker notre multi-graphe dirigé. En reprenant l’exemple du graphe :</p>

<p><img src="/cours_informatique/assets/cours/graphes/graphe_oriente_boucle.png" alt="un graphe orienté" style="margin: auto;display: block;"></p>

<p>codé en python :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="s">'a'</span><span class="p">,</span> <span class="s">'b'</span><span class="p">,</span> <span class="s">'c'</span><span class="p">,</span> <span class="s">'d'</span><span class="p">,</span> <span class="s">'e'</span><span class="p">]</span>
<span class="n">edges</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">3</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
         <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
</code></pre></div></div>

<p>On pourra facilement accéder à :</p>

<ul>
  <li>tous ses sommets : <code class="language-plaintext highlighter-rouge">list(range(len(edges)))</code> ou <code class="language-plaintext highlighter-rouge">list(range(len(vertices)))</code> rendra une liste des indices des différents sommets</li>
  <li>savoir si $xy$ est une arête (avec $x$ et $y$ des indices) : <code class="language-plaintext highlighter-rouge">y in edges[x]</code> rendra <code class="language-plaintext highlighter-rouge">True</code>si $xy$ est une arête et <code class="language-plaintext highlighter-rouge">False</code> sinon.</li>
  <li>aux voisins de <code class="language-plaintext highlighter-rouge">x</code> : <code class="language-plaintext highlighter-rouge">list(g[x])</code> (avec <code class="language-plaintext highlighter-rouge">x</code> un indice). On copie la liste plutôt que d’utiliser celle de <code class="language-plaintext highlighter-rouge">edges</code> pour éviter les soucis.</li>
</ul>

<blockquote class="attention">
  <p>de part la structure proposée :</p>

  <ul>
    <li>la complexité de <code class="language-plaintext highlighter-rouge">y in g[x]</code> est en $\mathcal{O}$(<code class="language-plaintext highlighter-rouge">len(g[x])</code>),</li>
    <li>lorsque vous manipulez <code class="language-plaintext highlighter-rouge">g[x]</code> faites attention à ne pas la modifier sinon vous modifiez la structure du multi-graphe.</li>
  </ul>
</blockquote>

<h2 id="multi-graphes-eulérien">multi-graphes eulérien</h2>

<p>Créez une fonction <code class="language-plaintext highlighter-rouge">is_eulerian(edges)</code> qui répond <code class="language-plaintext highlighter-rouge">True</code> si la liste d’adjacence en paramètre est eulérienne, et <code class="language-plaintext highlighter-rouge">False</code> sinon.</p>

<p>On rappelle qu’un multi-graphe est eulérien si chaque sommet à un nombre d’arêtes entrantes et d’arêtes sortantes égal.</p>

<p>Il faut que votre fonction passe les tests ci-après :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_is_eulerian_empty</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">is_eulerian</span><span class="p">([])</span>


<span class="k">def</span> <span class="nf">test_is_eulerian_one_edge</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">is_eulerian</span><span class="p">(</span><span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]))</span> <span class="ow">is</span> <span class="bp">False</span>


<span class="k">def</span> <span class="nf">test_is_eulerian_loop</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">is_eulerian</span><span class="p">(</span><span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span>


<span class="k">def</span> <span class="nf">test_is_eulerian_cycle</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">is_eulerian</span><span class="p">(</span><span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]))</span>


<span class="k">def</span> <span class="nf">test_is_eulerian_no_eulerian</span><span class="p">():</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
    <span class="k">assert</span> <span class="n">is_eulerian</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">False</span>
</code></pre></div></div>

<h3 id="points-critiques--eulérien">Points critiques : eulérien</h3>

<ul>
  <li>on doit savoir si le nombre d’arêtes entrante est égal au nombre d’arêtes sortantes mais seule le nombre d’arête sortante est facilement accessible. Il faut donc commender par trouver ces nombres pour tous les sommets</li>
  <li>on doit répondre vrai que si l’on a vérifié le nombre d’arêtes sortantes et entrantes pour tous les sommets
 on peut coder l’algorithme en \(\mathcal{O}(|V| + |E|)\) si \(G=(V, E)\) est le multi-graphe.</li>
</ul>

<h2 id="circuits-dans-un-multi-graphe-eulérien">circuits dans un multi-graphe eulérien</h2>

<p>On a vu en cours qu’un graphe dont le degré minimum est &gt; 2 contient un cycle. La même démonstration permet de montrer que pour un multi-graphe connexe, si chaque sommet a au moins 1 arête entrante et 1 arête sortante, il existe un circuit.</p>

<h3 id="circuit">circuit</h3>

<p>Avant de créer la vrai fonction, on va commencer par régler les cas particuliers. Créez un algorithme qui, a partir d’un multi-graphe eulérien (que l’on supposera connexe) :</p>

<ul>
  <li>rend un circuit non vide sous la forme d’une liste si le graphe a au moins 1 arête,</li>
  <li>rend la liste si le graphe est sans arêtes.</li>
</ul>

<p>Vous implémenterez cet algorithme dans la fonction <code class="language-plaintext highlighter-rouge">circuit_from_eulerian(edges)</code>. Elle doit satisfaire les tests suivants :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_circuit_empty</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">circuit_from_eulerian</span><span class="p">([])</span> <span class="o">==</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">test_circuit_no_edge</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">circuit_from_eulerian</span><span class="p">([[],</span> <span class="p">[]])</span> <span class="o">==</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">test_circuit_loop</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">circuit_from_eulerian</span><span class="p">(</span><span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="points-critiques--circuits">points critiques : circuits</h3>

<ul>
  <li>l’algorithme du cours est itératif mais sa boucle est une boucle <code class="language-plaintext highlighter-rouge">while</code> : on essaie d’étendre le chemin courant en cherchant un sommet qui n’est pas encore dans le chemin et qui forme une arête avec le dernier élément du chemin</li>
  <li>si l’on trouve une arête entre le dernier élément du chemin et un autre sommet du chemin on a trouvé un cycle. Mais ce cycle ne concerne pas forcément tous les éléments du chemin.</li>
  <li>si le multi-graphe ne contient pas de circuit faites en sorte que l’algorithme s’arrête tout de même en rendant <code class="language-plaintext highlighter-rouge">None</code> par exemple.</li>
</ul>

<h4 id="un-circuit">un circuit</h4>

<p>Pour ces tests on a un petit soucis. Un graphe eulérien va avoir plein de circuits possibles. Il faut donc dans les tests prévoir tous les cas car on ne sait pas a priori quel chemin va trouver l’algorithme.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_circuit</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">circuit_from_eulerian</span><span class="p">(</span><span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]))</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
</code></pre></div></div>

<h2 id="copie-de-graphe">copie de graphe</h2>

<p>Pour trouver un circuit eulérien d’un graphe, il faut itérativement supprimer un cycle de celui-ci. On va donc commencer par créer une fonction qui duplique un graphe et appelez-la <code class="language-plaintext highlighter-rouge">copy_multi_graph(edges)</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_copy_multi_graph</span><span class="p">():</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
    <span class="n">copy_edges</span> <span class="o">=</span> <span class="n">copy_multi_graph</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">copy_edges</span> <span class="o">==</span> <span class="n">edges</span>

    <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="s">"X"</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">copy_edges</span> <span class="o">!=</span> <span class="n">edges</span>
</code></pre></div></div>

<h3 id="points-critiques--copie">points critiques : copie</h3>

<ul>
  <li>la liste d’adjacence doit être copiée pas juste donnée au nouveau graphe. Les listes sont en effet des <a href="https://zestedesavoir.com/tutoriels/954/notions-de-python-avancees/1-starters/3-mutables-hashables/">objets</a> (modifiables)</li>
</ul>

<h2 id="suppression-de-circuit">suppression de circuit</h2>

<p>Créez une fonction qui, à partir d’un multi-graph et d’un cycle rend un <strong>autre</strong> multi-graph correspondant au multi-graph d’origine auquel on a supprimé le cycle.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_delete_cycle</span><span class="p">():</span>
    <span class="n">new_edges</span> <span class="o">=</span> <span class="n">delete_circuit</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]))</span>
    <span class="k">assert</span> <span class="n">new_edges</span> <span class="o">==</span> <span class="p">[[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]]</span>


<span class="k">def</span> <span class="nf">test_delete_cycle_different_graph</span><span class="p">():</span>
    <span class="n">initial_graph</span> <span class="o">=</span> <span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
    <span class="n">delete_circuit</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">initial_graph</span><span class="p">)</span>
    
    <span class="k">assert</span> <span class="n">initial_graph</span> <span class="o">==</span> <span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
</code></pre></div></div>

<h3 id="points-critiques--suppression-de-circuit">points critiques : suppression de circuit</h3>

<ul>
  <li>utilisez les fonctions créées précédemment comme <code class="language-plaintext highlighter-rouge">copy_multi_graph</code>
</li>
  <li>la structure de multi-graphe est stockée sous la forme de listes d’adjacence et le circuit est une succession d’arêtes</li>
</ul>

<h2 id="suite-de-circuits">suite de circuits</h2>

<p>Pour trouver un circuit eulérien, le cours vous indique qu’il faut itérativement supprimer un cycle à un graphe eulérien jusqu’à ce qu’on ne puisse plus le faire.</p>

<p>Créez une fonction qui, à partir d’un multi-graphe eulérien, rend une suite de circuits permettant de recréer son circuit eulérien.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_list_of_circuits_empty</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">list_of_circuits</span><span class="p">([])</span> <span class="o">==</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">test_list_of_circuits_one_circuit</span><span class="p">():</span>
    <span class="n">circuits</span> <span class="o">=</span> <span class="n">list_of_circuits</span><span class="p">(</span><span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">circuits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">circuits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>


<span class="k">def</span> <span class="nf">test_list_of_circuits_several_circuits</span><span class="p">():</span>
    <span class="n">circuits</span> <span class="o">=</span> <span class="n">list_of_circuits</span><span class="p">(</span><span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">circuits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="p">{</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">circuits</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">circuits</span><span class="p">[</span><span class="mi">1</span><span class="p">])}</span> <span class="o">==</span> <span class="p">{</span><span class="nb">frozenset</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}),</span> <span class="nb">frozenset</span><span class="p">({</span><span class="mi">0</span><span class="p">})}</span>
</code></pre></div></div>

<h3 id="points-critiques--suite-de-circuits">points critiques : suite de circuits</h3>

<ul>
  <li>on a créé pratiquement toutes les fonctions utiles à cet algorithme.</li>
  <li>une liste vide en python est considérée comme <code class="language-plaintext highlighter-rouge">False</code> pour ce qui est de tests booléens.</li>
  <li>le dernier test est un peu tricky, car il ne compare pas des listes de listes mais des ensembles d’ensembles. On est obligé de faire comme ça car on ne sais pas a priori dans quel ordre l’algorithme va trouver les cycles ni dans quel ordre il va les écrire (<code class="language-plaintext highlighter-rouge">[0, 1, 2]</code> et <code class="language-plaintext highlighter-rouge">[2, 0, 1]</code> correspondent au même circuit et sont tous les deux représentés par l’ensemble <code class="language-plaintext highlighter-rouge">{0, 1, 2}</code>)</li>
  <li>un <code class="language-plaintext highlighter-rouge">set</code> est mutable et ne peut contenir comme élément que des objets non mutable. On utilise ainsi dans les tests des <code class="language-plaintext highlighter-rouge">frozenset</code> qui sont des objets ensembles non mutable. Voir <a href="https://www.python-course.eu/sets_frozensets.php">là</a> par exemple pour une petite étude sur leurs différences.</li>
  <li>en python <code class="language-plaintext highlighter-rouge">{0, 1, 2, 3}</code> est un ensemble.</li>
</ul>

<h2 id="raboutage-de-2-circuits-en-un-circuit-plus-gros">raboutage de 2 circuits en un circuit plus gros</h2>

<p>Maintenant qu’on a une liste de circuits d’un multi-graphe eulérien, il faut les rabouter petit à petit pour obtenir un circuit eulérien. Commençons par rabouter 2 circuits en 1 seul.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_raboutage_left_empty</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">raboutage</span><span class="p">([],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_raboutage_right_empty</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">raboutage</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[])</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_raboutage</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">raboutage</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
</code></pre></div></div>

<h3 id="points-critiques">points critiques</h3>

<ul>
  <li>il faut trouver un élément commun aux deux circuits. On peut faire ça facilement en intersectant les ensembles créés à partir des listes de sommets des deux circuits.</li>
  <li>en manipulant les <a href="https://railsware.com/blog/python-for-machine-learning-indexing-and-slicing-for-lists-tuples-strings-and-other-sequential-types/">slycing</a> des listes, rabouter ceux cycles devient facile.</li>
</ul>

<h2 id="raboutage-de-circuits-en-un-circuit-eulérien">raboutage de circuits en un circuit eulérien</h2>

<p>Prenez un muti-graphe euliérien et rendez un de ses circuits eulériens</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_eulerian_circuit_empty</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">eulerian_circuit</span><span class="p">([])</span> <span class="o">==</span> <span class="p">[]</span>


<span class="k">def</span> <span class="nf">test_eulerian_circuit_one_loop</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">eulerian_circuit</span><span class="p">(</span><span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_eulerian_circuit</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">eulerian_circuit</span><span class="p">(</span><span class="n">create_multi_graph</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span> <span class="ow">in</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
</code></pre></div></div>

<h3 id="points-critiques--raboutage-de-circuits">points critiques : raboutage de circuits</h3>

<ul>
  <li>si vous êtes arrivé jusque là vous avez codé toutes les fonctions utile à cet algorithme.</li>
  <li>faite grossir un circuit initialement vide en le raboutant.</li>
</ul>

<h2 id="processus-complet-dans-le-main">processus complet dans le main</h2>

<p>Et <a href="https://www.youtube.com/watch?v=EVDlleOUQXY">voilà, c’est fini</a>, il ne vous reste plus qu’à faire votre programme principal qui, à partir d’un multi-graphe vérifie qu’il est eulérien et si c’est le cas, rend un circuit eulérien du graphe.</p>

<p>Pour cela, prenez un graphe du court permettant de trouver une <a href="https://fr.wikipedia.org/wiki/Suite_de_de_Bruijn">suite de Brujin</a> (c’est une variante des mots de brujin vus en cours) des mots de longueur 3 de l’alphabet ${0, 1}$</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique à l'école centrale marseille.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
