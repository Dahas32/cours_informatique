<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Théorie des graphes : arbres | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="Théorie des graphes : arbres">
<meta name="author" content="François Brucker">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<meta property="og:description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<link rel="canonical" href="/cours_informatique/cours/graphes/arbres.html">
<meta property="og:url" content="/cours_informatique/cours/graphes/arbres.html">
<meta property="og:site_name" content="cours d’informatique">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Théorie des graphes : arbres">
<script type="application/ld+json">
{"description":"Support de cours/td d’informatique à l’école centrale marseille.","@type":"WebPage","url":"/cours_informatique/cours/graphes/arbres.html","headline":"Théorie des graphes : arbres","author":{"@type":"Person","name":"François Brucker"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Théorie des graphes : arbres</h1>Auteur : <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">François Brucker</span></span>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/graphes/">graphes</a> / <a href="/cours_informatique/cours/graphes/arbres.html">arbres</a></p>
</blockquote>

<h2 id="but">But</h2>

<p>Explorer les propriétés et l’intérêt de l’arbre.</p>

<blockquote class="attention">
  <p>Tous les graphes de cette partie seront considérés comme étant <em>simples</em></p>
</blockquote>

<p><a href="/cours_informatique/cours/graphes/arbres-corrige.html">éléments de corrigé</a></p>

<h2 id="définitions">définitions</h2>

<p>Un <strong>arbre</strong> est un <em>graphe simple</em> $T = (V, E)$ qui est :</p>

<ul>
  <li>connexe</li>
  <li>sans cycle</li>
</ul>

<h3 id="graphe-simple">graphe simple</h3>

<blockquote class="a-faire">
  <p>Redonnez la définition d’un graphe simple. Combien d’arêtes au maximum peut contenir un graphe simple ?</p>
</blockquote>

<h3 id="arbre-ou-pas-arbre-">arbre ou pas arbre ?</h3>

<blockquote class="a-faire">
  <p>Déduire de la définition lequel des 2 graphes ci-dessous est un arbre.</p>
</blockquote>

<table>
  <tbody>
    <tr>
      <td><img src="/cours_informatique/assets/cours/graphes/pas_arbre.png" alt="graphe A"></td>
      <td><img src="/cours_informatique/assets/cours/graphes/arbre.png" alt="graphe B"></td>
    </tr>
    <tr>
      <td>A</td>
      <td>B</td>
    </tr>
  </tbody>
</table>

<h3 id="algorithme-de-reconnaissance">algorithme de reconnaissance</h3>

<h4 id="graphe-connexe">graphe connexe</h4>

<blockquote class="a-faire">
  <ol>
    <li>Donnez un algorithme permettant de savoir si un graphe $G = (V, E)$ donné est connexe.</li>
    <li>Quelle structure de graphe utiliseriez-vous pour que cet algorithme ait la plus petite complexité possible ?</li>
  </ol>
</blockquote>

<p><strong>Indice</strong> : On pourra partir d’un sommet $x$ et trouver itérativement tous les sommets que l’on peut atteindre avec lui.</p>

<h4 id="graphe-sans-cycle-">graphe sans cycle ?</h4>

<p>Là comme ça, ça n’a pas l’air simple de répondre à cette question. On va plutôt ruser et prouver deux propriétés des graphes connexes à la place.</p>

<blockquote class="a-faire">
  <ul>
    <li>Tout graphe sans cycle contient au maximum $\vert V \vert - 1$ arêtes.</li>
    <li>Tout graphe connexe contient au minimum $\vert V \vert - 1$ arêtes.</li>
  </ul>
</blockquote>

<h4 id="conditions">conditions</h4>

<p>En déduire que :</p>

<blockquote class="a-faire">
  <p>Un graphe $G=(V, E)$ est un arbre si et seulement si :</p>

  <ul>
    <li>il est connexe</li>
    <li>$\vert E \vert = \vert V \vert - 1$</li>
  </ul>
</blockquote>

<p>Sur votre lancée prouvez aussi que :</p>

<blockquote class="a-faire">
  <p>un graphe $G=(V, E)$ est un arbre si et seulement si :</p>

  <ul>
    <li>il est sans cycle</li>
    <li>$\vert E \vert = \vert V \vert - 1$</li>
  </ul>
</blockquote>

<p>Pour enfoncer le clou et montrer que les arbres sont une structure de connexité minimale vous pouvez aussi :</p>

<blockquote class="a-faire">
  <p>prouver que :</p>

  <ul>
    <li>Si on ajoute une arête à un arbre (n’importe laquelle) on ajoute un cycle</li>
    <li>Si on supprime une arête à un arbre (n’importe laquelle) on le déconnecte</li>
  </ul>
</blockquote>

<h4 id="conclusion">conclusion</h4>

<p>Les conditions précédentes nous permettent de ne pas avoir à chercher si un graphe a un cycle, ce qui rend l’algorithme de reconnaissance plus aisé :</p>

<blockquote class="a-faire">
  <p>Donnez l’algorithme final pour savoir si un graphe est un arbre.</p>
</blockquote>

<h2 id="arbre-enraciné">arbre enraciné</h2>

<p>En informatique on utilise souvent la structure d’arbre en l’<strong>enracinant</strong>, c’est-à-dire qu’on choisi un sommet qui sera la racine et tous les autres sommets vont être dépendants de lui. Ceci est possible de part une importante propriété des arbres : <strong>l’unicité des chemins</strong></p>

<h3 id="chemins-et-arbres">chemins et arbres</h3>

<p>Soit $T = (V, E)$ un arbre.</p>

<blockquote class="a-faire">
  <p>Montrez que quels que soient deux sommets $x$ et $y$, il n’existe qu’un seul chemin entre $x$ et $y$.</p>
</blockquote>

<h3 id="ordo-sommets">ordonnancement des sommets</h3>

<p>L’unicité des chemins permet d’ordonner les sommets par rapport à leur chemin par rapport à la racine. On a coutume de les faire <em>“tomber”</em> depuis la racine. On peut en effet les ranger par rapport à <strong>leur chemin</strong> par rapport à celle ci :</p>

<p><img src="/cours_informatique/assets/cours/graphes/arbre_plante.png" alt="arbre_plante" style="margin: auto;display: block;"></p>

<p>Vocabulaire :</p>

<ul>
  <li>$y$ est un <strong>ancêtre</strong> de $x$ : si $y$ est sur le chemin entre la racine et $x$</li>
  <li>$x$ est un <strong>descendant</strong> de $y$ : si $y$ est sur le chemin entre la racine et $x$</li>
  <li>$x$ est une <strong>feuille</strong> s’il n’a pas de descendant</li>
  <li>$x$ est un <strong>nœud intérieur</strong> s’il n’est pas une feuille</li>
  <li>$x$ est un <strong>enfant</strong> de $y$ : si $y$ est le sommet juste avant $x$ dans le chemin de la racine à $x$</li>
  <li>$y$ est un <strong>parent</strong> de $x$ : si $y$ est le sommet juste avant $x$ dans le chemin de la racine à $x$</li>
  <li>la <strong>hauteur</strong> de $x$ est la longueur du chemin entre la racine et $x$.</li>
  <li>la <strong>hauteur</strong> de l’arbre est la longueur du plus long chemin entre la racine et un autre sommet.</li>
</ul>

<blockquote class="a-faire">
  <p>Donnez un exemple de chacun des termes pour le graphe ci-avant.</p>
</blockquote>

<p>Cet ordonnancement est <a href="https://fr.wikipedia.org/wiki/Arbre_phylog%C3%A9n%C3%A9tique">très utilisé en biologie</a> par exemple car il permet de rendre compte de l’évolution des espèces. En analyse des données on utilise ce paradigme pour classer les données (qui sont les feuilles) selon ce qu’elles ont en commun (les leurs ancêtres).</p>

<h2 id="arbre-binaire">arbre binaire planté</h2>

<p>En informatique, c’est souvent les arbres binaires planté que l’on utilise :</p>

<p>Un arbre planté est binaire si tout noeud intérieur a <strong>au plus 2 enfants</strong>. On aura parfois aussi besoin qu’il soit <strong>complet</strong>, c’est-à-dire que les noeuds intérieurs qui n’ont pas 2 enfants sont en bas de l’arbre (à la hauteur de l’arbre -1).</p>

<h3 id="propriété-fondamentale-des-arbres-binaires">propriété fondamentale des arbres binaires</h3>

<blockquote class="a-faire">
  <p>Montrer que pour un arbre binaire, si tout noeud intérieur a exactement 2 enfants, alors en notant $f$ le nombre de feuilles de l’arbre, on a :</p>

  <ul>
    <li>la hauteur de l’arbre est égale à $\log_2(f)$</li>
    <li>$f$ est égal au nombre de nœuds intérieurs plus 1.</li>
  </ul>
</blockquote>

<p>Les propriétés ci-dessus montrent que si l’on veut organiser $n$ données, on n’a besoin que d’un arbre de hauteur $\log_2(n)$. Comme le chemin depuis la racine nous permet de retrouver les données, si on associe une question à chaque nœud intérieur, on peut retrouver $n$ éléments en ne posant que $\log_2(n)$ questions. C’est le principe des <strong>arbres de décisions</strong>, si utiles en apprentissage automatique.</p>

<blockquote>
  <p>La différence en $\log_2(n)$ et $n$ est très importante ! On par exemple besoin d’uniquement 100 questions pour trier 1267650600228229401496703205376 éléments.
Un informaticien est prêt à beaucoup, beaucoup de choses pour avoir une structure en $\log_2(n)$.</p>
</blockquote>

<h3 id="exemple-du-tas">exemple du tas</h3>

<p>Nous allons montrer ici une utilité de l’arbre binaire complet pour résoudre le problème d’une file de priorité.</p>

<h4 id="le-problème">le problème</h4>

<p>Une salle d’attente des urgences d’un hôpital contient des patients dont la gravité d’état est donnée par un entier. Des patients peuvent arriver et partir de la salle d’attente et leur état peut s’améliorer (la gravité d’état baisse) ou se détériorer (leur gravité d’état augmente). A chaque fois qu’un médecin est libre, on prend en charge le patient avec l’état de gravité le plus important.</p>

<h4 id="une-solution-possible-naïve">une solution possible (naïve)</h4>

<p>On regarde chaque patient et on prend le patient ayant la gravité d’état le plus important.</p>

<blockquote class="a-faire">
  <p>Quel est le coût algorithmique d’utiliser une telle solution ?</p>
</blockquote>

<p>Si l’on suppose que l’état de gravité d’un patient est connu, on peut faire bien mieux.</p>

<h4 id="un-tas">un tas</h4>

<p>Un tas est un arbre binaire planté complet dont les sommets sont des entiers. On considère en plus qu’un tas est <strong>plein</strong>, c’est-à-dire que les feuilles de hauteur maximum forment un intervalle à gauche de l’arbre.</p>

<p><img src="/cours_informatique/assets/cours/graphes/arbre_plante_tas_abc.png" alt="arbre_plante_tas_?" style="margin: auto;display: block;"></p>

<blockquote class="a-faire">
  <p>Des trois arbres ci-dessus lequel (il n’y en a qu’un) est binaire, complet et plein ?</p>
</blockquote>

<p>De plus, pour un tas, chaque nœud est de valeur plus grande que chacun de ses descendants direct.</p>

<blockquote class="a-faire">
  <ul>
    <li>Créez un tas avec les nombres : 42, 12, 1, 3, 6, 5.</li>
    <li>Y a-t-il plusieurs possibilités ?</li>
    <li>que peut-on dire du nœud ayant le plus grand nombre ?</li>
  </ul>
</blockquote>

<h4 id="manipulation-dun-tas">manipulation d’un tas</h4>

<blockquote class="a-faire">
  <p>Donner les algorithmes pour effectuer les opérations suivantes :</p>

  <ol>
    <li>ajout d’un élément</li>
    <li>modification d’une valeur</li>
    <li>suppression de la racine</li>
  </ol>
</blockquote>

<p>On peut s’en sortir avec des algorithmes dont le nombre d’opérations est proportionnel à la hauteur du tas.</p>

<blockquote class="a-faire">
  <p>En conclure que l’utilisation du tas est bien meilleure que la solution naïve.</p>
</blockquote>

<h4 id="pour-la-bonne-bouche">pour la bonne bouche</h4>

<blockquote class="a-faire">
  <ul>
    <li>En déduire une façon de trier un tableau de nombres.</li>
    <li>trouver un moyen de représenter un tas par une liste (on pourra parcourir le tas de haut en bas et de droite à gauche).</li>
  </ul>
</blockquote>

<h2 id="parcours">parcours</h2>

<p>Pour modifier la structure du tas on a dû évoluer dans la structure d’arbre planté. Un autre intérêt (encore un !) des arbres plantés est que tout sommet peut être considéré comme la racine de sous-arbre. On a donc uniquement besoin de créer l’algorithme qui fonctionnera pour la racine et le re-exécuter ensuite sur les descendants.</p>

<p>On utilise ce principe pour parcourir tous les sommets d’un arbre planté efficacement, c’est à dire en ne regardant chaque sommet qu’un nombre constant de fois.</p>

<h3 id="trois-parcours-classiques">trois parcours classiques</h3>

<blockquote class="a-faire">
  <p>Pour chaque parcours ci-après, donnez le résultat pour l’arbre de la partie <a href="#ordo-sommets">ordonnancement des sommets</a> en supposant que <code class="language-plaintext highlighter-rouge">Examen de la Racine</code> signifie : affiche le numéro de la racine à l’écran.</p>

  <p>Une fois ceci fait, trouvez un ordre qui lira les sommets dans l’ordre alphabétique à partir de b.</p>
</blockquote>

<h4 id="pré-ordre">pré-ordre</h4>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pré-ordre(racine)
Si la racine a des descendants:
    Examen de la racine 
    pré-ordre(enfant gauche) 
    pré-ordre(enfant droit)
</code></pre></div></div>

<h4 id="post-ordre">post-ordre</h4>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>post-ordre(racine)
Si la racine a des descendants:
    post-ordre(enfant gauche) 
    post-ordre(enfant droit)
    Examen de la racine 
</code></pre></div></div>

<h4 id="en-ordre">en-ordre</h4>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>en-ordre(racine)
Si la racine a des descendants:
    en-ordre(enfant gauche) 
    Examen de la racine 
    en-ordre(enfant droit)
</code></pre></div></div>

<blockquote>
  <p>Les <a href="https://fr.wikipedia.org/wiki/Arbre_syntaxique">parcours d’arbres</a> sont utilisés en linguistique pour analyser syntaxiquement une phrase. Un exercice classique est de créer un <a href="https://diu-uf-bordeaux.github.io/bloc4/td/arbres/expression/">arbre à partir d’une expression arithmétique</a> pour la résoudre de façon optimale en nombre d’opérations.</p>
</blockquote>

<h2 id="arbre-dans-des-graphes-connexes">arbre dans des graphes connexes</h2>

<blockquote class="a-faire">
  <p>Montrer que pour tout graphe connexe $G = (V, E)$, il existe au moins un arbre $T=(V, E’)$ tel que $E’ \subseteq E$.</p>
</blockquote>

<p>On appelle ces arbres les <strong>arbres couvrants</strong> d’un graphe.</p>

<p>Les arbres couvrant d’un graphe sont beaucoup utilisés en optimisation. Nous allons montrer un exemple ci-après.</p>

<h3 id="graphe-valué">graphe valué</h3>

<p>On peut associer à tout graphe $G = (V, E)$ une <strong>valuation</strong> $f: E \rightarrow \mathbb{R}$.</p>

<h4 id="une-mise-en-situation">une mise en situation</h4>

<p>On suppose que vous êtes chef d’un état. Vous voulez que votre territoire soit connexe (que les gens puissent aller partout sur votre territoire), mais vous ne voulez pas payer trop cher (vous voulez être ré-élu et ça fait mauvais genre d’augmenter les impôts).</p>

<p>Vous demandez donc à vos conseillez de créer un graphe dont les sommets correspondant à vos villes et dont les arêtes sont valuées par le coût de construction d’une route entre ces 2 villes. Ce graphe n’a pas forcément toutes les arêtes si le coût de construction est prohibitif par exemple.</p>

<p>La solution la plus efficace consiste à trouver de ce graphe un arbre couvrant dont la somme des valuations est minimale parmi tous les arbres couvrant.</p>

<blockquote class="a-faire">
  <p>Pourquoi ?</p>
</blockquote>

<h4 id="un-exemple">un exemple</h4>

<p>On considère le graphe ci-dessous :</p>

<p><img src="/cours_informatique/assets/cours/graphes/prim_graphe_exemple.png" alt="graphe exemple" style="margin: auto;display: block;"></p>

<p>Avec un peu d’imagination considérez que c’est le graphe de construction d’une petite île du pacifique dont vous êtes le nouveau chef d’état.</p>

<blockquote class="a-faire">
  <ul>
    <li>Quel est l’arête qui sera forcément dans tous les arbres couvrants de poids minimum ?</li>
    <li>Quel est l’arête qui ne sera forcément jamais dans un arbre couvrant de poids minimum ?</li>
    <li>y a-t-il plusieurs arbres couvrants de poids minimum pour ce graphe ?</li>
  </ul>
</blockquote>

<h4 id="propriété">propriété</h4>

<blockquote class="a-faire">
  <ul>
    <li>montrez que s’il existe deux arbres couvrants de poids minimum qui ne différent que d’une arête, alors elles ont même valuation</li>
    <li>montrez que si toutes les valuations sont différentes, il n’existe qu’un seul arbre couvrant de poids minimal.</li>
    <li>montrez que la réciproque n’est pas vraie</li>
  </ul>
</blockquote>

<h4 id="algo-prim">un algorithme</h4>

<p>Ce problème a l’air dur, mais il possède un algorithme (assez) simple pour le résoudre. L’algorithme suivant est l’algorithme de Prim (1957) :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entrée :
    * un graphe G = (V, E)
    * une valuation f qui associe un réel à toute arête de G
Initialisation :
    * cout_entree(x) = +∞ pour tout sommet x
    * predecesseur(x) = x pour tout sommet x
    * V' = {}, E' = {}
Algorithme :
    * on choisit un sommet r quelconque
    * cout_entree(r) = 0
    * ajoute r à V'    
    * tant que V' n'est pas V:
        * pour tous les voisins x de r qui ne sont pas dans V':
            * si cout_entree(x) &gt;= f(rx):
                cout_entree(x) = f(rx)
                predecesseur(x) = r
        * soit x le sommet de V qui n'est pas dans V' minimisant cout_entree(x)
        * r = x
        * cout_entree(r) = 0
        * ajoute r à V' et {r, predecesseur(r)} à E'
Retour :
    T = (V', E')
</code></pre></div></div>

<p>Commencer par :</p>

<blockquote class="a-faire">
  <p>Prouver que si G est connexe, alors T est connexe et est un arbre</p>
</blockquote>

<p>Une fois ceci fait :</p>

<blockquote class="a-faire">
  <p>Prouver que $T$ est <strong>un arbre couvrant de poids minimal</strong> pour $G$</p>
</blockquote>

<p>Maintenant qu’on est sur que ça marche :</p>

<blockquote class="a-faire">
  <p>Réalisez l’algorithme en entier sur le graphe précédent.</p>
</blockquote>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique à l'école centrale marseille.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
