<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>circuits eulérien | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="circuits eulérien" />
<meta name="author" content="François Brucker" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Support de cours/td d’informatique à l’école centrale marseille." />
<meta property="og:description" content="Support de cours/td d’informatique à l’école centrale marseille." />
<link rel="canonical" href="/cours_informatique/cours/graphes/circuits-euleriens-old.html" />
<meta property="og:url" content="/cours_informatique/cours/graphes/circuits-euleriens-old.html" />
<meta property="og:site_name" content="cours d’informatique" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="circuits eulérien" />
<script type="application/ld+json">
{"headline":"circuits eulérien","description":"Support de cours/td d’informatique à l’école centrale marseille.","@type":"WebPage","url":"/cours_informatique/cours/graphes/circuits-euleriens-old.html","author":{"@type":"Person","name":"François Brucker"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css"><link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique" /><!-- Mathjax Support -->
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
      },
      svg: {
        fontCache: 'global'
      }
    };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
</head>

<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/cours_informatique/">cours d&#39;informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">circuits eulérien</h1></p>Auteur : <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">François Brucker</span></span></p>
  </header>

  <div class="post-content">
    <h2 id="introduction">Introduction</h2>

<p>Le but de ce cours est d’apprendre à coder un (multi-)graphe dirigé et de s’en servir pour trouver un circuit eulérien d’un de ces graphes (s’il existe).</p>

<p>Le code complet de ce tuto est disponible sur <a href="https://github.com/FrancoisBrucker/cours_informatique/tree/master/docs/cours/tronc_commun/circuits-euleriens-code">le github du projet</a>. Essayez tout de même de résoudre les questions par vous-même, vous apprendrez plus que juste lire le corrigé.</p>

<h2 id="outils">Outils</h2>

<p>Vous aurez besoin d’un environnement de développement fonctionnel (suivez <a href="/cours_informatique/tutos/editeur/pycharm/2021/08/30/configuration-pycharm.html">ce tuto</a>, si ce n’est pas déjà fait).
Lorsque l’on vous demandera de <em>faire passer un test</em>, il faudra ajouter le test à votre fichier de test, comme indiqué dans le <a href="/cours_informatique/tutos/python/tests%20unitaires/2021/08/01/tests-unitaires.html">tuto sur les tests</a>.</p>

<p>Les tests vont s’ajouter petit à petit et à la fin de la séance votre fichier <em>test_multi_graph.py</em> contiendra plus d’une vingtaine de tests !</p>

<h2 id="plan">Plan</h2>

<ol>
  <li>modéliser un multi-graphe dirigé en python</li>
  <li>algorithme du circuit eulérien</li>
  <li>suppression itératives de circuits à un multi-graphe eulérien</li>
  <li>création d’un multi-graphe à partir d’une suite de circuits</li>
  <li>le programme qui trouve un circuit eulérien d’un multi-graphe donné.</li>
</ol>

<h2 id="code">code</h2>

<p>Les fonctions que l’on vous demande de coder sont la plupart du temps simples, mais certaines nécessitent de réfléchir et — surtout — de se tromper un peu avant de voir la lumière. Comme cous avez le corrigé et les tests que l’on vous demande de faire passer, vous savez lorsque vous avez bon. On vous demande donc :</p>

<ul>
  <li>de ne pas regarder la solution avant que vous ayez fait passer les tests</li>
  <li>de vous creuser la tête pour faire marcher l’algorithme</li>
  <li>de bien nommer vos variables et de séparer par des retours à la lignes les différentes parties de l’algorithme</li>
</ul>

<h2 id="multi-graphe-dirigé">multi-graphe dirigé</h2>

<p>Un multi-graphe dirigé est un couple $G = (V, E)$ tel que soit une liste de couples $(x, y)$ (que l’on notera \(xy\)) appartenant à \(V^2\). Cette structure de graphe permet :</p>

<ul>
  <li>d’avoir des arêtes dirigées ($xy$ étant différent de $yx$),</li>
  <li>d’avoir plusieurs fois la même arête (\(E\) est une liste et non un ensemble)</li>
</ul>

<h3 id="structure-python">structure python</h3>

<p>Créez une méthode python <code class="language-plaintext highlighter-rouge">create_multi_graph(edges)</code> qui prend en paramètre une liste de couples et rend un multi-graphe. On s’assurera de la validité de la structure choisie en faisant en sorte que les tests suivants passent.</p>

<p>Pour bien faire, créez votre structure de façon itérative en commençant par faire une structure qui fait passer le 1er test. Puis améliorez votre structure pour qu’elle fasse passer les 2 premiers tests, et ainsi de suite jusqu’à avoir une structure qui fasse passer tous les tests.</p>

<blockquote>
  <p><strong>Bota Bene :</strong> si le graphe ne prend qu’une suite d’arêtes en paramètre, on ne pourra pas créer de graphes avec des sommets isolés. Pour notre application, les circuits eulériens, ce n’est pas très grave, mais autant le noter.</p>
</blockquote>

<h4 id="code-1">code</h4>

<p>La structure de votre projet sera :</p>

<ul>
  <li>un fichier <em>multi_graph.py</em> contenant tout le code relatif à la structure de multi-graphe,</li>
  <li>le fichier <em>main.py</em> contiendra le programme principal avec l’exemple finalisé</li>
</ul>

<p>Tout ce qui concerne la structure de multi-graphe doit être stockée dans un fichier nommé <em>multi_graph.py</em>. Ce fichier sera importé dans le fichier <em>main.py</em> pour l’exécution du programme ou importé dans les fichiers de tests.</p>

<h4 id="points-critiques">Points critiques</h4>

<ul>
  <li>Les tests vous montrent l’implémentation demandée, sous la forme d’un dictionnaire les sommets étant les clés et les arêtes les valeurs codées sous la forme d’une <a href="https://fr.wikipedia.org/wiki/Liste_d%27adjacence">liste d’adjacence</a>.</li>
  <li>on essaie (dans la mesure du possible) de coder en anglais. Vous aurez dans votre vie professionnels à travailler avec des personnes de nationalités différentes et l’anglais est la langue de communication.</li>
</ul>

<h4 id="tests">tests</h4>

<p>Les tests doivent être exécutés dans le fichier <em>test_multi_graph.py</em>, n’oubliez pas d’importer de <em>multi_graph.ph</em> les fonction que vous voulez tester, par exemple :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">multi_graph</span> <span class="kn">import</span> <span class="n">create_multi_graph</span>
</code></pre></div></div>

<blockquote>
  <p><strong>Nota Bene :</strong> On déconseille fortement d’importer <code class="language-plaintext highlighter-rouge">*</code> (<em>ie.</em> toutes les fonctions), importez les une à une. Ca ne prend pas de temps avec <em>pycharm</em> et ça permet de savoir précisément ce qui est testé.</p>
</blockquote>

<p>Les différents tests vont montrer comment organiser votre structure.</p>

<h5 id="multi-graphe-vide">multi-graphe vide</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_create_multi_graph_empty</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">create_multi_graph</span><span class="p">([])</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">()</span>
</code></pre></div></div>

<h5 id="multi-graphe-une-arête">multi-graphe une arête</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_multi_graph_one_edge</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">create_multi_graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span> <span class="o">==</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[]}</span>
</code></pre></div></div>

<h5 id="multi-graphe-des-arêtes">multi-graphe des arêtes</h5>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_multi_graph_several_edges</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">create_multi_graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span> <span class="o">==</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> 
                                                                            <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> 
                                                                            <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> 
                                                                            <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">]}</span>
</code></pre></div></div>

<h4 id="usage">usage</h4>

<p>On a utilisé une structure sous la forme d’un <a href="https://docs.python.org/fr/3/tutorial/datastructures.html#dictionaries">dictionnaire</a> pour stocker notre multi-graphe dirigé.</p>

<p>Par exemple, le multi-graphe dirigé de la figure ci-dessous</p>

<p><img src="./multi-graphe.png" alt="un multi-graphe" /></p>

<p>s’écrira en python :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="s">"a"</span><span class="p">:</span> <span class="p">[</span><span class="s">"b"</span><span class="p">,</span> <span class="s">"e"</span><span class="p">],</span>
 <span class="s">"b"</span><span class="p">:</span> <span class="p">[</span><span class="s">"b"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">],</span>
 <span class="s">"c"</span><span class="p">:</span> <span class="p">[</span><span class="s">"d"</span><span class="p">],</span>
 <span class="s">"d"</span><span class="p">:</span> <span class="p">[</span><span class="s">"a"</span><span class="p">],</span>
 <span class="s">"e"</span><span class="p">:</span> <span class="p">[</span><span class="s">"d"</span><span class="p">,</span> <span class="s">"a"</span><span class="p">],</span>
<span class="p">}</span>
</code></pre></div></div>

<p>On pourra alors facilement accéder à la structure d’un multi-graphe <code class="language-plaintext highlighter-rouge">g</code>:</p>

<ul>
  <li>tous ses sommets : <code class="language-plaintext highlighter-rouge">set(g.keys())</code> sera l’ensemble de ses sommets</li>
  <li>savoir si \(xy\) est une arête de <code class="language-plaintext highlighter-rouge">g</code> : <code class="language-plaintext highlighter-rouge">"y" in g["x"]</code></li>
  <li>les voisins de <code class="language-plaintext highlighter-rouge">"x"</code> : <code class="language-plaintext highlighter-rouge">list(g["x"])</code></li>
</ul>

<blockquote>
  <p><strong>Attention :</strong> de part la structure proposée :</p>
  <ul>
    <li>la complexité de <code class="language-plaintext highlighter-rouge">"y" in g["x"]</code> est en \(\mathcal{O}\)(<code class="language-plaintext highlighter-rouge">len(g["x"])</code>),</li>
    <li>lorsque vous manipulez <code class="language-plaintext highlighter-rouge">g["x"]</code> faites attention à ne pas le modifier sinon vous modifiez la structure du multi-graphe.</li>
  </ul>
</blockquote>

<h2 id="multi-graphes-eulérien">multi-graphes eulérien</h2>

<p>Créez une fonction <code class="language-plaintext highlighter-rouge">is_eulerian(multi_graph)</code> qui répond <code class="language-plaintext highlighter-rouge">True</code> si le graphe en paramètre est eulérien, et <code class="language-plaintext highlighter-rouge">False</code> sinon.</p>

<p>On rappelle qu’un multi-graphe est eulérien si chaque sommet à un nombre d’arêtes entrantes et d’arêtes sortantes égal.</p>

<p>Il faut que votre fonction passe les tests ci-après</p>

<h3 id="points-critiques-1">Points critiques</h3>

<ul>
  <li>on doit savoir si le nombre d’arêtes entrante est égal au nombre d’arêttes sortantes mais seule le nombre d’arête sortante est facilement accessible. Il faut donc commender par trouver ces nombres pour tous les sommets</li>
  <li>on doit répondre vrai que si l’on a vérifié le nombre d’arêtes sortantes et entrantes pour tous les sommets</li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>on peut coder l’algorithme en $$\mathcal{O}(</td>
          <td>V</td>
          <td>+</td>
          <td>E</td>
          <td>)\(si\)G=(V, E)$$ est le multi-graphe.</td>
        </tr>
      </tbody>
    </table>
  </li>
</ul>

<h3 id="tests-1">tests</h3>

<h4 id="graphe-vide">graphe vide</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_is_eulerian_empty</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">is_eulerian</span><span class="p">(</span><span class="nb">dict</span><span class="p">())</span>
</code></pre></div></div>

<h3 id="graphe-1-arête">graphe 1 arête</h3>

<pre><code class="language-pyhton">def test_is_eulerian_one_edge():
    assert is_eulerian(create_multi_graph([[1, 2]])) is False
</code></pre>

<h3 id="graphe-boucle">graphe boucle</h3>

<pre><code class="language-pyhton">def test_is_eulerian_loop():
    assert is_eulerian(create_multi_graph([[1, 1]]))
</code></pre>

<h3 id="un-circuit">un circuit</h3>

<pre><code class="language-pyhton">def test_is_eulerian_cycle():
    assert is_eulerian(create_multi_graph([[1, 2], [3, 1], [2, 3]]))
</code></pre>

<h3 id="pas-eulérien-plus-gros">pas eulérien plus gros</h3>

<pre><code class="language-pyhton">def test_is_eulerian_no_eulerian():
    assert is_eulerian(create_multi_graph([[1, 2], [2, 3], [3, 1], [2, 4]])) is False
</code></pre>

<h2 id="circuits-dans-un-multi-graphe-eulérien">circuits dans un multi-graphe eulérien.</h2>

<p>On a vu en cours qu’un graphe dont le degré minimum est &gt; 2 contient un cycle. La même démonstration permet de montrer que pour un multi-graphe connexe, si chaque sommet a au moins 1 arête entrante et 1 arête sortante, il existe un circuit.</p>

<h3 id="circuit">circuit</h3>

<p>Créez un algorithme qui, a partir d’un multi-graphe eulérien (que l’on supposera connexe) :</p>

<ul>
  <li>rend un circuit non vide sous la forme d’une liste si le graphe a au moins 1 arête,</li>
  <li>rend la liste si le graphe est sans arêtes.</li>
</ul>

<p>Vous implémenterez cet algorithme dans la fonction <code class="language-plaintext highlighter-rouge">circuit_from_eulerian(multi_graph)</code></p>

<h3 id="points-critiques-2">points critiques</h3>

<ul>
  <li>l’algorithme du cours est itératif mais sa boucle est une boucle <code class="language-plaintext highlighter-rouge">while</code> : on essaie d’étendre le chemin courant en cherchant un sommet qui n’est pas encore dans le chemin et qui forme une arête avec le dernier élément du chemin</li>
  <li>si l’on trouve une arête entre le dernier élément du chemin et un autre sommet du chemin on a trouvé un cycle. Mais ce cycle ne concerne pas forcément tous les éléments du chemin.</li>
  <li>si le multi-graphe ne contient pas de circuit faites en sorte que l’algorithme s’arrête tout de même en rendant <code class="language-plaintext highlighter-rouge">None</code> par exemple.</li>
</ul>

<h3 id="test">test</h3>

<h4 id="vide">vide</h4>

<pre><code class="language-pyhton">def test_circuit_empty():
    assert circuit_from_eulerian(dict()) == []
</code></pre>

<h4 id="sans-arêtes">sans arêtes</h4>

<pre><code class="language-pyhton">def test_circuit_no_edge():
    assert circuit_from_eulerian({1: [], 2: []}) == []
</code></pre>

<h4 id="une-boucle">une boucle</h4>

<pre><code class="language-pyhton">def test_circuit_loop():
    assert circuit_from_eulerian(create_multi_graph([[1, 1]])) == [1]
</code></pre>

<h4 id="un-circuit-1">un circuit</h4>

<p>Pour ces tests on a un petit soucis. Un graphe eulérien va avoir plein de circuits possibles. Il faut donc dans les tests prévoir tous les cas car on ne sait pas a priori quel chemin va trouver l’algorithme.</p>

<pre><code class="language-pyhton">def test_circuit():
    assert circuit_from_euleriancreate_multi_graph([[1, 2], [3, 1], [2, 3]])) in [[1, 2, 3], [2, 3, 1], [3, 1, 2]]
</code></pre>

<h2 id="copie-de-graphe">copie de graphe</h2>

<p>Pour trouver un circuit eulérien d’un graphe, il faut itérativement supprimer un cycle de celui-ci. On va donc commencer par créer une fonction qui duplique un graphe et appelez-la <code class="language-plaintext highlighter-rouge">copy_multi_graph(multi_graph)</code>.</p>

<h3 id="points-critiques-3">points critiques</h3>

<ul>
  <li>la liste d’adjacence doit être copiée pas juste donnée au nouveau graphe. Les listes sont en effet des <a href="https://zestedesavoir.com/tutoriels/954/notions-de-python-avancees/1-starters/3-mutables-hashables/">objets</a> (modifiables)</li>
  <li>regardez du côté de la méthode <a href="https://docs.python.org/3/tutorial/datastructures.html#looping-techniques">.items()</a> des dictionnaires.</li>
</ul>

<h3 id="tests-2">tests</h3>

<p>Pour vérifier que tout fonctionne assurez vous que le test suivant passe.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_copy_multi_graph</span><span class="p">():</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">create_multi_graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
    <span class="n">copy_graph</span> <span class="o">=</span> <span class="n">copy_multi_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span> 
    <span class="k">assert</span> <span class="n">copy_graph</span> <span class="o">==</span> <span class="n">graph</span>
    
    <span class="n">graph</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">append</span><span class="p">(</span><span class="s">"X"</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">copy_graph</span> <span class="o">!=</span> <span class="n">graph</span>
</code></pre></div></div>

<h2 id="suppression-de-circuit">suppression de circuit</h2>

<p>Créez une fonction qui, à partir d’un multi-graph et d’un cycle rend un <strong>autre</strong>* multi-graph correspondant au multi-graph d’origine auquel on a supprimé le cycle.</p>

<h3 id="points-critiques-4">points critiques</h3>

<ul>
  <li>utilisez les fonctions créees précédemment comme <code class="language-plaintext highlighter-rouge">copy_multi_graph</code></li>
  <li>la structure de multi-graphe est stockée sous la forme de listes d’adjacence et le circuit est une succession d’arêtes</li>
  <li>la méthode <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists">.remove()</a> des listes peut être super utile.</li>
</ul>

<h3 id="tests-3">tests</h3>

<p>Vérifiez qu’elle fonctionne avec les tests suivants :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_delete_cycle</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">delete_circuit</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">create_multi_graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]))</span> <span class="o">==</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[]}</span> 
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_delete_cycle_different_graph</span><span class="p">():</span>
     
    <span class="n">initial_graph</span> <span class="o">=</span> <span class="n">create_multi_graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
    <span class="n">delete_circuit</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">create_multi_graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]))</span>
    
    <span class="k">assert</span> <span class="n">initial_graph</span> <span class="o">==</span> <span class="n">create_multi_graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
</code></pre></div></div>

<h2 id="suite-de-circuits">suite de circuits</h2>

<p>Pour trouver un circuit eulérien, le cours vous indique qu’il faut itérativement supprimer un cycle à un graphe eulérien jusqu’à ce qu’on ne puisse plus le faire.</p>

<p>Créez une fonction qui, à partir d’un multi-graphe eulérien, rend une suite de circuits permettant de recréer son circuit eulérien.</p>

<h3 id="points-critiques-5">points critiques</h3>

<ul>
  <li>on a créé pratiquement toutes les fonctions utiles à cet algorithme.</li>
  <li>une liste vide en python est considérée comme <code class="language-plaintext highlighter-rouge">False</code> pour ce qui est de tests booléens.</li>
  <li>le dernier test est un peu tricky, car il ne compare pas des listes de listes mais des ensembles d’ensembles. On est obligé de faire comme ça car on ne sais pas a priori dans quel ordre l’algorithme va trouver les cycles ni dans quel ordre il va les écrire (<code class="language-plaintext highlighter-rouge">[1, 2, 3]</code> et <code class="language-plaintext highlighter-rouge">[3, 1, 2]</code> correspondent au même circuit et sont tous les deux représentés par l’ensemble <code class="language-plaintext highlighter-rouge">{1, 2, 3}</code>)</li>
  <li>un <code class="language-plaintext highlighter-rouge">set</code> est mutable et ne peut contenir comme élément que des objets non mutable. On utilise ainsi dans les tests des <code class="language-plaintext highlighter-rouge">frozenset</code> qui sont des objets ensembles non mutable. Voir <a href="https://www.python-course.eu/sets_frozensets.php">là</a> par exemple pour une petite étude sur leurs différences.</li>
  <li>en python <code class="language-plaintext highlighter-rouge">{1, 2, 3, 4}</code> est un ensemble et <code class="language-plaintext highlighter-rouge">{1: 2, 3: 4}</code> un dictionnaire avec deux clés 1 et 3.</li>
</ul>

<h3 id="tests-4">tests</h3>

<p>Testez ces fonctions avec les deux tests suivants :</p>

<h4 id="liste-déjà-vide">liste déjà vide</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_list_of_circuits_empty</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">list_of_circuits</span><span class="p">(</span><span class="nb">dict</span><span class="p">())</span> <span class="o">==</span> <span class="p">[]</span>
</code></pre></div></div>

<h4 id="un-circuit-2">un circuit</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_list_of_circuits_one_circuit</span><span class="p">():</span>
    <span class="n">circuits</span> <span class="o">=</span> <span class="n">list_of_circuits</span><span class="p">(</span><span class="n">create_multi_graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]))</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">circuits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">circuits</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</code></pre></div></div>

<h4 id="plusieurs-circuits">plusieurs circuits</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_list_of_circuits_several_circuits</span><span class="p">():</span>
    <span class="n">circuits</span> <span class="o">=</span> <span class="n">list_of_circuits</span><span class="p">(</span><span class="n">create_multi_graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]))</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">circuits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="p">{</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">circuits</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">circuits</span><span class="p">[</span><span class="mi">1</span><span class="p">])}</span> <span class="o">==</span> <span class="p">{</span><span class="nb">frozenset</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}),</span> <span class="nb">frozenset</span><span class="p">({</span><span class="mi">1</span><span class="p">})}</span>
</code></pre></div></div>

<h2 id="raboutage-de-2-circuits-en-un-circuit-plus-gros">raboutage de 2 circuits en un circuit plus gros</h2>

<p>Maintenant qu’on a une liste de circuits d’un multi-graphe eulérien, il faut les rabouter petit à petit pour obtenir un circuit eulérien. Commençons par rabouter 2 circuits en 1 seul.</p>

<h3 id="points-critiques-6">points critiques</h3>

<ul>
  <li>il faut trouver un élément commun aux deux circuits. On peut faire ça facilement en intersectant les ensembles créés à partir des listes de sommets des deux circuits.</li>
  <li>en manipulant les <a href="https://railsware.com/blog/python-for-machine-learning-indexing-and-slicing-for-lists-tuples-strings-and-other-sequential-types/">slycing</a> des listes, rabouter ceux cycles devient facile.</li>
</ul>

<h3 id="tests-5">tests</h3>

<h4 id="un-circuit-vide">un circuit vide</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_raboutage_left_empty</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">raboutage</span><span class="p">([],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">test_raboutage_right_empty</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">raboutage</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[])</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="deux-circuits">deux circuits</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_raboutage</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">raboutage</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="ow">in</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
</code></pre></div></div>

<h2 id="raboutage-de-circuits-en-un-circuit-eulérien">raboutage de circuits en un circuit eulérien</h2>

<p>Prenez un muti-graphe euliérien et rendez un de ses circuits eulériens</p>

<h3 id="points-critiques-7">points critiques</h3>

<ul>
  <li>si vous êtes arrivé jusque là vous avez codé toutes les fonctions utile à cet algorithme.</li>
  <li>faite grossir un circuit initialement vide en le raboutant le raboutage itératif des circuits peut se faire en parcourant les éléments de la liste des circuits et</li>
</ul>

<h3 id="tests-6">tests</h3>

<h4 id="graphe-vide-1">graphe vide</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_eulerian_circuit_empty</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">eulerian_circuit</span><span class="p">(</span><span class="nb">dict</span><span class="p">())</span> <span class="o">==</span> <span class="p">[]</span>
</code></pre></div></div>

<h4 id="une-boucle-1">une boucle</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_eulerian_circuit_one_loop</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">eulerian_circuit</span><span class="p">(</span><span class="n">create_multi_graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]))</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="2-circuits">2 circuits</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_eulerian_circuit</span><span class="p">():</span>
    <span class="k">assert</span> <span class="n">eulerian_circuit</span><span class="p">(</span><span class="n">create_multi_graph</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]))</span> <span class="ow">in</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</code></pre></div></div>

<h2 id="processus-complet-dans-le-main">processus complet dans le main</h2>

<p>Et <a href="https://www.youtube.com/watch?v=EVDlleOUQXY">voilà, c’est fini</a>, il ne vous reste plus qu’à faire votre programme principal qui, à partir d’un multi-graphe vérifie qu’il est eulérien et si c’est le cas, rend un circuit eulérien du graphe.</p>

<p>Pour cela, prenez un graphe du court permettant de trouver une <a href="https://fr.wikipedia.org/wiki/Suite_de_de_Bruijn">suite de Brujin</a> (c’est une variante des mots de brujin vus en cours) des mots de longueur 3 de l’alphabet \({0, 1}\)</p>


  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d&#39;informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d&#39;informatique</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d&#39;informatique à l&#39;école centrale marseille.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
