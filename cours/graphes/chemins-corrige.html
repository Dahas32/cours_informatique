<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Théorie des graphes : chemins | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="Théorie des graphes : chemins">
<meta name="author" content="François Brucker">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique de François Brucker.">
<meta property="og:description" content="Support de cours/td d’informatique de François Brucker.">
<link rel="canonical" href="/cours_informatique/cours/graphes/chemins-corrige.html">
<meta property="og:url" content="/cours_informatique/cours/graphes/chemins-corrige.html">
<meta property="og:site_name" content="cours d’informatique">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Théorie des graphes : chemins">
<script type="application/ld+json">
{"description":"Support de cours/td d’informatique de François Brucker.","@type":"WebPage","author":{"@type":"Person","name":"François Brucker"},"url":"/cours_informatique/cours/graphes/chemins-corrige.html","headline":"Théorie des graphes : chemins","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Théorie des graphes : chemins</h1>Auteur : <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">François Brucker</span></span>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/graphes/">graphes</a> / <a href="/cours_informatique/cours/graphes/chemins.html">chemins</a></p>
</blockquote>

<h2 id="but">But</h2>

<p>Chemins entre deux sommets.</p>

<p><a href="/cours_informatique/cours/graphes/chemins.html">les exercices</a></p>

<h2 id="dijkstra">Dijkstra</h2>

<p>La seule différence entre l’algorithme de Prim et et l’algorithme de Dijkstra est l’évaluation du coût d’entrée :</p>

<ul>
  <li>dans l’algorithme de Prim il est égal à la valuation de l’arête rx</li>
  <li>dans l’algorithme de Diskstra il vaut l’addition de cout_entree(r) plus la valuation de l’arête rx.</li>
</ul>

<p>Cette différence s’explique parce que le poids d’un arbre est la somme des valuations des arêtes qui le constitue alors que pour un chemin, avant d’aller en x, il faut déjà aller en r (dont le coût est cout_entree(x) ) puis de r à x (dont le coût est f(rx)).</p>

<h3 id="test">test</h3>

<p>Les différentes étapes de l’algorithme sont représentées dans les graphes ci-dessous.</p>

<ul>
  <li>La figure se lit de gauche à droite et de haut en bas.</li>
  <li>$V’$ est en vert</li>
  <li>en magenta $r$ et les modification des prédécesseur et du cout d’entrée s’il y en a</li>
  <li>en orange le prédécesseur et le cout d’entrée.</li>
</ul>

<p><img src="/cours_informatique/assets/cours/graphes/chemin_dijkstra_paris_rana.png" alt="Dijkstra Paris à Rana" style="margin: auto;display: block;"></p>

<h3 id="preuve">preuve</h3>

<p>On montre par récurrence que le chemin de x à r en remontant les prédécesseurs de r jusqu’à arriver à d est de longueur minimale et de coût cout_entree(r).</p>

<p>Au départ <code class="language-plaintext highlighter-rouge">r = d</code>, la propriété est donc vraie. On la suppose vrai jusqu’à l’étape $i$. A l’étape $i+1$, on a choisi <code class="language-plaintext highlighter-rouge">r</code> qui minimise le coût d’entrée parmi tous les éléments de <code class="language-plaintext highlighter-rouge">V</code> qui ne sont pas encore dans <code class="language-plaintext highlighter-rouge">V'</code>. Comme tous les chemins alternatifs entre <code class="language-plaintext highlighter-rouge">d</code> et <code class="language-plaintext highlighter-rouge">r</code> commencent en <code class="language-plaintext highlighter-rouge">d</code>, il existe une arête de ce chemin dont le départ  (disons $u$) est dans <code class="language-plaintext highlighter-rouge">V'</code> et l’arrivée (disons $v$) n’y est pas. Prenons la première arête $uv$ pour laquelle ça arrive.</p>

<p>Par hypothèse de récurrence, <code class="language-plaintext highlighter-rouge">cout_entree(u)</code> est le cout minimum d’un chemin entre <code class="language-plaintext highlighter-rouge">d</code> et $u$ et <code class="language-plaintext highlighter-rouge">cout_entree(v)</code> est donc plus grand que <code class="language-plaintext highlighter-rouge">cout_entree(u) + f(uv)</code> (on a examiné ce cas lorsque l’on a fait rentrer $u$ dans <code class="language-plaintext highlighter-rouge">V'</code>) et de <code class="language-plaintext highlighter-rouge">cout_entree(r)</code> (car c’est le min).</p>

<p>De là, le coût du chemin alternatif est plus grand également que <code class="language-plaintext highlighter-rouge">cout_entree(r)</code> <strong>car toutes les valuations sont positives</strong> : notre hypothèse est vérifiée.</p>

<h3 id="complexité">complexité</h3>

<p>On ajoute à chaque étape un élément, donc il y a au pire $\vert V \vert$ étapes. A chaque choix on compare les voisins de <code class="language-plaintext highlighter-rouge">r</code>. Ces comparaisons sont donc de l’ordre de $\mathcal{O}(\delta(r))$ opérations. Comme <code class="language-plaintext highlighter-rouge">r</code> est différent à chaque étapes, toutes ces comparaisons sont de l’ordre de $\mathcal{O}(\sum\delta(r)) = \mathcal{O}(\vert E \vert)$ opérations.</p>

<p>On prend ensuite le minimum parmi les éléments de <code class="language-plaintext highlighter-rouge">V'</code>, ce qui prend $\mathcal{O}(\vert V \vert)$ opérations.</p>

<p>La complexité totale est alors en $\mathcal{O}(\vert E\vert + (\vert V \vert)^2)$.</p>

<p>On voit qu’elle dépend entièrement de la prise du minimum de <code class="language-plaintext highlighter-rouge">cout_entree</code>. En optimisant cette opération, on peut drastiquement diminuer la complexité de l’algorithme</p>

<p>Si l’on utilise un tas pour prendre le min, on doit au pire mettre à jour le tas pour chaque arête. Comme il va y a voir au maximum <code class="language-plaintext highlighter-rouge">V</code> éléments dans ce tas, la complexité de mise à jour est de $\mathcal{O}(\log_2(\vert V \vert))$, donc le coût total des mises à jour sera de $\mathcal{O}(\vert E \vert \log_2(\vert V \vert))$.</p>

<p>Enfin, comme on prend $\vert V \vert$ fois le minimum du tas, la complexité de trouver tous les <code class="language-plaintext highlighter-rouge">r</code> est de $\mathcal{O}(\vert V \vert \log_2(\vert V \vert))$. La complexité de chercher le minimum $\vert V \vert$ fois plus la mise à jour du tas est donc de : $\mathcal{O}((\vert E \vert + \vert V \vert)\log_2(\vert V \vert))$.</p>

<p>La complexité de Dijkstra avec un tas est alors : $\mathcal{O}(\vert E \vert + (\vert E \vert + \vert V \vert)\log_2(\vert V \vert))$ ce qui est égal à $\mathcal{O}((\vert E \vert + \vert V \vert)\log_2(\vert V \vert))$.</p>

<p>Ceci est mieux de prendre le minimum si le graphe ne contient pas énormément d’arêtes : $(\vert E \vert + \vert V \vert) \log_2(\vert V \vert) \leq \vert E\vert + (\vert V \vert)^2$, ce qui donne asymptotiquement $\vert E \vert \leq \frac{\vert V \vert^2}{\log_2(\vert V \vert)}$.</p>

<p>La <a href="https://fr.wikipedia.org/wiki/Algorithme_de_Dijkstra#Complexit%C3%A9_de_l'algorithme">page wikipédia</a> précise qu’en utilisant un tas amélioré, dit tas de fibonnaci, on arrive même à faire descendre la complexité à $\mathcal{O}(\vert E \vert + \vert V \vert\log_2(\vert V \vert))$, ce qui est du coup tout le temps mieux que la prise de minimum naïve.</p>

<h2 id="arborescence">arborescence</h2>

<p>A chaque fois que l’on ajoute un élément dans <code class="language-plaintext highlighter-rouge">V'</code> on vérifie tous ses voisins pour mettre à jour le coût d’entrée dans la structure. On procède comme le parcours en largeur et on a montré qu’il trouvait la composante connexe de sa racine.</p>

<h3 id="preuve-dijkstra-arborescence">preuve</h3>

<p>Cette preuve dérive directement de la preuve de l’algorithme de Dijkstra que l’on a fait précédemment.</p>

<h3 id="prim-vs-dijkstra">Prim vs Dijkstra</h3>

<p>Le graphe suivant montre que l’arborescence de Disjkstra sera différente de l’arbre de poids minimum donné par Prim.</p>

<p><img src="/cours_informatique/assets/cours/graphes/chemin_prim_vs_dijkstra.png" alt="Prim vs Dijkstra" style="margin: auto;display: block;"></p>

<blockquote class="attention">
  <p>Ne confondez pas les 2 problèmes !</p>
</blockquote>

<h2 id="chemin-le-plus-long">chemin le plus long</h2>

<h3 id="algorithme-">algorithme ?</h3>

<p>Même si l’on met à jour en cherchant à prendre le plus grand coût d’entrée à chaque fois, l’algorithme ne fonctionne pas. Prenez par exemple le graphe suivant :</p>

<p><img src="/cours_informatique/assets/cours/graphes/chemin_pas_hamilton.png" alt="Dijkstra pas hamilton" style="margin: auto;display: block;"></p>

<p>Le chemin de longueur maximum $132$ ne sera jamais trouvé si les sommets sont rentré dans l’ordre 1, 2, 3.</p>

<h3 id="chemin-hamiltonien">chemin hamiltonien</h3>

<p>Le plus long chemin élémentaire possible dans un graphe passe par tous les sommets. Donc un chemin élémentaire de longueur $\vert V \vert -1$ est hamiltonien.</p>

<h3 id="graphes-particuliers">graphes particuliers</h3>

<h4 id="graphe-sans-circuit">graphe sans circuit</h4>

<p>1 :</p>

<p>Soit $c_0\dots c_k$ un cycle ($c_k = c_0$), quelque soit l’ordre total entre les sommets du graphe, il existe $i$ tel que $c_{i+1} &lt; c_i$ ce qui est impossible si un tel ordre était topologique.</p>

<p>2 :</p>

<p>Supposons que tout sommet d’un DAG admette un voisin entrant et un voisin sortant, et prenons une arête $x_0x_1$ de ce graphe. Il existe donc une arête $x_1x_2$. Si $x_2 = x_0$ il existe un cycle dans le graphe, sinon il existe un chemin $x_0x_1x_2$. Il existe donc une arête $x_2x_3$. Si $x_3 \in {x_0, x_1 }$ il existe un cycle et sinon on a un chemin $x_0x_1x_2x_3$. On peut ainsi recommencer jusqu’à tomber sur un cycle par finitude du graphe. Ce n’est pas un DAG.</p>

<p>Le raisonnement est identique pour les voisins entrant.</p>

<p>3 :</p>

<p>en supprimant itérativement les sommets sans voisins rentrant d’un DAG (le graphe obtenu en supprimant un sommet d’un DAG est toujours un DAG puisque supprimer un sommet ne rajoute pas de cycle), on obtient un tri topologique.</p>

<blockquote>
  <p>On peut aussi le faire de façon optimale en utilisant un <a href="https://fr.wikipedia.org/wiki/Algorithme_de_parcours_en_profondeur">parcours en profondeur</a></p>
</blockquote>

<p>4 :</p>

<p>On a montré que :</p>

<ul>
  <li>cycle implique non tri topologique</li>
  <li>DAG (non cycle) implique tri topologique</li>
</ul>

<p>On a donc bien l’équivalence : tri topologique est équivalent à DAG.</p>

<p>algorithme sur tri topologique :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entrée :
    * un graphe orienté G = (V, E)
    * un tri V0 &lt; ... &lt; Vn des éléments de V
Initialisation :
    * longueur(x) = 0 pour tout sommet x
    * predecesseur(x) = x pour tout sommet x
    * V' = {}, E' = {}
Algorithme :
    * pour v allant de V0 à Vn:
        * pour chaque voisin sortant w de v:
            * si longueur(w) &lt; longueur(v) + 1:
                * longueur(w) = longueur(v) + 1
                * predecesseur(w) = v
    * soit a l'élément de V ayant la plus grande longueur
    * chemin = [a]
    * x = a
    * tant que x est différent de predecesseur(x):
        * x = predecesseur(x)
        * ajoute x au début de chemin        
Retour :
    chemin
</code></pre></div></div>

<p>La complexité est de $\mathcal{O}(\vert E \vert + \vert V \vert)$, ce qui est optimal.</p>

<p>Pour prouver l’algorithme, on montre par récurrence sur $\vert V \vert$ que <code class="language-plaintext highlighter-rouge">longueur(x)</code> est la longueur d’un plus long chemin finissant en <code class="language-plaintext highlighter-rouge">x</code>.</p>

<p>Si $\vert V \vert = 1$, c’est Ok. On suppose la propriété vraie à $\vert V \vert = n$. Pour $\vert V \vert = n +1$ on remarque que <code class="language-plaintext highlighter-rouge">longueur(Vi)</code> est la même pour le graphe $G$ et pour le graphe $G$ auquel on a enlevé $v_{n+1}$ pour tout $i \neq n+1$. Comme tous les prédécesseurs de $v_{n+1}$ seront vus pour l’algorithme et que <code class="language-plaintext highlighter-rouge">longueur(Vi)</code> ne change pas après l’étape $i$ on en conclut que la récurrence est vraie à $\vert V \vert = n +1$.</p>

<h4 id="tournoi">tournoi</h4>

<h5 id="cycles">cycles</h5>

<p>Si le tournoi n’est pas transitif il existe $x$, $y$ et $z$  tels que $xy$ et $yz$ mais pas $xz$ : $xyzx$ est un cycle.</p>

<p>Réciproquement, s’il existe un cycle, prenons en un de longueur minimum : $c_0c_1c_2 \dots c_k$. Comme le cycle est de longueur minimum, $c_0c_2$ n’est pas une arête : le tournoi n’est pas transitif.</p>

<h5 id="chemin-hamiltonien-1">chemin hamiltonien</h5>

<p>Par récurrence, un tournoi à 1 sommet admet un chemin hamiltonien. Si on suppose cela vrai pour tout tournoi à moins de $n$ sommets, soit $T = (V, E)$ un tournoi à $n+1$ sommets.</p>

<p>On prend $x$ un sommet de ce tournoi. On a alors que $N^+(x) \cup N^-(x) \cup { x } = V$ et que la restriction de $T$ à $N^+(x)$ ou à $N^-(x)$ restent des tournois et ont strictement moins de $n+1$ sommets.</p>

<p>Il existe alors :</p>

<ul>
  <li>un chemin hamiltonien $c_0\dots c_k$ dans la restriction de $T$ à $N^+(x)$</li>
  <li>un chemin hamiltonien $c’_0\dots c’_l$ dans la restriction de $T$ à $N^-(x)$</li>
</ul>

<p>On en conclut que le chemin $c’_0 \dots c’_l x c_0 \dots c_k$ est hamiltonien dans $T$, ce qui termine la preuve par récurrence.</p>

<h3 id="ordonnancement">ordonnancement</h3>

<p>Il est clair que s’il y a un cycle on ne peut réaliser le projet. De plus un tri topologique fait que lorsque l’on s’attelle à la tache $v_i$ on a déjà fait tous ses prédécesseurs (ses prés-requis).</p>

<h2 id="variantes">variantes</h2>

<h3 id="poids-négatifs">poids négatifs</h3>

<p><img src="/cours_informatique/assets/cours/graphes/chemin_poids_negatif.png" alt="chemin poids négatif" style="margin: auto;display: block;"></p>

<p>Il suffit de pouvoir aller de $d$ au circuit absorbant puis du circuit à $a$ pour que la longueur minimale d’un chemin allant de $d$ à $a$ soit $-\infty$ (on repasse beaucoup de fois par le circuit absorbant qui va diminuer à chaque fois la longueur du chemin).</p>

<p><img src="/cours_informatique/assets/cours/graphes/chemin_absorbant.png" alt="circuit absorbant" style="margin: auto;display: block;"></p>

<h3 id="graphe-inconnu-ou-changeant">graphe inconnu ou changeant</h3>

<h4 id="exemple-sur-la-grille">exemple sur la grille</h4>

<ul>
  <li>On peut prendre comme graphe la grille 2D carré de pas 1m par exemple</li>
  <li>s’il y a des murs on ne mets pas d’arêtes</li>
  <li>l’euristique sera la distance L1 entre la position et l’arrivée.</li>
</ul>

<p>On peut même se déplacer à chaque itération et se rapprocher normalement du but petit à petit.</p>

<h4 id="attention-à-lheuristique-utilisée">attention à l’heuristique utilisée</h4>

<p>Pour montrer qu’il peut se tromper, on donne une estimation de coût 0 à un chemin qui n’est pas de longueur minimale et $+\infty$ à sous les autres.</p>

<h3 id="grand-graphes">grand graphes</h3>

<ul>
  <li>Marseille a Dijon et Paris dans ses hub. Le premier pour aller de Marseille à Strabourg et le second pour aller de Marseille à Brest</li>
  <li>Strasbourg à également Dijon et Paris dans ses hubs le premier pour aller à Marseille (c’est symétrique) et le second pour aller à Brest.</li>
</ul>

<p><img src="/cours_informatique/assets/cours/graphes/chemin_hubs.png" alt="chemin hubs" style="margin: auto;display: block;"></p>

<p>Google maps peut alors vous proposer deux grands chemins pour aller de Marseille à Strasbourg, soit en passant par Dijon soit par Paris (bon il ne le fait pas car un chemin est bien plus long que l’autre, mais c’est l’idée).</p>

<p>Les hubs, en plus d’être efficaces en temps de calculs sont aussi une chouette solution pour proposer des itinéraires différents pour aller entre 2 villes.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique de François Brucker.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
