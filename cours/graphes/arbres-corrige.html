<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Théorie des graphes : arbres | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Théorie des graphes : arbres" />
<meta name="author" content="François Brucker" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Support de cours/td d’informatique à l’école centrale marseille." />
<meta property="og:description" content="Support de cours/td d’informatique à l’école centrale marseille." />
<link rel="canonical" href="/cours_informatique/cours/graphes/arbres-corrige.html" />
<meta property="og:url" content="/cours_informatique/cours/graphes/arbres-corrige.html" />
<meta property="og:site_name" content="cours d’informatique" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Théorie des graphes : arbres" />
<script type="application/ld+json">
{"headline":"Théorie des graphes : arbres","description":"Support de cours/td d’informatique à l’école centrale marseille.","@type":"WebPage","url":"/cours_informatique/cours/graphes/arbres-corrige.html","author":{"@type":"Person","name":"François Brucker"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css"><link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique" /><!-- Mathjax Support -->
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
      },
      svg: {
        fontCache: 'global'
      }
    };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
</head>

<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/cours_informatique/">cours d&#39;informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Théorie des graphes : arbres</h1></p>Auteur : <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">François Brucker</span></span></p>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/graphes/">graphes</a> / <a href="/cours_informatique/cours/graphes/arbres-corrige.html">arbres corrigé</a></p>
</blockquote>

<p>Ce ne sera pas un corrigé exhaustif. On donnera les principale piste pour résoudre les exercices.</p>

<h2 id="définitions-et-premières-propriétés">définitions et premières propriétés</h2>

<h3 id="graphe-simple">graphe simple</h3>

<blockquote class="a-faire">
  <p>Redonnez la définition d’un graphe simple. Combien d’arêtes au maximum peut contenir un graphe simple ?</p>
</blockquote>

<p><a href="/cours_informatique/cours/graphes/#restrictions">Dans le cours</a> : un graphe simple est un graphe sans boucle et non orienté</p>

<h3 id="arbre-ou-pas-arbre-">arbre ou pas arbre ?</h3>

<blockquote class="a-faire">
  <p>Déduire de la définition lequel des 2 graphes ci-dessous est un arbre.</p>
</blockquote>

<p>C’est bien sur le graphe B qui est connexe et ne contient pas de cycle. Le graphe A est connexe mais il contient des cycles.</p>

<h3 id="algorithme-de-reconnaissance">algorithme de reconnaissance</h3>

<h4 id="graphe-connexe">graphe connexe</h4>

<blockquote class="a-faire">
  <ol>
    <li>Donnez un algorithme permettant de savoir si un graphe $G = (V, E)$ donné est connexe.</li>
    <li>Quelle structure de graphe utiliseriez vous pour que cet algorithme ait la plus petite complexité possible ?</li>
  </ol>
</blockquote>

<p>On utilise le <a href="https://fr.wikipedia.org/wiki/Algorithme_de_parcours_en_largeur">parcours en largeur des graphes</a>. COmme il faut examiner stous les voisins d’un sommet, on a coutume d’utiliser les liste d’adjacence pour le nombre d’opération de l’algorithme soit proportionnel aux nombres d’arêtes du graphes ($\mathcal{O}(\vert E \vert)$) : il est donc optimal.</p>

<h4 id="graphe-sans-cycle-">graphe sans cycle ?</h4>

<blockquote class="a-faire">
  <ul>
    <li>Tout graphe sans cycle contient au maximum $\vert V \vert - 1$ arêtes.</li>
    <li>Tout graphe connexe contient au minimum $\vert V \vert - 1$ arêtes.</li>
  </ul>
</blockquote>

<p>Pour la 1ère preuve, on utilise la contre-apposée puis le résultat du cours sur l’<a href="/cours_informatique/cours/graphes/parcours-euleriens.html#prop-cycles-graph">existence de cycles dans un graphe</a>.</p>

<p>Pour la seconde preuve, on le montre par récurrence. La propriété est clairement vraie pour un graphe à 1 ou 2 sommets. On le suppose alors vraie jusqu’à $n$ sommets et on considère un graphe connexe à $n+1$ sommets.</p>

<p>POur ce graphe on choisi un sommet, $x$, que l’on supprime du graphe. Ce dernier n’est alors plus connexe et possède $p$ composantes connexes qui respectent l’hypothèse de récurrence : $\vert E_i \vert \geq \vet V_i \vert -1 pour chacune d’elles. En sommant le tout on a alors :</p>

\[\sum \vert E_i \vert \geq \sum (\vert V_i \vert -1)\]

<p>On conclut en remarquant que $\sum \vert E_i \vert = \vert E\vert -p$ et $\sum \vert V_i \vert = V - 1$.</p>

<h4 id="conditions">conditions</h4>

<blockquote class="a-faire">
  <p>Un graphe $G=(V, E)$ est un arbre si et seulement si :</p>

  <ul>
    <li>il est connexe</li>
    <li>$\vert E \vert = \vert V \vert - 1$</li>
  </ul>
</blockquote>

<p>clair avec ce qui précède.</p>

<blockquote class="a-faire">
  <p>un graphe $G=(V, E)$ est un arbre si et seulement si :</p>

  <ul>
    <li>il est sans cycle</li>
    <li>$\vert E \vert = \vert V \vert - 1$</li>
  </ul>
</blockquote>

<p>Tout pareil, clair avec ce qui précède.</p>

<blockquote class="a-faire">
  <p>prouver que :</p>

  <ul>
    <li>Si on ajoute une arête à un arbre (n’importe laquelle) on ajoute un cycle</li>
    <li>Si on supprime une arête à un arbre (n’importe laquelle) on le déconnecte</li>
  </ul>
</blockquote>

<p>Encore une fois, c’est clair (ils sont vraiment trop faciles ces exercices).</p>

<blockquote class="a-faire">
  <p>Donnez l’algorithme final pour savoir si un graphe est un arbre.</p>
</blockquote>

<p>On utilise le parcours en largeur pour obtenir la composante connexe à partir d’un élément. Si elle contient tous les éléments, le graphe est connexe et si ce graphe à $\vert V \vert -1$ c’est un graphe.</p>

<h2 id="arbre-enracinées">arbre enracinées</h2>

<h3 id="chemin-et-arbres">chemin et arbres</h3>

<blockquote class="a-faire">
  <p>Montrez que quelques soient deux sommets $x$ et $y$, il n’existe qu’un seul chemin entre $x$ et $y$.</p>
</blockquote>

<p>S’il existait 2 chemins distincts pour aller de $x$ à $y$ on se placerait au premier élément distincts et au premier élément en commun après celui-ci et on aurait un cycle.</p>

<h3 id="ordo-sommets">ordonnancement des sommets</h3>

<blockquote class="a-faire">
  <p>Donnez un exemple de chacun des termes pour le graphe ci-avant.</p>
</blockquote>

<ul>
  <li>$a$ est un <strong>ancêtre</strong> de $n$</li>
  <li>$g$ est un <strong>descendant</strong> de $d$</li>
  <li>$k$ est une <strong>feuille</strong></li>
  <li>$c$ est un <strong>nœud intérieur</strong></li>
  <li>$b$ est un <strong>successeur</strong> de $a$</li>
  <li>$h$ est un <strong>prédécesseur</strong> de $m$</li>
  <li>la <strong>hauteur</strong> de $2$ est 2</li>
  <li>la <strong>hauteur</strong> de l’arbre est 4</li>
</ul>

<h2 id="arbre-binaire-planté">arbre binaire planté</h2>

<h3 id="propriété-fondamentale-des-arbres-binaires">propriété fondamentale des arbres binaires</h3>

<blockquote class="a-faire">
  <p>Montrer que pour un arbre binaire, si noeud intérieur a exactement 2 successeurs, alors en notant $f$ le nombre de feuilles de l’arbre, on a :</p>

  <ul>
    <li>la hauteur de l’arbre est égale à $\log_2(f)$</li>
    <li>$f$ est égal au nombre de nœuds intérieurs plus 1.</li>
  </ul>
</blockquote>

<p>Si chaque noeud intérieur a 2 successeurs $ \sum \delta(x) = 2 + f + (n-f - 1) \cdot 3$. Comme $\vert E \vert = \vert V \vert -1 = n -1$, assemble ces deux équations pour obtenir $n + 1 = 2f$.</p>

<h3 id="exemple-du-tas">exemple du tas</h3>

<h4 id="le-problème">le problème</h4>

<h4 id="une-solution-possible-naïve">une solution possible (naïve)</h4>

<blockquote class="a-faire">
  <p>Quel est le coût algorithmique d’utiliser une telle solution ?</p>
</blockquote>

<p>On n’a besoin que de regarder chaque patient lorsqu’il faut en prendre en charge un nouveau. On a pas besoin de faire des choses lorsque les patients changent d’état de gravité ou partent et arrivent. Mais à chaque fois c’est $\mathcal{O}(n)$ opérations.</p>

<h4 id="un-tas">un tas</h4>

<p>Voir <a href="https://fr.wikipedia.org/wiki/Tas_(informatique)">wikipedia</a> pour (presque) toutes les informations nécessaire sur cette belle structure.</p>

<blockquote class="a-faire">
  <p>Des trois arbres ci-dessus lequel (il n’y en a qu’un) est binaire, complet et plein ?</p>
</blockquote>

<ul>
  <li>(a) est binaire mais pas complet</li>
  <li>(b) est binaire complet mais pas plein</li>
  <li>(c) est binaire, complet et plein.</li>
</ul>

<blockquote>
  <ul>
    <li>Créez un tas avec les nombres : 42, 12, 1, 3, 6, 5.</li>
    <li>Y a-t-il plusieurs possibilités ?</li>
    <li>que peut-on dire du nœud ayant le plus grand nombre ?</li>
  </ul>
</blockquote>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    42
 12    3
6  5  1
</code></pre></div></div>

<p>Ou encore :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    42
 12    6
6  1  5
</code></pre></div></div>

<p>Le plus grand noeud est <strong>toujours</strong> la racine du tas.</p>

<h4 id="manipulation-dun-tas">manipulation d’un tas</h4>

<blockquote class="a-faire">
  <p>Donner les algorithmes pour effectuer les opérations suivantes :</p>

  <ol>
    <li>ajout d’un élément</li>
    <li>modification d’une valeur</li>
    <li>suppression de la racine</li>
  </ol>
</blockquote>

<ol>
  <li>on l’ajoute à la fin et on le remonte (récursivement) si nécessaire</li>
  <li>on change la valeur puis on échange avec un de ses successeurs ou son prédécesseur récursivement</li>
  <li>on prend la dernière feuille, on la supprime et on modifie la racine avec la valeur de la feuille enlevée.</li>
</ol>

<blockquote class="a-faire">
  <p>En conclure que l’utilisation du tas est bien meilleure que la solution naïve.</p>
</blockquote>

<p>Toutes les opération nécessitent un nombre proportionnel à la hauteur du tas opérations. Et il y a $2^h$ éléments dans celui-ci. Nous opération sont donc toutes en $\mathcal{O}(\log_2(n))$ opérations.</p>

<h4 id="pour-la-bonne-bouche">pour la bonne bouche</h4>

<blockquote class="a-faire">
  <ul>
    <li>En déduire une façon de trier un tableau de nombre.</li>
    <li>trouver un de représenter un tas par une liste (on pourra parcourir le tas de haut en bas et de droite à gauche).</li>
  </ul>
</blockquote>

<p>On commence par un tas vide et on le remplit petit à petit (cela prend $n$ fois $\mathcal{O}(\log_2(n))$ opérations). Puis on supprime itérativement la racine $n$ fois. Ce qui prend encore $n$ fois $\mathcal{O}(\log_2(n))$ opérations.</p>

<p>On a donc un tri en $\mathcal{O}(n\log_2(n))$ opérations.</p>

<p>Pour la représentation en tableau, voir Voir <a href="https://fr.wikipedia.org/wiki/Tas_(informatique)">wikipedia</a> (on les place dans l’ordre de haut en bas et de droite à gauche).</p>

<h2 id="parcours">parcours</h2>

<blockquote class="note">
  <p>TBD</p>
</blockquote>

<h3 id="trois-parcours-classiques">trois parcours classiques</h3>

<blockquote class="a-faire">
  <p>Pour chaque parcours ci-après, donnez le résultat pour l’arbre de la partie <a href="#ordo-sommets">ordonnancement des sommets</a> en supposant que <code class="language-plaintext highlighter-rouge">Examen de la Racine</code>signifie : affiche le numéro de la racine à l’écran.</p>

  <p>Une fois ceci fait, trouvez un ordre qui lira les sommets dans l’ordre alphabétique.</p>
</blockquote>

<h2 id="arbre-dans-des-graphes-connexe">arbre dans des graphes connexe</h2>

<blockquote class="note">
  <p>TBD</p>
</blockquote>

<blockquote class="a-faire">
  <p>Montrer que pour tout graphe connexe $G = (V, E)$, il existe au moins un arbre $T=(V, E’)$ tel que $E’ \subseteq E$.</p>
</blockquote>

<h3 id="graphe-valué">graphe valué</h3>

<h4 id="une-mise-en-situation">une mise en situation</h4>

<blockquote class="a-faire">
  <p>Pourquoi ?</p>
</blockquote>

<h4 id="un-exemple">un exemple</h4>

<blockquote class="a-faire">
  <ul>
    <li>Quel est l’arête qui sera forcément dans tous les arbres couvrant de poids minimum ?</li>
    <li>Quel est l’arête qui ne sera forcément jamais dans un arbre couvrant de poids minimum ?</li>
    <li>y a-t-il plusieurs arbres couvrant de poids minimum pour ce graphe ?</li>
  </ul>
</blockquote>

<h4 id="propriété">propriété</h4>

<blockquote class="a-faire">
  <ul>
    <li>montrez que s’il existe deux arbres couvrant de poids minimum ne différent que d’une arête, alors elles on même valuation</li>
    <li>montrez que si toutes les valuations sont différentes, il n’existe qu’un seul arbre couvrant de poids minimal.</li>
    <li>montrez que la réciproque n’est pas vraie</li>
  </ul>
</blockquote>

<h4 id="un-algorithme">un algorithme</h4>

<p>Voir <a href="https://fr.wikipedia.org/wiki/Algorithme_de_Prim">wikipedia</a>.</p>

<blockquote class="a-faire">
  <p>Prouver que si G est connexe, alors T est connexe et est un arbre</p>
</blockquote>

<p>Une fois ceci fait :</p>

<blockquote class="a-faire">
  <p>Prouver que $T$ est <strong>un arbre couvrant de poids minimal</strong> pour $G$</p>
</blockquote>

<p>Maintenant qu’on est sur que ça marche :</p>

<blockquote class="a-faire">
  <p>Réalisez l’algorithme en entier sur le graphe précédent.</p>
</blockquote>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d&#39;informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d&#39;informatique</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d&#39;informatique à l&#39;école centrale marseille.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
