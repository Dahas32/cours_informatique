<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Théorie des graphes : arbres, élément de corrigé | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Théorie des graphes : arbres, élément de corrigé" />
<meta name="author" content="François Brucker" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Support de cours/td d’informatique à l’école centrale marseille." />
<meta property="og:description" content="Support de cours/td d’informatique à l’école centrale marseille." />
<link rel="canonical" href="/cours_informatique/cours/graphes/arbres-corrige.html" />
<meta property="og:url" content="/cours_informatique/cours/graphes/arbres-corrige.html" />
<meta property="og:site_name" content="cours d’informatique" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Théorie des graphes : arbres, élément de corrigé" />
<script type="application/ld+json">
{"headline":"Théorie des graphes : arbres, élément de corrigé","description":"Support de cours/td d’informatique à l’école centrale marseille.","@type":"WebPage","url":"/cours_informatique/cours/graphes/arbres-corrige.html","author":{"@type":"Person","name":"François Brucker"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css"><link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique" /><!-- Mathjax Support -->
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
      },
      svg: {
        fontCache: 'global'
      }
    };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
</head>

<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/cours_informatique/">cours d&#39;informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Théorie des graphes : arbres, élément de corrigé</h1></p>Auteur : <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">François Brucker</span></span></p>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/graphes/">graphes</a> / <a href="/cours_informatique/cours/graphes/arbres-corrige.html">arbres corrigé</a></p>
</blockquote>

<p>Eléments de corrigé des <a href="/cours_informatique/cours/graphes/arbres.html">exercices sur les arbres</a> où l’on donnera les principales pistes pour résoudre les exercices.</p>

<h2 id="définitions-et-premières-propriétés">définitions et premières propriétés</h2>

<h3 id="graphe-simple">graphe simple</h3>

<blockquote class="a-faire">
  <p>Redonnez la définition d’un graphe simple. Combien d’arêtes au maximum peut contenir un graphe simple ?</p>
</blockquote>

<p><a href="/cours_informatique/cours/graphes/#restrictions">Dans le cours</a> : un graphe simple est un graphe sans boucle et non orienté</p>

<h3 id="arbre-ou-pas-arbre-">arbre ou pas arbre ?</h3>

<blockquote class="a-faire">
  <p>Déduire de la définition lequel des 2 graphes ci-dessous est un arbre.</p>
</blockquote>

<p>C’est bien sûr le graphe B qui est connexe et ne contient pas de cycle. Le graphe A est connexe mais il contient des cycles.</p>

<h3 id="algorithme-de-reconnaissance">algorithme de reconnaissance</h3>

<h4 id="graphe-connexe">graphe connexe</h4>

<blockquote class="a-faire">
  <ol>
    <li>Donnez un algorithme permettant de savoir si un graphe $G = (V, E)$ donné est connexe.</li>
    <li>Quelle structure de graphe utiliseriez-vous pour que cet algorithme ait la plus petite complexité possible ?</li>
  </ol>
</blockquote>

<p>On utilise le <a href="https://fr.wikipedia.org/wiki/Algorithme_de_parcours_en_largeur">parcours en largeur des graphes</a>. Comme il faut examiner tous les voisins d’un sommet, on a coutume d’utiliser les listes d’adjacence pour que le nombre d’opérations de l’algorithme soit proportionnel au nombre d’arêtes du graphe ($\mathcal{O}(\vert E \vert)$) : il est donc optimal.</p>

<h4 id="graphe-sans-cycle-">graphe sans cycle ?</h4>

<blockquote class="a-faire">
  <ul>
    <li>Tout graphe sans cycle contient au maximum $\vert V \vert - 1$ arêtes.</li>
    <li>Tout graphe connexe contient au minimum $\vert V \vert - 1$ arêtes.</li>
  </ul>
</blockquote>

<p>Pour la 1ère preuve, on suppose alors qu’il existe un graphe $G= (V, E)$, tel que $\vert E \vert \geq \vert V \vert$ et qu’il n’y ait pas de cycles.</p>

<p>Commençons par remarquer que si $\vert E \vert \geq \vert V \vert$, alors forcément $\vert V \vert \geq 3$ et s’il n’a pas de cycle alors $\vert V \vert &gt; 3$. De là, on peut choisir $G$ avec le plus petit nombre de sommets possible.</p>

<p>S’il existait dans ce graphe un sommet de degré plus petit ou égal à 1, on pourrait le supprimer du graphe et on aurait un graphe $G’ = (V’, E’)$ avec strictement moins de sommets que $G$, tel que $\vert E’ \vert \geq \vert V’ \vert$ et qui ne contiendrait pas de cycle (on ne peut pas ajouter de cycle en supprimant une arête ou un sommet à un graphe). Ce qui est impossible par choix de $G$.</p>

<p>Donc tout sommet de $G$ a un degré d’au moins 2 et il existe un cycle (<a href="/cours_informatique/cours/graphes/parcours-euleriens.html#prop-cycles-graph">c’est dans le cours</a>) : notre hypothèse était fausse.</p>

<p>Pour la seconde preuve, on la montre par récurrence. La propriété est clairement vraie pour un graphe à 1 ou 2 sommets. On la suppose alors vraie jusqu’à $n$ sommets et on considère un graphe connexe à $n+1$ sommets.</p>

<p>Pour ce graphe on choisi un sommet, $x$, que l’on supprime du graphe. Ce dernier n’est alors plus connexe et possède $p$ composantes connexes qui respectent l’hypothèse de récurrence : $\vert E_i \vert \geq \vert V_i \vert -1$ pour chacune d’elles. En sommant le tout on a alors :</p>

\[\sum \vert E_i \vert \geq \sum (\vert V_i \vert -1)\]

<p>On conclut en remarquant que $\sum \vert E_i \vert = \vert E\vert -p$ et $\sum \vert V_i \vert = V - 1$.</p>

<h4 id="conditions">conditions</h4>

<blockquote class="a-faire">
  <p>Un graphe $G=(V, E)$ est un arbre si et seulement si :</p>

  <ul>
    <li>il est connexe</li>
    <li>$\vert E \vert = \vert V \vert - 1$</li>
  </ul>
</blockquote>

<p>clair avec ce qui précède.</p>

<blockquote class="a-faire">
  <p>un graphe $G=(V, E)$ est un arbre si et seulement si :</p>

  <ul>
    <li>il est sans cycle</li>
    <li>$\vert E \vert = \vert V \vert - 1$</li>
  </ul>
</blockquote>

<p>Tout pareil, clair avec ce qui précède.</p>

<blockquote class="a-faire">
  <p>prouver que :</p>

  <ul>
    <li>Si on ajoute une arête à un arbre (n’importe laquelle) on ajoute un cycle</li>
    <li>Si on supprime une arête à un arbre (n’importe laquelle) on le déconnecte</li>
  </ul>
</blockquote>

<p>Encore une fois, c’est clair (ils sont vraiment trop faciles ces exercices).</p>

<blockquote class="a-faire">
  <p>Donnez l’algorithme final pour savoir si un graphe est un arbre.</p>
</blockquote>

<p>On utilise le parcours en largeur pour obtenir la composante connexe à partir d’un élément. Si elle contient tous les éléments, le graphe est connexe, et si ce graphe a $\vert V \vert -1$ arêtes, alors c’est un arbre.</p>

<h2 id="arbre-enraciné">arbre enraciné</h2>

<h3 id="chemins-et-arbres">chemins et arbres</h3>

<blockquote class="a-faire">
  <p>Montrez que quels que soient deux sommets $x$ et $y$, il n’existe qu’un seul chemin entre $x$ et $y$.</p>
</blockquote>

<p>S’il existait 2 chemins distincts pour aller de $x$ à $y$ on se placerait au premier élément distinct et au premier élément en commun après celui-ci et on aurait un cycle.</p>

<h3 id="ordo-sommets">ordonnancement des sommets</h3>

<blockquote class="a-faire">
  <p>Donnez un exemple de chacun des termes pour le graphe ci-avant.</p>
</blockquote>

<ul>
  <li>$a$ est un <strong>ancêtre</strong> de $n$</li>
  <li>$g$ est un <strong>descendant</strong> de $d$</li>
  <li>$k$ est une <strong>feuille</strong></li>
  <li>$c$ est un <strong>nœud intérieur</strong></li>
  <li>$b$ est un <strong>enfant</strong> de $a$</li>
  <li>$h$ est un <strong>parent</strong> de $m$</li>
  <li>la <strong>hauteur</strong> de $i$ est 2</li>
  <li>la <strong>hauteur</strong> de l’arbre est 4</li>
</ul>

<h2 id="arbre-binaire-planté">arbre binaire planté</h2>

<h3 id="propriété-fondamentale-des-arbres-binaires">propriété fondamentale des arbres binaires</h3>

<blockquote class="a-faire">
  <p>Montrer que pour un arbre binaire, si tout noeud intérieur a exactement 2 enfants, alors en notant $f$ le nombre de feuilles de l’arbre, on a :</p>

  <ul>
    <li>la hauteur de l’arbre est égale à $\log_2(f)$</li>
    <li>$f$ est égal au nombre de nœuds intérieurs plus 1.</li>
  </ul>
</blockquote>

<p>Si chaque noeud intérieur a 2 enfants $ \sum \delta(x) = 2 + f + (n-f - 1) \cdot 3$. Comme $\vert E \vert = \vert V \vert -1 = n -1$, on assemble ces deux équations pour obtenir $n + 1 = 2f$.</p>

<h3 id="exemple-du-tas">exemple du tas</h3>

<h4 id="le-problème">le problème</h4>

<h4 id="une-solution-possible-naïve">une solution possible (naïve)</h4>

<blockquote class="a-faire">
  <p>Quel est le coût algorithmique d’utiliser une telle solution ?</p>
</blockquote>

<p>On a simplement besoin de regarder chaque patient lorsqu’il faut en prendre en charge un nouveau. On n’a pas besoin de faire des choses lorsque les patients changent d’état de gravité ou partent et arrivent. Mais à chaque fois c’est $\mathcal{O}(n)$ opérations.</p>

<h4 id="un-tas">un tas</h4>

<p>Voir <a href="https://fr.wikipedia.org/wiki/Tas_(informatique)">wikipedia</a> pour (presque) toutes les informations nécessaire sur cette belle structure.</p>

<blockquote class="a-faire">
  <p>Des trois arbres ci-dessus lequel (il n’y en a qu’un) est binaire, complet et plein ?</p>
</blockquote>

<ul>
  <li>(a) est binaire mais pas complet</li>
  <li>(b) est binaire complet mais pas plein</li>
  <li>(c) est binaire, complet et plein.</li>
</ul>

<blockquote>
  <ul>
    <li>Créez un tas avec les nombres : 42, 12, 1, 3, 6, 5.</li>
    <li>Y a-t-il plusieurs possibilités ?</li>
    <li>que peut-on dire du nœud ayant le plus grand nombre ?</li>
  </ul>
</blockquote>

<p><img src="/cours_informatique/assets/cours/graphes/tas_2-possibilites.png" alt="tas possibles" style="margin: auto;display: block;" /></p>

<p>Le plus grand noeud est <strong>toujours</strong> la racine du tas.</p>

<h4 id="manipulation-dun-tas">manipulation d’un tas</h4>

<blockquote class="a-faire">
  <p>Donner les algorithmes pour effectuer les opérations suivantes :</p>

  <ol>
    <li>ajout d’un élément</li>
    <li>modification d’une valeur</li>
    <li>suppression de la racine</li>
  </ol>
</blockquote>

<ol>
  <li>on l’ajoute à la fin et on le remonte (récursivement) si nécessaire</li>
  <li>on change la valeur puis on échange récursivement
    <ul>
      <li>avec son parent si la valeur est plus grande ou</li>
      <li>avec son enfant de valeur maximum si la valeur est plus petite</li>
    </ul>
  </li>
  <li>on prend la dernière feuille, on la supprime et on modifie (avec l’opération 2) la racine avec la valeur de la feuille enlevée.</li>
</ol>

<blockquote class="a-faire">
  <p>En conclure que l’utilisation du tas est bien meilleure que la solution naïve.</p>
</blockquote>

<p>Toutes les opérations nécessitent un nombre de calculs proportionnel à la hauteur $h$ du tas. Et il y a $n = 2^h$ éléments dans celui-ci. Nos opérations sont donc toutes en $\mathcal{O}(\log_2(n)) = \mathcal{O}(h)$ opérations.</p>

<h4 id="pour-la-bonne-bouche">pour la bonne bouche</h4>

<blockquote class="a-faire">
  <ul>
    <li>En déduire une façon de trier un tableau de nombres.</li>
    <li>trouver un moyen de représenter un tas par une liste (on pourra parcourir le tas de haut en bas et de droite à gauche).</li>
  </ul>
</blockquote>

<p>On commence par un tas vide et on le remplit petit à petit (cela prend $n$ fois $\mathcal{O}(\log_2(n))$ opérations). Puis on supprime itérativement la racine $n$ fois. Ce qui prend encore $n$ fois $\mathcal{O}(\log_2(n))$ opérations.</p>

<p>On a donc un tri en $\mathcal{O}(n\log_2(n))$ opérations.</p>

<p>Pour la représentation en tableau, voir Voir <a href="https://fr.wikipedia.org/wiki/Tas_(informatique)">wikipedia</a> (on les place dans l’ordre de haut en bas et de droite à gauche).</p>

<h2 id="parcours">parcours</h2>

<h3 id="trois-parcours-classiques">trois parcours classiques</h3>

<blockquote class="a-faire">
  <p>Pour chaque parcours ci-après, donnez le résultat pour l’arbre de la partie <a href="#ordo-sommets">ordonnancement des sommets</a> en supposant que <code class="language-plaintext highlighter-rouge">Examen de la Racine</code> signifie : affiche le numéro de la racine à l’écran.</p>

  <p>Une fois ceci fait, trouvez un ordre qui lira les sommets dans l’ordre alphabétique à partir de la lettre b (en oubliant la racine).</p>
</blockquote>

<ul>
  <li>pré-ordre : a-b-h-l-m-n-i-j-k-c-d-e-g-f</li>
  <li>post-ordre : l-n-m-h-j-k-i-b-g-e-f-d-c-a</li>
  <li>en-ordre : l-h-n-m-b-j-i-k-a-c-g-e-d-f</li>
</ul>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>alphabetique(racine)
    examen enfant gauche
    examen enfant droit
    alphabetique(enfant droit)
    alphabetique(enfant gauche)
    
</code></pre></div></div>

<h2 id="arbre-dans-des-graphes-connexe">arbre dans des graphes connexe</h2>

<blockquote class="a-faire">
  <p>Montrer que pour tout graphe connexe $G = (V, E)$, il existe au moins un arbre $T=(V, E’)$ tel que $E’ \subseteq E$.</p>
</blockquote>

<p>Si un graphe est connexe et n’est pas un arbre, alors il existe un cycle. En supprimant une arête de ce cycle le graphe reste connexe et a strictement moins d’arêtes. On peut alors itérativement supprimer des arêtes à un arbre connexe qui contient un cycle jusqu’à obtenir un graphe connexe à $\vert V \vert -1$ arêtes qui ne contient pas de cycles : ce sera un arbre.</p>

<h3 id="graphe-valué">graphe valué</h3>

<h4 id="une-mise-en-situation">une mise en situation</h4>

<blockquote class="a-faire">
  <p>Pourquoi ?</p>
</blockquote>

<p>Un arbre est la structure minimale en nombre d’arêtes qui garantie la connexité. Parmi tous les arbres couvrants du graphe, on peut prendre un de ceux qui ont une somme des valuations de ses arêtes minimale (il y en a un nombre fini, le min existe donc mais il peut y en avoir plusieurs). Si la valuation d’une arête représente le coût, un arbre couvrant de poids minimal représente une solution de coût minimal pour rendre connexe le territoire.</p>

<h4 id="un-exemple">un exemple</h4>

<blockquote class="a-faire">
  <ul>
    <li>Quel est l’arête qui sera forcément dans tous les arbres couvrants de poids minimum ?</li>
    <li>Quel est l’arête qui ne sera forcément jamais dans un arbre couvrant de poids minimum ?</li>
    <li>y a-t-il plusieurs arbres couvrants de poids minimum pour ce graphe ?</li>
  </ul>
</blockquote>

<p>Toutes les preuves de cette partie et de la partie suivante vont fonctionner la même manière :</p>

<ol>
  <li>on va ajouter une arête à un arbre</li>
  <li>ce nouveau graphe n’est plus un arbre mais il est connexe : il existe un cycle</li>
  <li>en supprimant n’importe quelle arête de ce cycle, le graphe redevient un arbre.</li>
  <li>si on supprime judicieusement l’arête du cycle, on arrivera à une contradiction. car le nouvel arbre sera mieux que l’arbre initial.</li>
</ol>

<ul>
  <li>Il n’y a qu’une seule arête avec une valuation minimale. S’il existait un arbre couvrant qui ne la possédait pas, on pourrait l’ajouter à cet arbre. Ce ne serait alors plus un arbre, il existerait donc un cycle. En supprimant une arête de ce cycle (on peut choisir une arête de valuation non minimale) on aurait à nouveau un arbre (connexe et nombre minimum d’arête), mais qui serait de valuation totale strictement plus petite que notre premier arbre. Ce qui est impossible puisqu’il était déjà de valuation minimale.</li>
  <li>Il n’y a qu’une seule arête avec une valuation maximale. De plus, il existe des cycles la contenant dans le graphe initial. Si on suppose qu’un arbre couvrant possède cette arête de valuation maximale et qu’on la supprime de l’arbre, on va se retrouver avec 2 parties connexes. Comme il existe un cycle contenant l’arête de valuation maximale dans le graphe initial, il va exister une arête du graphe initial qui relie les 2 parties connexes nouvellement créées. L’ajouter à notre graphe va à nouveau le rendre connexe : ce sera à nouveau un arbre. Comme il serait de valuation strictement plus petite que notre arbre initial, ce n’est pas possible.</li>
  <li>Oui, il existe plusieurs arbres couvrant car le cycle k-g-j-l est de valuation constante et valant 2. Un raisonnement identique aux 2 précédent montre que l’on peut échanger une arête de valuation 2 par une autre dans un arbre de valuation minimale.</li>
</ul>

<h4 id="propriété">propriété</h4>

<blockquote class="a-faire">
  <ul>
    <li>montrez que s’il existe deux arbres couvrants de poids minimum qui ne différent que d’une arête, alors elles ont même valuation</li>
    <li>montrez que si toutes les valuations sont différentes, il n’existe qu’un seul arbre couvrant de poids minimal.</li>
    <li>montrez que la réciproque n’est pas vraie</li>
  </ul>
</blockquote>

<ul>
  <li>Les 2 arbres ont même valuation de la somme des valuations de leurs arêtes :les 2 arêtes différentes ont donc forcément même valuation.</li>
  <li>On range les valuations des 2 arbres par ordre croissant. Les deux arbres étant différents, on s’arrête à la 1ère position dans cet ordre qui contient 2 arêtes différentes. L’une des arêtes va avoir une valuation inférieure à l’autre. On peut alors procéder comme précédemment et ajouter l’arête de valuation la plus petite dans l’autre arbre. Il faudra alors à nouveau supprimer une arête qui forme un cycle, mais on pourra enlever une arête de valuation plus grande, ce qui est impossible car l’arbre initial était de valuation minimale.</li>
  <li>Si le graphe de départ est un arbre, il n’y a qu’un seul arbre couvant et les valuations peuvent être égales.</li>
</ul>

<h4 id="un-algorithme">un algorithme</h4>

<p>Voir <a href="https://fr.wikipedia.org/wiki/Algorithme_de_Prim">wikipedia</a>. Tout y est très bien expliqué.</p>

<blockquote class="a-faire">
  <p>Prouver que si G est connexe, alors T est connexe et est un arbre</p>
</blockquote>

<p>Une fois ceci fait :</p>

<blockquote class="a-faire">
  <p>Prouver que $T$ est <strong>un arbre couvrant de poids minimal</strong> pour $G$</p>
</blockquote>

<p>Maintenant qu’on est sur que ça marche :</p>

<blockquote class="a-faire">
  <p>Réalisez l’algorithme en entier sur le graphe précédent.</p>
</blockquote>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d&#39;informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d&#39;informatique</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d&#39;informatique à l&#39;école centrale marseille.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
