<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Théorie des graphes : chemins | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="Théorie des graphes : chemins">
<meta name="author" content="François Brucker">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique de François Brucker.">
<meta property="og:description" content="Support de cours/td d’informatique de François Brucker.">
<link rel="canonical" href="/cours_informatique/cours/graphes/chemins.html">
<meta property="og:url" content="/cours_informatique/cours/graphes/chemins.html">
<meta property="og:site_name" content="cours d’informatique">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Théorie des graphes : chemins">
<script type="application/ld+json">
{"description":"Support de cours/td d’informatique de François Brucker.","author":{"@type":"Person","name":"François Brucker"},"@type":"WebPage","url":"/cours_informatique/cours/graphes/chemins.html","headline":"Théorie des graphes : chemins","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Théorie des graphes : chemins</h1>Auteur : <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">François Brucker</span></span>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/graphes/">graphes</a> / <a href="/cours_informatique/cours/graphes/chemins.html">chemins</a></p>
</blockquote>

<h2 id="but">But</h2>

<p>Chemins entre deux sommets.</p>

<p><a href="/cours_informatique/cours/graphes/chemins-corrige.html">éléments de corrigé</a></p>

<h2 id="définitions">définitions</h2>

<p>Un chemin d’un graphe $G=(V,E)$ (orienté ou non) est une suite de sommets $s_0 \dots s_k$ telle que :</p>

<ul>
  <li>$s_is_{i+1}$ est une arête</li>
  <li>$s_is_{i+1} \neq s_js_{j+1}$ si $i\neq j$</li>
</ul>

<p>Si le graphe possède de plus une valuation qui associe un réel à toute arête, la <strong>longueur d’un chemin</strong> est la somme des valuations de ses arêtes.</p>

<h2 id="dijkstra">Dijkstra</h2>

<p>L’<a href="https://fr.wikipedia.org/wiki/Algorithme_de_Dijkstra">algorithme de Dijkstra</a> permet, à partir d’un graphe orienté valué, de trouver un chemin de longueur minimum entre deux sommets $d$ (départ) et $a$ (arrivée).</p>

<p>Il ressemble beaucoup à l’<a href="/cours_informatique/cours/graphes/arbres.html#algo-prim">algorithme de Prim</a> que l’on a vu précédemment.</p>

<h3 id="pseudo-code">pseudo-code</h3>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entrée :
    * un graphe orienté G = (V, E)
    * une valuation f qui associe un réel positif à toute arête de G
    * deux sommets d et a de V
Initialisation :
    * cout_entree(x) = +∞ pour tout sommet x
    * predecesseur(x) = x pour tout sommet x
    * V' = {}, E' = {}
Algorithme :
    * cout_entree(d) = 0
    * ajoute d à V' 
    * r = d   
    * tant que a n'est pas dans V':
        * pour tous les voisins sortant x de r qui ne sont pas dans V':
            * si cout_entree(x) &gt;= cout_entree(r) + f(rx):
                cout_entree(x) = cout_entree(r) + f(rx)
                predecesseur(x) = r
        * soit x le sommet de V qui n'est pas dans V' minimisant cout_entree(x)
        * r = x
        * ajoute r à V' et (predecesseur(r), r) à E'
    * chemin = [a]
    * x = a
    * tant que x est différent de d:
        * x = predecesseur(x)
        * ajoute x au début de chemin        
Retour :
    chemin
</code></pre></div></div>

<blockquote>
  <p>Notez que la valuation d’une arête est positive ou nulle.</p>
</blockquote>

<h3 id="test">test</h3>

<blockquote class="a-faire">
  <p>Allez de Paris à Rana en moins de temps possible en utilisant l’algorithme de Dijkstra sur le graphe ci-après, qui représente les différents vols et leurs durées entre différentes villes d’Europe.</p>
</blockquote>

<p><img src="/cours_informatique/assets/cours/graphes/chemin_paris_rana.png" alt="Paris à Rana" style="margin: auto;display: block;"></p>

<h3 id="preuve-dijkstra">preuve</h3>

<blockquote class="a-faire">
  <p>En utilisant la preuve de l’algorithme de Prim, montrez que l’algorithme de Dijkstra rend un chemin de longueur minimum entre $d$ et $a$</p>
</blockquote>

<h3 id="complexité">complexité</h3>

<blockquote class="a-faire">
  <p>Quelle est la complexité de l’algorithme de Disjkstra ?</p>
</blockquote>

<h2 id="arborescence">arborescence</h2>

<p>On peut continuer l’algorithme de Diskstra après que $a$ ait été rentré dans $V’$, jusqu’à ce que l’on ait plus que des éléments de coût infini à faire rentrer dans $V’$ ou que $V’$ soit égal à $V$.</p>

<blockquote class="a-faire">
  <p>Montrez que pour tous les sommets $x$ qui ne peuvent pas entrer dans $V’$, il n’existe pas de chemin entre $d$ et $x$ dans $G$</p>
</blockquote>

<h3 id="preuve-dijkstra-arborescence">preuve</h3>

<blockquote class="a-faire">
  <p>Montrez que si l’on peut continuer l’algorithme de Dijkstra jusqu’à ce que $V’$ soit égal à $V$ on obtient un graphe $G’ = (V, E’)$ tel que :</p>

  <ul>
    <li>$\vert E’ \vert = \vert V \vert -1$</li>
    <li>il existe un unique chemin entre $d$ et tout autre sommet</li>
    <li>le chemin entre $d$ et $x$ dans $G’$ est de poids minimum dans $G$</li>
  </ul>
</blockquote>

<h3 id="prim-vs-dijkstra">Prim vs Dijkstra</h3>

<blockquote class="a-faire">
  <p>Quelle est la différence entre Prim et Dijsktra ?
Montrez que les problèmes qu’ils résolvent sont différents et en déduire que l’arborescence obtenue par l’algorithme de Dijsktra pour un graphe non orienté peut être différente de l’arbre de poids minimum obtenu par Prim</p>
</blockquote>

<h2 id="chemin-le-plus-long">chemin le plus long</h2>

<p>L’algorithme de Dijkstra permet de répondre à la question : <em>quelle est la longueur des chemins les plus courts partant d’un sommet</em>. Mais qu’en est-il du pendant : <em>quelle est la longueur des chemins les plus longs partant d’un sommet</em> ?</p>

<p>On suppose que le problème est maintenant : quel est la longueur maximale d’un chemin passant une unique fois par chaque sommet ?</p>

<p>C’est le problème du <strong>plus long chemin élémentaire</strong> (les sommets n’apparaissent qu’une unique fois).</p>

<h3 id="algorithme-">algorithme ?</h3>

<p>Une idée serait de renverser les inégalités dans l’algorithme (de rentrer dans la structure à chaque fois l’élément de plus grand coût), puis de faire l’arborescence de Dijkstra pour chaque sommet de $V$ et enfin de prendre le chemin le plus long obtenu pour toutes les arborescences.</p>

<blockquote class="a-faire">
  <p>Montrez que cette approche ne fonctionne pas.</p>
</blockquote>

<h3 id="chemin-hamiltonien">chemin hamiltonien</h3>

<p>Il est illusoire de tenter de trouver un algorithme pour résoudre le problème du chemin le plus long dans le cas général car il permettrait de résoudre le problème du <a href="https://fr.wikipedia.org/wiki/Graphe_hamiltonien">chemin hamiltonien</a> qui peut s’écrire ainsi : existe-t-il un chemin élémentaire passant par tous les sommets d’un graphe G donné ?</p>

<blockquote class="a-faire">
  <p>Montrer que si l’on pouvait résoudre le problème d’un chemin le plus long dans un graphe, on pourrait résoudre le problème du chemin hamiltonien.</p>
</blockquote>

<p>Ce problème est <a href="https://fr.wikipedia.org/wiki/Probl%C3%A8me_NP-complet">NP-complet</a>, c’est à dire qu’il fait parti des problèmes algorithmiques les plus durs à résoudre (et que le résoudre facilement permettrait de résoudre facilement tous les problèmes algorithmiques qu’on peut se poser).</p>

<blockquote>
  <p>Notez comment une petite différence — remplacer sommet (hamiltonien) par arête (eulérien) — rend un problème soit très simple soit très compliqué à résoudre.</p>
</blockquote>

<p>Le problème de trouver un chemin hamiltonien dans un graphe peut paraître un peu artificiel mais il est crucial en pratique dans sa version <a href="https://fr.wikipedia.org/wiki/Probl%C3%A8me_du_voyageur_de_commerce">voyageur de commerce</a> qui est la base de toute optimisation de tournée ou de nombre de problèmes liés au transport.</p>

<h3 id="graphes-particuliers">graphes particuliers</h3>

<p>Il existe tout de même 2 classes de graphes particulières qui admettent des solutions faciles pour le problème du chemin élémentaire le plus long :</p>

<ul>
  <li>les <a href="https://fr.wikipedia.org/wiki/Graphe_orient%C3%A9_acyclique">graphes orientés sans circuits</a>
</li>
  <li>les <a href="https://fr.wikipedia.org/wiki/Tournoi_(th%C3%A9orie_des_graphes)">tournois</a>
</li>
</ul>

<h4 id="graphe-sans-circuit">graphe sans circuit</h4>

<p>Un graphe orienté qui ne contient pas de circuit est souvent appelé <em>DAG</em> (direct acyclic graph).</p>

<p>On appelle <strong>tri topologique</strong> d’un graphe orienté $G = (V, E)$ un ordre total $&lt;$ sur les sommets du graphe tel que $xy \in E$ implique $x &lt; y$ dans l’ordre.</p>

<blockquote class="a-faire">
  <p>Montrer que :</p>

  <ol>
    <li>un graphe ne peut admettre de tri topologique que s’il n’a pas de cycle</li>
    <li>pour un DAG, il existe toujours un sommet qui n’a pas de voisins entrant (<em>resp.</em> sortant)</li>
    <li>en déduire qu’un DAG admet un tri topologique</li>
    <li>conclure sur le fait qu’un graphe est un DAG si et seulement s’il admet un tri topologique</li>
  </ol>
</blockquote>

<p>On utilisera souvent ce tri pour résoudre des problèmes d’ordonnancement (on le verra tout à l’heure dans un cas d’importance certaine).</p>

<blockquote class="a-faire">
  <p>Utiliser le tri pour trouver un chemin élémentaire de longueur maximum dans un DAG.</p>
</blockquote>

<h4 id="tournoi">tournoi</h4>

<p>Un <a href="https://fr.wikipedia.org/wiki/Tournoi_(th%C3%A9orie_des_graphes)">tournoi</a> est un graphe orienté $T = (V, E)$  tel que quelque soit $x \neq y \in V$ soit $xy$ soit $yx$ est une arête, mais pas les deux.</p>

<p>Un tournoi est très utilisé en théorie du choix social et en théorie des votes car il modélise bien les choix et les soucis entre choix locaux (quelque soit une alternative on en préfère l’une à l’autre) et optimum global (existe-t-il un choix qui est préféré à tous les autres).</p>

<p>Dans ce champ applicatif, les cycles sont problématiques (A est préféré à B qui est préféré à C qui est préféré à A).</p>

<blockquote class="a-faire">
  <p>Montrer qu’un tournoi n’admet pas de cycle si et seulement si il est transitif</p>
</blockquote>

<p>Mais pour ce qui nous intéresse, il est rigolo de voir qu’un tournoi admet toujours un chemin qui passe par tous les sommets une unique fois.</p>

<blockquote class="a-faire">
  <p>Montrez le</p>
</blockquote>

<p>Donc quelles que soient les préférences, on peut toujours ordonner les préférences selon un ordre total (même s’il y en a plusieurs) localement cohérent (pour chaque élément il est préféré à celui d’avant et on lui préfèrera celui d’après dans l’ordre).</p>

<h3 id="ordonnancement">ordonnancement</h3>

<p>Un <a href="https://fr.wikipedia.org/wiki/Th%C3%A9orie_de_l%27ordonnancement">problème d’ordonnancement</a> peut se modéliser par un DAG nommé graphe de dépendances où si $xy$ est une arête alors il faut faire $x$ avant de pouvoir faire $y$.</p>

<blockquote class="a-faire">
  <p>Pourquoi ne doit-il pas y avoir de cycles dans un graphe de dépendance ?</p>
</blockquote>

<p>Vous résolvez des problèmes d’ordonnancement tous les jours comme par exemple comment s’habiller le matin (voir graphe ci-après)</p>

<p><img src="/cours_informatique/assets/cours/graphes/chemin_habillage.png" alt="habillage" style="margin: auto;display: block;"></p>

<blockquote class="a-afaire">
  <p>Montrer que le tri topologique est une solution au problème d’ordonnancement. Appliquez le au problème de s’habiller le matin.</p>
</blockquote>

<p>C’est encore un exemple où les contraintes sont locales et ou l’on cherche une solution globale.</p>

<h2 id="variantes">variantes</h2>

<p>On va montrer trois variantes de la recherche d’un chemin de longueur minimale entre deux sommets pour des graphes valués d’intérêt pratique.</p>

<h3 id="poids-négatifs">poids négatifs</h3>

<blockquote class="a-faire">
  <p>Montrez que si le graphe peut avoir des valuations positives et négatives, l’algorithme de Dijkstra ne garantit pas de trouver un chemin de longueur minimum</p>
</blockquote>

<p>D’ailleurs, un tel chemin existe-t-il ?</p>

<blockquote class="a-faire">
  <p>Montrez que s’il existe un circuit de valuation strictement négative (on appelle ces circuit <strong>circuits absorbant</strong>), la notion même de chemin de valuation minimum cesse d’exister</p>
</blockquote>

<p>Pour régler ce problème, on utilise l’algorithme de <a href="https://fr.wikipedia.org/wiki/Algorithme_de_Floyd-Warshall">Floyd-Warshall</a> qui trouve, en $\mathcal{O}(\vert V \vert ^3)$ :</p>

<ul>
  <li>les circuits absorbant s’il y en a</li>
  <li>tous les chemins de longueur minimum allant de $x$ à $y$ pour tous les sommets $x$ et $y$.</li>
</ul>

<blockquote>
  <p>Si les poids sont positifs, il vaut mieux utiliser Dijkstra pour trouver 1 chemin entre $x$ et $y$ ou tous les chemins de $x$ à tous les autres sommets, mais si l’on cherche  tous les chemins, il vaut mieux utiliser Floyd-Warshall.</p>
</blockquote>

<h3 id="graphe-inconnu-ou-changeant">graphe inconnu ou changeant</h3>

<p>Un algorithme beaucoup utilisé lorsque le graphe peut changer ou s’il est très grand, voir inconnu (un terrain de jeu) est l’algorithme $A^*$.</p>

<p>Son principe est identique à celui de Dijkstra, mais plutôt que de prendre à chaque fois l’élément de coût minimum, on choisit un élément dont le <code class="language-plaintext highlighter-rouge">cout_entree</code> + une distance heuristique sur sa distance à l’arrivée est minimum.</p>

<p>Si l’heuristique est valide, l’algorithme va considérer moins de sommets que Dijkstra.</p>

<p>On l’utilise aussi souvent pour avancer directement à cet élément dans les algorithme de pathfinding par exemple.</p>

<blockquote class="a-faire">
  <p>Proposez une implémentation de l’algorithme $A^*$ pour le parcours dans une salle d’un petit robot (un étudiant lambda un jeudi matin par exemple).</p>
</blockquote>

<p>On peut aussi montrer que si l’algorithme $A^*$ a une heuristique qui ne surestime pas la distance finale, il va bien trouver un chemin de poids minimum.</p>

<blockquote class="a-faire">
  <p>Donner un exemple qui montre que si l’algorithme $A^*$ a une heuristique qui surestime le coût du chemin réel il se peut qu’il ne rende pas le bon chemin.</p>
</blockquote>

<h3 id="grand-graphes">grand graphes</h3>

<p>C’est la technique utilisée par google maps. Pour le graphe de google maps, il est impossible de faire un algorithme de Dijkstra à chaque requête, cela prendrait bien trop de temps !</p>

<p>On ne peut pas non plus mettre les chemins en dur, car il faudrait une base de donnée gigantesque. Comment résoudre ce problème épineux ?</p>

<p>En utilisant des hubs ! On remarque en effet que lorsque l’on fait un plus court chemin entre 2 sommets quelconques sur un graphe de google maps les débuts de chemins sont souvent identiques (on prend les grandes routes) et divergent fortement à la fin (petites routes jusqu’à la destination).</p>

<p>On procède alors à un pré-traitement en calculant pour chaque sommet $x$ tous les chemins les plus courts (on crée l’arborescence de ce sommet). Et pour chaque chemin ainsi crée, on choisit la ville avec le plus d’habitants qui se trouve sur le second tiers du chemin. Toutes ces villes constituent les <em>hubs</em> de ce sommet $x$.</p>

<blockquote>
  <p>Notez que si l’on va de A à B sur des routes à double sens, le hub pour le chemin allant de A à B est le même que le hub pour le chemin allant de B à A.</p>
</blockquote>

<p>Sur une carte de géographie, on remarque qu’il y a très peu de hubs !</p>

<p>Une fois ce pré-traitement effectué, lorsqu’un utilisateur veut aller de A à B :</p>

<ol>
  <li>google choisi un hub commun H1 à A et B et crée 2 routes, une allant de A à H1 et l’autre allant de H1 à B</li>
  <li>on récurse pour les chemins créés en cherchant un hub commun H2 à A et H1 et un hub commun H2’ à H1 et B et ainsi de suite jusqu’à arriver à des chemins <em>“courts”</em>.</li>
  <li>jusqu’à arriver à des chemins courts où l’on peut faire un dijkstra entre les deux sommets rapidement.</li>
</ol>

<p>Le temps de calcul en est très réduit puisque les hubs sont calculés en amont de la requête.</p>

<blockquote class="a-faire">
  <p>Montrez avec les 3 (plus belles) villes (de France) que sont Marseille, Strasbourg et Brest comment les choix de hubs peuvent drastiquement influencer le chemin proposé.</p>
</blockquote>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique de François Brucker.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
