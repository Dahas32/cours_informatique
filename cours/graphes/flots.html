<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Théorie des graphes : flots | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Théorie des graphes : flots" />
<meta name="author" content="François Brucker" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Support de cours/td d’informatique à l’école centrale marseille." />
<meta property="og:description" content="Support de cours/td d’informatique à l’école centrale marseille." />
<link rel="canonical" href="/cours_informatique/cours/graphes/flots.html" />
<meta property="og:url" content="/cours_informatique/cours/graphes/flots.html" />
<meta property="og:site_name" content="cours d’informatique" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Théorie des graphes : flots" />
<script type="application/ld+json">
{"headline":"Théorie des graphes : flots","description":"Support de cours/td d’informatique à l’école centrale marseille.","@type":"WebPage","url":"/cours_informatique/cours/graphes/flots.html","author":{"@type":"Person","name":"François Brucker"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css"><link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique" /><!-- Mathjax Support -->
  <script>
    MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
      },
      svg: {
        fontCache: 'global'
      }
    };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
</head>

<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/cours_informatique/">cours d&#39;informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Théorie des graphes : flots</h1></p>Auteur : <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">François Brucker</span></span></p>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/graphes/">graphes</a> / <a href="/cours_informatique/cours/graphes/flots.html">flots</a></p>
</blockquote>

<p>Modéliser des problèmes de robinets par la théorie des graphes.</p>

<blockquote>
  <p>Les exemples de ce cours ont été pris dans l’excellent livre <a href="https://www.eyrolles.com/Informatique/Livre/methodes-d-optimisation-combinatoire-9782225853074/">méthodes d’optimisation combinatoire</a> de Charon, Germa et Hudry qui a appris la théorie des graphes et l’optimisation combinatoire à de nombreux étudiants des années 2000 (voir même un peu avant).</p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<p>On considère un réseau de canalisations, chaque tuyau le constituant ayant une capacité (le diamètre) particulière. Dans ce réseau on considère deux nœuds d’intérêt :</p>

<ul>
  <li>la source : le robinet</li>
  <li>le puits : l’endroit on l’on veut récupérer l’eau.</li>
</ul>

<p>Lorsque l’on ouvre le robinet, on peut mesurer le débit (en $m^3/s$) au puits.</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-def-1.png" alt="un flot" style="margin: auto;display: block;" /></p>

<p>Quel est le flot maximum (débit maximum) que l’on peut avoir si on ouvre à fond le robinet ?</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-def-max.png" alt="un flot maximum" style="margin: auto;display: block;" /></p>

<blockquote>
  <p>Remarquez bien qu’une fois le flot maximum atteint, il ne sert rien d’ouvrir plus le robinet.</p>
</blockquote>

<p>Où est le goulot d’étranglement du réseau ?</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-def-max-goulot.png" alt="un flot maximum" style="margin: auto;display: block;" /></p>

<blockquote>
  <p>Notez que le goulot d’étranglement est le flot maximum.</p>
</blockquote>

<p>C’est pour résoudre ces problèmes d’importance capitale sans avoir besoin de se mouiller que nous allons <a href="https://fr.wikipedia.org/wiki/Probl%C3%A8me_de_flot_maximum">utiliser la théorie des graphes</a>. On verra aussi quelques cas d’applications où les flot apparaissent alors qu’on ne les attendez pas.</p>

<h2 id="définitions">définitions</h2>

<p>Un <strong>réseau</strong> est un graphe (simple) orienté $G=(V, E)$ avec :</p>

<ul>
  <li>une <strong>capacité</strong> $c : E \rightarrow \mathbb{R}^{+*}$ (réels strictement positifs)</li>
  <li>deux sommets spéciaux nommées <strong>source</strong> (noté $s$) et <strong>puits</strong> (noté $p$).</li>
</ul>

<p>exemple de réseau :</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-ex-1.png" alt="réseau" style="margin: auto;display: block;" /></p>

<blockquote>
  <p>Notez que si on veut une capacité nulle, il suffit de supprimer l’arc</p>
</blockquote>

<p>Un <strong>flot</strong> dans un réseau donné est une application $f E \rightarrow \mathbb{R}^{+}$ telle que :</p>

<ul>
  <li>$0 \leq f(u) \leq c(u)$ pour tout arc $u \in E$</li>
  <li>pour tout sommet $x$ différent de $s$ et $p$, il y a <strong>conservation du flot</strong>, c’est à dire que le flot entrant est égal au flot sortant : $\sum_{y \in N^-(x)} f(yx) = \sum_{y \in N^+(x)} f(xy)$.</li>
</ul>

<p>On dit que pour un arc donné $u$ son <strong>flux</strong> est $f(u)$.</p>

<p>Exemple de flot (nombres en bleu) :</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-ex-2.png" alt="réseau" style="margin: auto;display: block;" /></p>

<blockquote>
  <p>On peut d’ores et déjà noter qu’il existe toujours un flot dans n’importe quel réseau, le flot nul qui vaut $0$ pour tout arc.</p>
</blockquote>

<p>Une <strong>coupe</strong> est déterminée à partir d’un ensemble $S \subseteq V$ contenant $s$ et pas $p$. En notant $\overline{S} = V \backslash S$ le complémentaire de $S$, une coupe, notée $(S, \overline{S})$  est l’ensemble des arcs ayant leurs origines dans $S$ et leurs extrémités dans $\overline{S}$.</p>

<blockquote>
  <p>Notez bien que $S$ n’est pas forcément connexe dans $G$.</p>
</blockquote>

<p>Exemples de coupes pour notre réseau :</p>

<ul>
  <li>$({s}, \bar{{s}})$ qui contient les arcs : $sa$ et $sb$</li>
  <li>$(V \backslash \{p\}, \overline{V \backslash \{p\}})$ qui contient les arcs $dp$ et $ep$</li>
  <li>$(\{s, d\}, \overline{\{s, d\}})$ qui contient les arcs : $sa$, $sb$, $dp$ et $de$</li>
</ul>

<p>La <strong>capacité d’une coupe</strong> $c(S, \overline{S})$ est la somme des capacités des arcs de la coupe :</p>

\[c(S, \overline{S}) = \sum_{xy \in (S, \overline{S})}c(xy)\]

<p>On note également pour une coupe $(S, \overline{S})$ les valeurs suivantes :</p>

<ul>
  <li>$f(S, \overline{S})$ comme étant la somme des flux des arcs ayant pour origine $S$ et pour extrémité $\overline{S}$ (les éléments de la coupe)</li>
  <li>$f(\overline{S}, S)$ comme étant la somme des flux des arcs ayant pour extrémité $S$ et pour origine $\overline{S}$</li>
</ul>

<p>Exemples :</p>

<ul>
  <li>$f(\{s\}, \overline{\{s\}}) = 1 + 0 = 1$</li>
  <li>$f(\{p\}, V \backslash \{p\}) = 1 + 0 = 1$</li>
  <li>$f(\{s, d\}, \overline{\{s, d\}}) = 1 + 0 + 1 + 0 = 2$</li>
</ul>

<h2 id="valeur-dun-flot">valeur d’un flot</h2>

<p>On va prouver que pour toute coupe $(\overline{S}, S)$, quantité suivant est contante :</p>

\[f(S, \overline{S}) - f(\overline{S}, S) = \mbox{val}(f)\]

<p>Pour tout sommet $x$ de $S$ différent de $s$, on a conservation du flot donc :</p>

\[\sum_{x \in S} (\sum_{xy \in E} f(xy) - \sum_{yx \in E} f(yx)) = \sum_{sy \in E} f(sy) - \sum_{ys \in E} f(ys) = f(\\{s\\}, \overline{\\{s\\}}) - f(\overline{\\{s\\}}, \\{s\\})\]

<p>De plus, les arcs internes à $S$ sont comptés deux fois une fois pour l’origine de façon positive et une fois pour l’extrémité de façon négative. Les seuls arcs qui ne sont comptés qu’une fois sont ceux qui rentre ou qui sortent de $S$. de là :</p>

\[\sum_{x \in S} (\sum_{xy \in E} f(xy) - \sum_{yx \in E} f(yx)) = f(S, \overline{S}) - f(\overline{S}, S)\]

<p>On en conclut donc que $f(S, \overline{S}) - f(\overline{S}, S)$ est une constante pour n’importe quelle coupe et vaut :</p>

\[\mbox{val}(f) = \sum_{sx \in E}f(sx) - \sum_{xs \in E}f(xs) = \sum_{xp \in E}f(xp) - \sum_{px \in E}f(px)\]

<blockquote>
  <p>Ce qui rentre dans le réseau en ressort</p>
</blockquote>

<p>Pour notre exemple, on a donc une valeur de flot de $\mbox{val}(f) = 1$</p>

<h2 id="flot-maximum">flot maximum</h2>

<p>On a clairement que :</p>

<ul>
  <li>$\mbox{val}(f) \leq c(S, \overline{S})$ pour toute coupe du réseau.</li>
  <li>si $\mbox{val}(f) = c(S^<em>, \overline{S^</em>})$ alors :
    <ul>
      <li>$S^*$ est la coupe réalisant le minimum de c(S, \overline{S})$ pour toute coupe $S$</li>
      <li>$\mbox{val}(f)$ est maximum</li>
      <li>pour tout arc $u$ partant de $S^<em>$ pour finir en $\overline{S^</em>}$, $f(u) = c(u)$</li>
      <li>pour tout arc $u$ partant de $\overline{S^<em>}$ pour finir en $S^</em>$, $f(u) = 0$</li>
    </ul>
  </li>
</ul>

<p>La réciproque est également vraie et nous allons le prouver. On va prouver :</p>

<ol>
  <li>que le flot maximum existe</li>
  <li>que le flot maximum est égale à la coupe minium.</li>
</ol>

<h3 id="existence-du-flot-maximum">existence du flot maximum</h3>

<p>Commençons pas montrer que le flot maximum est atteint.</p>

<p>Soient $G= (V, E)$ et $c$ un réseau donné. Une valuation $f$ des arcs de $G$ peut être vue comme  un vecteur de l’espace vectoriel $\mathbb{R}^m$ où $m = \vert E \vert$ que l’on munie d’une norme $\vert\vert . \vert\vert$ . Si cette valuation n’est pas un flot, alors :</p>

<ul>
  <li>soit une des coordonnées est strictement négative : $f(u) &lt; 0$,</li>
  <li>soit la conservation du flot n’est pas respectée pour au moins un sommet de $G$ : la valeur absolue de la différence vaut $d &gt; 0$.</li>
</ul>

<p>Il existe alors $\epsilon &gt; 0$ tel que toute valuation $f’$ avec $\vert\vert f - f’\vert\vert \leq \epsilon$ n’est pas non plus un flot (on prend $\epsilon$ plus petit que $f(u) &gt; 0$ et $d &gt; 0$) : l’espace de $\mathbb{R}^m$ où $f$ n’est pas un flot est un ouvert. Donc son complémentaire, l’espace de $\mathbb{R}^m$ où $f$ est un flot, est fermé. Ce fermé est de plus borné puisque les flux ne peuvent dépasser les capacités.</p>

<p>Un fermé borné atteignant ses bornes, on en déduit que $\mbox{val}(f)$ va atteindre ses bornes : il existe bien un flot maximum.</p>

<h3 id="chaine-augmentante">chaine augmentante</h3>

<p>Pour montrer que le flot maximum est égal à la coupe minimum on va introduire la notion de chaine augmentante.</p>

<p>Une <strong>chaine</strong> $c_0 \dots c_k$ dans un graphe orienté $G=(V, E)$ est une suite de sommets tels que pour tout $0 \leq i &lt; k$, soit $c_ic_{i+1}$ soit $c_{i+1}c_i$ soit un arc du graphe.</p>

<p>On suppose que l’on ait un réseau $G=(V, E)$ avec ses capacités $c$ et un flot $f$. Soit alors $C = c_0\dots c_k$ une chaine de $s$ à $p$ dans $G$.</p>

<p>Par exemple :</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-chaine-1.png" alt="une chaine" style="margin: auto;display: block;" /></p>

<p>Cette chaine a 3 arcs qui vont dans le sens de $s$ à $p$ ($sa$, $ce$ et $ep$) et un arc qui va de $p$ vers $s$ ($ca$).</p>

<p>Si l’on peut augmenter la valeurs des arcs allant de $s$ à $p$ et diminuer la valeur des flots allant de $p$ à $s$ on augmentera le flot. Pour garder la conservation des flots, il faut augmenter et diminuer de la même valeur absolue.</p>

<p>Notons alors $C^+$ (respectivement $C^-$) l’ensemble des arcs de la chaine allant de $s$ à $p$ (respectivement de $p$ à $s$) et calculons :</p>

<ul>
  <li>$\alpha^+ = \min \{ c(u) - f(u) \vert u \in C^+ \}$</li>
  <li>$\alpha^- = \min \{ f(u) \vert u \in C^- \}$</li>
  <li>$\alpha = \min \{\alpha^+, \alpha^-\}$</li>
</ul>

<p>Si $\alpha &gt; 0$, $C$ est dit être une <strong>chaine augmentante</strong> car on peut augmenter le flot des arcs de $C^+$ de $\alpha$ et diminuer les arcs de $C^-$ de $\alpha$ ce qui garde la conservation du flot et augmente $\mbox{val}(f)$ de $\alpha &gt; 0$.</p>

<p>Dans l’exemple on a : $\alpha^+ = \alpha^- = 1$ : notre flot n’est pas maximum</p>

<blockquote class="note">
  <p>On en conclut que s’il existe une chaine augmentante de $s$ à $p$ alors $\mbox{val}(f)$ n’est pas maximum.</p>
</blockquote>

<p>Réciproquement, supposons qu’il n’existe pas de chaines augmentante de $s$ à $p$. Soit alors $x$ l’ensemble $S’$ des sommets tel qu’il existe une chaine augmentante de $s$ à $x$. L’ensemble $S = S’ \cup \{ s\}$ est alors une coupe de notre réseau et :</p>

<ul>
  <li>pour tout arc $xy$ commençant dans $S$ et finissant dans $\overline{S}$ on a $f(xy) = c(xy)$ sinon il existerait une chaine augmentante de $s$ à $x$ et de $x$ à $y$, donc une chaine augmentante entre $s$ et $y$</li>
  <li>pour tout arc $xy$ commençant dans $\overline{S}$ et finissant dans $S$ on a $f(xy) &gt; 0$ sinon il existerait une chaine augmentante de $s$ à $y$ et de $y$ à $x$, donc une chaine augmentante entre $s$ et $y$</li>
</ul>

<p>On en déduit que pour cette coupe : $c(S, \overline{S}) = f(S, \overline{S}) - f(\overline{S}, S)$, la valeur de notre flot est maximum !</p>

<p>On a donc qu’il existe une chaine augmentante de $s$ à $p$ si et seulement si $\mbox{val}(f)$ n’est pas maximum.</p>

<h3 id="théorème-des-flots">théorème des flots</h3>

<p>Finalement :</p>

<ul>
  <li>il existe une chaine augmentante de $s$ à $p$ si et seulement si $\mbox{val}(f)$ n’est pas maximum.</li>
  <li>comme le flot maximum est atteint sa valeur ne peut être que la valeur de la coupe minimum puisque l’ensemble des sommets admettant une chaine augmentante forme alors une coupe.</li>
</ul>

<blockquote>
  <p>La coupe minimum est le goulot d’étranglement du réseau.</p>
</blockquote>

<h2 id="algorithmes">algorithmes</h2>

<p>Il existe de nombreux algorithme pour résoudre le problème du flot maximum. Nos allons ici juste montrer un exemple en suivant l’idée des chaines augmentantes.</p>

<p>L’idée est d’itérativement :</p>

<ol>
  <li>trouver une chaine augmentante</li>
  <li>maximiser sa valeur en l’augmentant au maximum sa valeur de flot</li>
</ol>

<p>Lorsque l’on ne trouve plus de chaine augmentante, le flot est maximum. L’initialisation est toujours possible puisque le flot nul est un flot possible.</p>

<p>Si l’on suppose que nos capacités sont entières on pourra augmenter au minimum de 1 unité toutes nos chaines augmentantes à chaque fois, donc l’algorithme va converger en :</p>

<ul>
  <li>au maximum $C(S, \overline{S})$ itérations où $S$ est une coupe</li>
  <li>au maximum $\max \mbox{val}(f)$ itérations où $\max \mbox{val}(f)$ est la valeur de flot maximum</li>
  <li>au maximum $\vert V \vert c_\max$ itérations où $c_\max$ est la capacité maximale (pour montrer ça on considère la coupe $(\{s\}, V \backslash \{s \}))$</li>
</ul>

<h3 id="ford-et-fulkerson">Ford et Fulkerson</h3>

<p>L’algorithme de Ford et Fulkerson (1955) est une implémentation de ce principe. Il cherche une chaine augmentante puis la résous. La procédure de recherche de chaine est paradigmatique des algorithme <em>marquage/ examinage</em></p>

<p>Son algorithme de recherche de chaine est le suivant :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entrée :
    * un graphe orienté G = (V, E)
    * une capacité c qui associe un réel strictement positif à toute arc de G
    * deux sommets s et p
    * un flot f admissible
Initialisation :
    * marquer s par ({}, +∞)
    * considérer tous les sommet différent d s comme non marqué
    * considérer qu'aucun sommet n'est examiné
Algorithme :
    * tant que p est non marqué et qu'il existe un sommet marqué et non examiné:
        * soit x marqué et ⍺ la valeur absolue du second paramètre de sa marque
        * pour voisin y de x tel que xy est un arc et y non marqué:
            * si c(xy) &gt; f(xy) alors :
                * β = min(⍺, c(xy) - f(xy))
                * marquer y par (x, +β)
        * pour voisin y de x tel que yx est un arc et y non marqué:
            * si f(yx) &gt; 0 alors :
                * β = min(⍺, f(yx))
                * marquer y par (x, -β)
        * considérer x comme examiné
Retour :
    * les marques des sommets
</code></pre></div></div>

<p>Si le sommet p est marqué à la fin de l’algorithme, il existe une chaine augmentante que l’on trouve par l’algorithme suivant :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entrée : 
    * s et p
    * les marques de l'algorithme de marquage
Initialisation :
    * C = [p]
Algorithme :
    * x = p
    * tant que x est différent de s:
        * soit y la première marque de x
        * x = y
        * ajouter x au début de C
Retour : 
    * C
</code></pre></div></div>

<p>Pour se convaincre que l’algorithme trouve bien une chaine augmentante si elle existe, il suffit de remarquer qu’un sommet est marqué que si et seulement si il existe une chaine augmentante allant de s à lui. Ceci fonctionne car s’il existe une chaine augmentante allant de $s$ à $x$ et une chaine augmentante allant de $x$ à $y$ alors il existe une chaine augmentante allant de $s$ à $y$.</p>

<p>De là, si p n’est pas marqué, il n’existe pas de chaine augmentante, et le flot est maximum. Sinon, on peut augmenter le flot avec l’algorithme suivant et recommencer</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Entrée : 
    * une chaine augmentante C
    * les marques 
Algorithme
    * soit ⍺ la valeur absolue de la seconde marque de p
    * C=c0 ... ck la chaine augmentante de s à p que l'on retrouve en remontant les premières marques jusqu'à s
    * pour chaque i allant de 1 à k:
        * si le premir paramètre de de la marque de ci est positif alors :
            * f(c(i-1)ci) += ⍺
        * sinon :
            * f(c(i-1)ci) -= ⍺
Retour :
    * f
</code></pre></div></div>

<p>La complexité de tout cet algorithme est proportionnelle au nombre d’arête du graphe (il suffit de stocker les éléments marqué dans une liste que l’on prend petit à petit). Il est donc optimal pour trouver et traiter une chaine augmentante.</p>

<h3 id="exemple">exemple</h3>

<p>On va utiliser notre graphe qui possède déjà un flot :</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-ex-2.png" alt="réseau" style="margin: auto;display: block;" /></p>

<h4 id="algorithme-de-marquage">algorithme de marquage</h4>

<p>Les graphes ci-dessous montre les différentes étapes de l’algorithme de marquage (en orange les résultats de l’étape courante).</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-ff-1.png" alt="marquage" style="margin: auto;display: block;" /></p>

<p>On s’arrête une fois le puits marqué.</p>

<h4 id="mise-à-jour">mise à jour</h4>

<p>La chaine augmentante trouvée est :</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-chaine-1.png" alt="une chaine" style="margin: auto;display: block;" /></p>

<p>On peut augmenter de +1 (le premier paramètre de la marque du puits) :</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-ff-2.png" alt="marquage" style="margin: auto;display: block;" /></p>

<p>Ce qui donne le flot suivant :</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-ff-3.png" alt="flot trouvé" style="margin: auto;display: block;" /></p>

<p>On relance l’algorithme de Ford et Fulkerson et on obtient (par exemple), la chaine augmentante suivante :</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-ff-4.png" alt="re marquage" style="margin: auto;display: block;" /></p>

<p>Et le flot :</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-ff-5.png" alt="flot maximum" style="margin: auto;display: block;" /></p>

<p>Ce flot est maximum puisque l’on sature les arcs arrivant en p.</p>

<p>Montrons le en exécutant l’algorithme de Ford et Fulkerson pour trouver la coupe minimum (en magenta un ordre possible d’examinage des sommets):</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-ff-6.png" alt="coupe min" style="margin: auto;display: block;" /></p>

<p>La coupe minimum est en orange.</p>

<h3 id="autres-algorithmes">Autres algorithmes</h3>

<p>La complexité de l’algorithme de Ford et Fulkerson n’est pas polunomiale (elle dépent des valuations), mais il existe des algorithmes polynomiaux, variations de l’algorithme de Ford et Fulkerson pour résoudre notre problème de flot. Vous pouvez voir la page <a href="https://fr.wikipedia.org/wiki/Probl%C3%A8me_de_flot_maximum">wikipedia</a> pour quelques exemples, dont l’algorithmede <a href="https://fr.wikipedia.org/wiki/Algorithme_de_Dinic">Dinic</a> ou d’<a href="https://fr.wikipedia.org/wiki/Algorithme_d%27Edmonds-Karp">Edmonds Karp</a>.</p>

<h2 id="flot-maximum-à-cout-minimum">flot maximum à cout minimum</h2>

<p>Si les arcs ont un coût de passage $v(u)$, le cout du flot est : $\sum_{u \in E} v(u)f(u)$</p>

<p>On peut alors chercher à trouver un flot maximum à coût minimum. Ceci est possible pour les graphes antisymétriques (c’est à dire que si l’arête $xy$ existe, l’arête $yx$ n’existe pas) en utilisant les graphes d’écart pour trouver une chaine augmentante.</p>

<blockquote>
  <p>La complexité est plus importante qu’avec l’algorithme de Ford et Fulkerson car il faut utiliser Dijkstra pour trouver un chemin.</p>
</blockquote>

<h3 id="graphe-décart">graphe d’écart</h3>

<p>Si le graphe du réseau est antisymétrique (c’est à dire que si l’arête $xy$ existe, l’arête $yx$ n’existe pas) alors on peut utiliser un graphe auxiliaire, appelé <strong>graphe d’écart</strong> pour trouver une chaine augmentante.</p>

<p>Soit $G=(V, E)$ un graphe orienté anti-symétrique, une capacité $x$ et un flot $f$. on appelle graphe d’écart le graphe orienté $G_f = (V, E’)$ tel que pour toute arc $xy$ de $G$ :</p>

<ul>
  <li>si $f(xy) &lt; c(xy)$ alors on crée un arc $xy$ dans $G_f$ avec une valuation de $v(xy)$</li>
  <li>si $f(xy) &gt; 0$ alors on crée un arc $yx$ dans $G_f$ avec une valuation de $v(xy)$</li>
</ul>

<p>Il est alors clair qu’il n’existe un chemin allant de $s$ à $p$ dans $G_f$ que si et seulement si il existe une chaine augmentante pour le réseau initial.</p>

<h3 id="algorithme">algorithme</h3>

<p>On procède comme avant, mais la chaine augmentante cherchée correspondra à un chemin de longueur minimum dans le graphe d’écart, en valuant ses arcs avec le coût de passage de chaque arc.</p>

<p>On peut utiliser l’<a href="https://fr.wikipedia.org/wiki/Algorithme_de_Dijkstra">algorithme de Dijkstra</a> par exemple pour trouver ce chemin.</p>

<h3 id="exemple-1">exemple</h3>

<p>Reprenons notre exemple fétiche (On ne mettra pas de valuation sur le graphe) :</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-ex-2.png" alt="réseau" style="margin: auto;display: block;" /></p>

<p>Le graphe d’écart associé est alors (avec en orange les arcs inverses) :</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-ecart-1.png" alt="graphe d'écart 1" style="margin: auto;display: block;" /></p>

<p>Ce qui donne comme chemin possible :</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-ecart-2.png" alt="graphe d'écart 2" style="margin: auto;display: block;" /></p>

<p>Et après mise à jour du flot :</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-ff-3.png" alt="flot trouvé" style="margin: auto;display: block;" /></p>

<p>Le nouveau graphe d’écart (et un chemin possible) devient alors :</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-ecart-3.png" alt="graphe d'écart 2" style="margin: auto;display: block;" /></p>

<p>D’où le flot :</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-ff-5.png" alt="flot maximum" style="margin: auto;display: block;" /></p>

<p>Et le graphe d’écart qui ne permet plus de trouver un chemin entre $s$ et $p$ :</p>

<p><img src="/cours_informatique/assets/cours/graphes/flot-ecart-4.png" alt="graphe d'écart 3" style="margin: auto;display: block;" /></p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d&#39;informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d&#39;informatique</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d&#39;informatique à l&#39;école centrale marseille.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
