<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>GraphQL | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="GraphQL">
<meta name="author" content="Adèle Bourgeix">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<meta property="og:description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<link rel="canonical" href="/cours_informatique/cours/dfs/graphql.html">
<meta property="og:url" content="/cours_informatique/cours/dfs/graphql.html">
<meta property="og:site_name" content="cours d’informatique">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="GraphQL">
<script type="application/ld+json">
{"description":"Support de cours/td d’informatique à l’école centrale marseille.","@type":"WebPage","url":"/cours_informatique/cours/dfs/graphql.html","headline":"GraphQL","author":{"@type":"Person","name":"Adèle Bourgeix"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">GraphQL</h1>Auteurs :
      <ul>
      
        <li><span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Adèle Bourgeix</span></span></li>
      
        <li><span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Fanis Michalakis</span></span></li>
      
      </ul>
  </header>

  <div class="post-content">
    <h2 id="graphql-quest-ce-que-cest-">GraphQL qu’est ce que c’est ?</h2>
<p>GraphQL c’est en fait un langage de requête pour API ainsi qu’un environnement pour exécuter ces requêtes.</p>

<blockquote>
  <p><strong>Nota Bene</strong>: Une API c’est quoi ?  Une API permet à ton application de communiquer avec d’autres produits et services sans avoir exactement ça fonctionne ces autres produits ou services.</p>
</blockquote>

<p>Avant, on dessinait les API avec une architecture REST. Avec Rest, chaque ressource s’identifie avec une adresse URL à laquelle on fait appel par le protocole HTTP. 
Par exemple si je veux accéder au livre “Les Raisins de la Colère” il est très probable que le chemin associé soit de la forme mon-application/livres/les-raisins-de-la-colère. Quand un client fait une requête en utilisant cette URL, le serveur récupère cette URL, identifie la nature et les détails de la requête, récupère les données et les renvoie au client. 
GraphQL ça fonctionne un peu pareil, la différence c’est dans la manière dont sont récupérées les données!</p>

<h3 id="mais-donc-pourquoi-on-utilise-graphql-dans-ce-cas-">Mais donc pourquoi on utilise GraphQL dans ce cas ?</h3>

<p>Encore une fois, les développeurs utilisent maintenant GraphQL dans une optique d’optimisation. Il est maintenant vraiment important que le temps de réponse des applications soit le plus court possible : un utilisateur qui ne peut pas acheter rapidement le produit qu’il veut va rapidement se lasser et ça peut faire perdre beaucoup beaucoup d’argent à une entreprise.</p>

<p>Voilà pourquoi GraphQL c’est super top : GraphQL récupère exactement les données qu’on lui demande, ni plus ni moins. Par exemple, si on souhaite récupérer le titre d’un livre, on récupère seulement le titre et pas l’auteur, l’éditeur, l’identifiant, l’année de parution ou n’importe quel autre renseignement que l’on n’avait pas demandé. Ca peut paraître anodin mais si cela concerne un fichier JSON de plusieurs dizaines de paramètres et qu’on multiplie les requêtes, ça peut vite devenir long de récupérer trop de données inutiles.</p>

<blockquote>
  <p><strong>Nota Bene :</strong> et d’ailleurs une requête c’est quoi ? 
Le protocole HTTP permet la transmission d’informations au serveur via différentes requêtes dont les deux plus connues sont GET et POST. 
Pour récupérer des données, on utilise en général la requête GET qui est une requête de consultation. 
Il est parfois nécessaire de modifier les données du serveur. C’est notamment ce qui se passe lorsqu’on utilise un formulaire HTML (par exemple pour poster un billet de blog ou passer une commande). Dans ce cas, il est nécessaire d’utiliser une requête POST. Dans une requête POST, l’adresse où vont être envoyées les données (généralement celle du serveur) est précisée dans l’attribut action de la balise form.</p>
</blockquote>

<blockquote>
  <p><strong>Nota Bene:</strong> Il est aussi possible d’envoyer des données au serveur via une requête GET, la grande différence est qu’avec POST, les données sont envoyées de manière confidentielle. On s’explique: les paramètres envoyés au serveur avec une méthode GET sont directement ajoutés à l’URL ce qui fait que tout le monde peut y avoir accès, pas très safe !</p>
</blockquote>

<p>Une autre raison pour utiliser GraphQL c’est qu’on permet au client d’encapsuler les requêtes. On s’explique : si on récupère tous les livres de Steinbeck, on peut lui demander en même temps de récupérer leur titre et leur année de parution. Pas besoin de refaire une seconde requête pour chaque livre comme avec REST!
Donc en fait, GraphQL nous permet de récupérer des données sous forme d’un graphe (d’ou ce fameux nom!).</p>

<h2 id="du-côté-serveur--schémas-et-types">Du côté serveur : schémas et types</h2>

<p>Donc maintenant, comment ça marche ? Avant de pouvoir permettre au client de faire des requêtes, il faut définir l’environnement GraphQL du côté serveur. C’est à dire définir la structure des données qui peuvent être récupérées mais aussi les “opérations” qui vont pouvoir être récupérées par le client.</p>

<h3 id="définir-les-schémas">Définir les schémas</h3>

<p>Avec GraphQL, un schéma doit être écrit pour chaque entité de notre base de données. Dans le cadre d’une bibliothèque, on aura par exemple un schéma pour les livres et un autre pour les auteurs.</p>

<blockquote>
  <p><strong>Nota Bene</strong>: l’environnement GraphQL peut se configurer dans plusieurs syntaxes de languages de programmation mais par la suite, les exemples seront écrit en JavaScript. Les module qui est utilisé est <strong>graphql</strong>. Il faut importer certaines méthodes du module:</p>
  <div class="language-plaintext highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>const graphql = require('graphql');
const {
    GraphQLObjectType,
    GraphQLString,
    GraphQLSchema,
    GraphQLID,
    GraphQLInt,
    GraphQLNonNull,
    GraphQLList
} = graphql;
</code></pre></div>  </div>
</blockquote>

<p>Voici comment pourrait s’écrire le schéma associés à nos livres:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const BookType = new GraphQLObjectType({
    name: 'Book',
    fields: ( ) =&gt; ({
        id: { type: GraphQLID },
        name: { type: GraphQLString },
        genre: { type: GraphQLString },
      })
});

</code></pre></div></div>

<h4 id="champs-et-types-de-champs">Champs et types de champs</h4>

<p>Chaque schéma contient des champs qui sont les attributs de nos objets. Chaque champ possède un type qui est soit un type défini par GraphQL: une chaîne de caractères, un nombre, un identifiant unique (ce qui est bien pratique parfois!), etc mais peut aussi être du type défini par un autre schéma.</p>

<p>On peut aussi que le champ ne peut être nul avec un <strong>!</strong> ou que c’est une liste avec des <strong>[]</strong>.</p>

<p>Définissons par exemple le schéma de nos auteurs:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const AuthorType = new GraphQLObjectType({
    name: 'Author',
    fields: ( ) =&gt; ({
        id: { type: GraphQLID },
        name: { type: GraphQLString },
        age: { type: GraphQLInt },
        books: {
            type: new GraphQLList(BookType),
            resolve(parent, args){
                return Book.find({authorId: parent.id})
            }
        }
    })
});
</code></pre></div></div>

<p>Notre auteur, possède un identifiant, un nom, un âge mais aussi une liste des livres qu’il a écrits. Pour trouver ces livres on a besoin d’une méthode qui s’appelle <strong>resolve</strong> et qui reçoit notamment un parent (qui est en fait ici l’auteur lui-même).</p>

<p>On peut donc compléter le schéma pour nos livres :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const BookType = new GraphQLObjectType({
    name: 'Book',
    fields: ( ) =&gt; ({
        id: { type: GraphQLID },
        name: { type: GraphQLString },
        genre: { type: GraphQLString },
        author: {
            type: AuthorType,
            resolve(parent, args){
                return Author.findById(parent.authorId)
            }
        }
    })
});
</code></pre></div></div>

<h4 id="et-les-opérations-dans-tout-ça-">Et les opérations dans tout ça ?</h4>

<p>Nous avons donc fini de définir les modèles sur lesquels le client va pouvoir effectuer des opérations. D’ailleurs quelles sont ces opérations ? 
Les opérations peuvent être de deux types :</p>
<ol>
  <li>Des <em>queries</em>: le client récupère des données qu’il a demandé.</li>
  <li>Des <em>mutations</em>: le client décide de faire une mutation sur la base de données (ajouter une instance, modifier une instance, supprimer une instance, etc)</li>
</ol>

<p>Chaque environnement GraphQL reçoit un objet contenant les queries et peut recevoir des mutations. En fait, ces objets permettent de définir le point d’entrée de notre graphe, c’est à dire comment vont pouvoir être récupérées les données par le client.</p>

<h5 id="les-queries">Les queries</h5>

<p>Pour définir les queries qui peuvent être performées :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const RootQuery = new GraphQLObjectType({
    name: 'RootQueryType',
    fields: {
        book: {
            type: BookType,
            args: { id: { type: GraphQLID } },
            resolve(parent, args){
                return Book.findById(args.id)
            }
        },
        author: {
            type: AuthorType,
            args: { id: { type: GraphQLID } },
            resolve(parent, args){
                return Author.findById(args.id);
            }
        },
        books: {
            type: new GraphQLList(BookType),
            resolve(parent, args){
                return Book.find();
            }
        },
        authors: {
            type: new GraphQLList(AuthorType),
            resolve(parent, args){
                return Author.find();
            }
        }
    }
});

</code></pre></div></div>

<p>Ici on permet au client de récupérer: tous les livres, tous les auteurs, un livre identifié par un numéro unique ou un auteur identifié par un numéro unique.</p>

<p>Chaque query possède :</p>
<ul>
  <li>un nom</li>
  <li>le type de l’objet ou des objets retournés</li>
  <li>une méthode pour récupérer les objets grâce au parents et aux arguments passés (dans le cas de la rehcerche du livre, l’argument c’est l’identifiant unique du livre).</li>
</ul>

<h5 id="les-mutations">Les mutations</h5>

<p>Pour définir les mutations possibles, c’est un peu pareil, il suffit juste de définir l’objet Mutation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const Mutation = new GraphQLObjectType({
    name: 'Mutation',
    fields: {
        addAuthor: {
            type: AuthorType,
            args: {
                name: { type: new GraphQLNonNull(GraphQLString) },
                age: { type: new GraphQLNonNull(GraphQLInt) }
            },
            resolve(parent, args){
                let author = new Author({
                    name: args.name,
                    age: args.age
                });
                return author.save();
            }
        },
        addBook: {
            type: BookType,
            args: {
                name: { type: GraphQLNonNull(GraphQLString) },
                genre: { type: GraphQLNonNull(GraphQLString) },
                authorId: { type: new GraphQLNonNull(GraphQLID) }
            },
            resolve(parent, args){
                let book = new Book({
                    name: args.name,
                    genre: args.genre,
                    authorId: args.authorId
                });
                return book.save();
            }
        }
    }
});
</code></pre></div></div>

<p>Ici, on permet au client d’ajouter des livres et auteurs à notre base de donnée.</p>

<p>Pour définir une mutation possible, on précise :</p>
<ul>
  <li>un nom</li>
  <li>un type pour les objets retournés</li>
  <li>un liste d’arguments ainsi que leur type</li>
  <li>une méthode pour la mutation qui est agrémentée du parent et des arguments nécessaires.</li>
</ul>

<blockquote>
  <p><strong>Nota Bene</strong>: il est important de ne pas oublier de sauver l’instance dans la base de données après la mutation.</p>
</blockquote>

<p>Finalement, on définit le service GraohQL avec les mutations et queries définies:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>module.exports = new GraphQLSchema({
    query: RootQuery,
    mutation: Mutation
});
</code></pre></div></div>

<h2 id="du-côté-client-les-opérations">Du côté client: les opérations</h2>

<p>Maintenant que les schémas et opérations sont définies du côté du serveur, on peut commencer à formuler des requêtes du côté client.</p>

<p>Pour ça, il faut définir les différentes requêtes dans un fichier à part de l’application client.</p>

<p>Les différentes requêtes s’écrivent entre  <code class="language-plaintext highlighter-rouge">``</code>  et se passent comme paramètre à graphql.</p>

<h3 id="queries">Queries</h3>

<p>Pour récupérer tous les livres de l’application avec leur nom et leur identifiant, il suffit d’écrire :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const getBooksQuery=gql`
{
    books {
        name
        id
    }
}
`
</code></pre></div></div>

<p>On peut aussi récupérer des informations sur un livre en particulier et en même temps, des informations sur son auteur :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const getBookQuery=gql`
query($id:String!){
    book(id:$id){
    id
    name
    genre
    author{
        id
        name
        age
        books {
            name
            id
        }
        }
    }

}
`
</code></pre></div></div>

<blockquote>
  <p><strong>Nota Bene</strong> : il faut donc préciser les paramètres de la query ainsi que son type !</p>
</blockquote>

<h3 id="mutations">Mutations</h3>

<p>Pour préciser une mutation, c’est un peu pareil. On précise aussi les attributs en arguments.  Par exemple:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const addBookMutation=gql`
mutation($name: String!, $genre: String!, $authorId:ID!){
    addBook(name:$name,genre:$genre,authorId:$authorId){
        name
        id
    
    }
}
`
</code></pre></div></div>
<h3 id="validations">Validations</h3>

<p>En revanche,il existe quelques règles à respecter pour que les requêtes soient validées par GraphQL.</p>

<p>GraphQL termine de parcourir le graphe de requête lorsqu’il rencontre un scalaire (chaîne de caractères, entier, flottant), il faut ddonc préciser les champs que l’on souhaite recevoir. Si un des champs est du type d’une autre entité qui a été définie, il faut continuer à demander des attributs jusqu’a n’avoir que sur les feuilles du graphe, des sclaires.</p>

<p>On ne peut bien sûr que demander des champs du modèle concerné.</p>

<p>Un lien utile pour utiliser GraphQL avec MongoDB : <a href="https://www.youtube.com/watch?v=Y0lDGjwRYKw&list=PL4cUxeGkcC9iK6Qhn-QLcXCXPQUov1U7f">ici</a></p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique à l'école centrale marseille.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
