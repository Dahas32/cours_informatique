<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Structure : liste | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="Structure : liste">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique de François Brucker.">
<meta property="og:description" content="Support de cours/td d’informatique de François Brucker.">
<link rel="canonical" href="/cours_informatique/cours/algorithme-code-theorie/algorithme/structure-liste.html">
<meta property="og:url" content="/cours_informatique/cours/algorithme-code-theorie/algorithme/structure-liste.html">
<meta property="og:site_name" content="cours d’informatique">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Structure : liste">
<script type="application/ld+json">
{"headline":"Structure : liste","description":"Support de cours/td d’informatique de François Brucker.","@type":"WebPage","url":"/cours_informatique/cours/algorithme-code-theorie/algorithme/structure-liste.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Structure : liste</h1>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/algorithme-code-theorie/">Algorithme, code et théorie</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/algorithme/">algorithmie</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/algorithme/structure-liste.html">structure : liste</a></p>

  <p><strong>prérequis :</strong></p>

  <ul>
    <li><a href="/cours_informatique/cours/algorithme-code-theorie/algorithme/complexite-moyenne.html">complexité en moyenne</a></li>
  </ul>

</blockquote>

<h2 id="tableau">tableau</h2>

<p>On l’a vu, pour un tableau on a les complexité suivantes :</p>

<ul>
  <li>La complexité dans le cas le pire de la création de la structure : $\mathcal{O}(1)$</li>
  <li>La complexité dans le cas le pire pour trouver l’élément d’indice $i$ : $\mathcal{O}(1)$</li>
  <li>La complexité dans le cas le pire de l’ajout d’un élément à la structure : $\mathcal{O}(1)$ en fin de structure s’il reste de la place, sinon ajout impossible. $\mathcal{O}(n - i) = \mathcal{O}(n)$ à l’emplacement $i$.</li>
  <li>La complexité dans le cas le pire de la suppression d’un élément de la structure :  Pour un tableau $\mathcal{O}(1)$ en fin de structure. $\mathcal{O}(n - i) = \mathcal{O}(n)$ à l’emplacement $i$</li>
  <li>La complexité dans le cas le pire de la suppression de la structure : $\mathcal{O}(1)$</li>
</ul>

<p>Cette structure est adaptée lorsque l’on ne doit pas supprimer/ajouter des éléments en milieu de structures. Cependant, on doit connaitre <em>a priori</em> le nombre maximum d’éléments.</p>

<h2 id="liste">liste</h2>

<p>Les listes de python se comportent de manières différentes. Tout comme les tableaux ce sont des objets pouvant contenir une succession d’autres objets auxquels on peut accéder par un *indice**, mais on peut facilement ajouter/supprimer un nombre infini d’éléments en fin de liste.</p>

<blockquote>
  <p>vous devriez déjà savoir manipuler des listes par cœur. Mais comme enseigner, c’est répéter. Je le répète.</p>
</blockquote>

<h3 id="création-dune-liste">création d’une liste</h3>

<p>Pour créer un objet de type liste ne contenant pas d’éléments on peut procéder ainsi : <code class="language-plaintext highlighter-rouge">l = []</code> ou encore comme ça <code class="language-plaintext highlighter-rouge">l = list()</code>  (on crée un objet de type liste sans éléments que l’on référence par le nom <code class="language-plaintext highlighter-rouge">l</code>) .</p>

<p>On peut également créer des listes contenant déjà des éléments.
Le programme suivant par exemple crée une liste de nom l, contenant des objets de valeurs <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">2</code>, et <code class="language-plaintext highlighter-rouge">"toto"</code>, puis l’affiche :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"toto"</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</code></pre></div></div>

<p>La liste <code class="language-plaintext highlighter-rouge">l</code> contient 3 éléments, le premier d’indice 0 est un objet de type entier de valeur 1, le second — d’indice 1 — est un objet de type entier de valeur 2 et le troisième — d’indice 2 — est un objet de type chaine de caractères contenant <em>toto</em>. Pour accéder à ces paramètres on pourra utiliser :</p>

<ul>
  <li>la fonction <code class="language-plaintext highlighter-rouge">len</code>. L’instruction <code class="language-plaintext highlighter-rouge">len(l)</code> rendra un objet de type entier contenant comme valeur la longueur de la liste, ici 3.</li>
  <li>l’opérateur de positionnement <code class="language-plaintext highlighter-rouge">[indice]</code>. <code class="language-plaintext highlighter-rouge">l[i]</code> rendra l’objet contenu à l’indice  <code class="language-plaintext highlighter-rouge">i</code> de la liste <code class="language-plaintext highlighter-rouge">l</code>. Ici les indices iront de 0 à 2 puisque la liste est de longueur 3.</li>
</ul>

<h3 id="création-dune-liste-avec-range">création d’une liste avec <code class="language-plaintext highlighter-rouge">range</code>
</h3>

<p>La fonction <code class="language-plaintext highlighter-rouge">range</code> crée un générateur (quelque chose qui produit des nombres). Elle peut s’utiliser de trois façons différentes qu’elle soit appelée avec un, deux ou trois paramètres~:</p>

<ul>
  <li>de <code class="language-plaintext highlighter-rouge">0</code> à juste avant <code class="language-plaintext highlighter-rouge">paramètre</code>. Par exemple <code class="language-plaintext highlighter-rouge">range(10)</code> rendra un générateur de la suite des 10 entiers allant de 0 à 9.</li>
  <li>de <code class="language-plaintext highlighter-rouge">premier paramètre</code> à juste avant <code class="language-plaintext highlighter-rouge">deuxième paramètre</code>. Par exemple <code class="language-plaintext highlighter-rouge">range(4, 10)</code> rendra un générateur de la suite des 6 entiers allant de 4 à 9.</li>
  <li>
<code class="language-plaintext highlighter-rouge">premier paramètre</code> à juste avant <code class="language-plaintext highlighter-rouge">deuxième paramètre</code>, avec un saut de <code class="language-plaintext highlighter-rouge">troisième paramètre</code>. Par exemple <code class="language-plaintext highlighter-rouge">range(10, -1, -1)</code> rendra un générateur de la suite 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0.</li>
</ul>

<p>Un générateur <strong>n’est pas</strong> une liste. On peut l’utiliser tel quel dans les boucles, mais si on veut créer une liste contenant la suite des nombres produits par le générateur, on le convertit en liste avec le type <code class="language-plaintext highlighter-rouge">list</code>. Ainsi <code class="language-plaintext highlighter-rouge">list(range(10))</code> crée une liste <code class="language-plaintext highlighter-rouge">[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code>.</p>

<h3 id="suppression-dun-élément-dune-liste">suppression d’un élément d’une liste</h3>

<p>On peut utiliser la commande <code class="language-plaintext highlighter-rouge">del</code> pour supprimer un indice d’une liste~: l’instruction <code class="language-plaintext highlighter-rouge">del l[1]</code> supprime de la liste de nom <code class="language-plaintext highlighter-rouge">l</code> l’indice 1. L’objet associé au nom <code class="language-plaintext highlighter-rouge">l</code> est <strong>modifié</strong>, il n’est plus que de longueur 2.</p>

<h3 id="ajout-dun-élément-dune-liste">ajout d’un élément d’une liste</h3>

<p>Nous utiliserons essentiellement deux façons d’ajouter des éléments à une liste, tous les deux utilisant des <em>méthodes</em> des objets de type liste.</p>

<blockquote>
  <p>Une <em>méthode</em> est liée à un type d’objet particulier.  Supposons que l’on ait un objet de nom <code class="language-plaintext highlighter-rouge">obj</code> et une méthode nommée <code class="language-plaintext highlighter-rouge">meth</code> associée au type de l’objet de nom  <code class="language-plaintext highlighter-rouge">obj</code>, l’instruction <code class="language-plaintext highlighter-rouge">obj.meth()</code> exécutera la méthode <code class="language-plaintext highlighter-rouge">meth</code> pour l’objet <code class="language-plaintext highlighter-rouge">obj</code>. Si la méthode nécessite des paramètres, ils seront placés à l’intérieur de la parenthèse, séparés par des virgules (par exemple <code class="language-plaintext highlighter-rouge">obj.meth(param1, param2)</code>).</p>
</blockquote>

<p>Chaque type d’objet (liste, entier, chaines de caractères) possède de nombreuses méthodes bien utiles. Avant de se lancer dans de la grande programmation, il est souvent préférable de regarder dans la documentation s’il n’existe pas une méthode qui résout notre problème\dots</p>

<p>La liste des méthodes disponibles pour les objets de type liste est disponible là : <a href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists">https://docs.python.org/3/tutorial/datastructures.html#more-on-lists</a>.</p>

<p>Pour ajouter des éléments à une liste, nous utiliserons les méthodes <code class="language-plaintext highlighter-rouge">append</code> et <code class="language-plaintext highlighter-rouge">insert</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">l</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">"a la fin"</span><span class="p">)</span>
<span class="n">l</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">"au debut"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="copie-dune-sous-liste">copie d’une sous-liste</h3>

<p>On peut copier une partie de liste. Ainsi si <code class="language-plaintext highlighter-rouge">l[i]</code> rend l’objet qui est à l’indice <code class="language-plaintext highlighter-rouge">i</code> de la liste <code class="language-plaintext highlighter-rouge">l</code>, <code class="language-plaintext highlighter-rouge">l[i:j]</code> rendra une <strong>liste</strong> contenant les objets de l’indice <code class="language-plaintext highlighter-rouge">i</code> à l’indice <code class="language-plaintext highlighter-rouge">j - 1</code> (cela se comporte comme les paramètre de la fonction <code class="language-plaintext highlighter-rouge">range</code>).</p>

<h2 id="structure-dun-liste">structure d’un liste</h2>

<p>Une liste peut être implémentée de cette façon :</p>

<ul>
  <li>on commence par créer un tableau de taille $t = k$, le nombre initial d’éléments étant $n = 0$.</li>
  <li>à chaque ajout d’éléments :
    <ol>
      <li>test si $n &lt; t$ :
        <ul>
          <li>si oui :
            <ul>
              <li>$n = n + 1$.</li>
            </ul>
          </li>
          <li>sinon :
            <ul>
              <li>on alloue un tableau $2 *t$ éléments \&amp; $t = 2 \times t$</li>
              <li>on copie les $n$ premiers éléments du tableau initial dans le nouveau tableau \&amp; on supprime le tableau initial.</li>
              <li>$n = n + 1$.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>décalage de tous les éléments d’indice supérieur au rang de l’ajout \&amp; insertion de l’élément.</li>
    </ol>
  </li>
</ul>

<h2 id="complexités">complexités</h2>

<ul>
  <li>La complexité dans le cas le pire de la création de la structure : $\mathcal{O}(1)$</li>
  <li>La complexité dans le cas le pire pour trouver l’élément d’indice $i$ : $\mathcal{O}(1)$</li>
  <li>La complexité dans le cas le pire de l’ajout d’un élément à la structure : $\mathcal{O}(n)$</li>
  <li>La complexité dans le cas le pire de la suppression d’un élément de la structure : $\mathcal{O}(1)$</li>
  <li>La complexité dans le cas le pire de la suppression de la structure : $\mathcal{O}(1)$</li>
</ul>

<h3 id="complexité-dajout-de-n-éléments">complexité d’ajout de $n$ éléments</h3>

<p>Ajouter un élément à la structure peut très mal tomber. Cela peut être juste au moment où l’on doit doubler la taille de la structure. C’est donc de complexité $\mathcal{O}(n)$ opération s’il y avait $n$ élément dans la liste au moment de l’ajout.. Mais ensuite, les $n-1$ suivants ajout vont <strong>forcément</strong> bien se passer et auront tous une complexité de $\mathcal{O}(1)$ opérations.</p>

<p>On a même le résultat suivant :</p>

<blockquote class="note">
  <p>L’ajout de $n$ éléments à une liste originellement vide prend $\mathcal{O}(n)$ opérations au maximum</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Complexité d’ajout de $n$ éléments à une liste :</p>

<ul>
  <li>Dans le cas le pire le dernier ajout entraine un doublement de la taille de la structure : un nouveau tableau est créé en $\mathcal{O}(1)$ puis les $n$ éléments de l’ancien tableau sont copiés dans le nouveau en $\mathcal{O}(n)$ opérations</li>
  <li>Le précédent tableau  était de taille $n-1$ et a nécessité $\mathcal{O}(n)$ opérations pour être créé puis rempli (recopie de $n/2$ anciens éléments puis insertion de $n/2$ nouveaux éléments).</li>
  <li>Le tableau encore d’avant d’avant était de taille $n/2$ et son remplissage a pris $\mathcal{O}(n/2)$ opérations (recopie de $n/4$ anciens éléments puis insertion de $n/4$ nouveaux éléments)</li>
  <li>Le tableau encore encore d’avant d’avant était de taille $n/4$ et son remplissage a pris $\mathcal{O}(n/4)$ opérations</li>
  <li>…</li>
  <li>le $i$ème tableau précédent était de taille $n / {2^i}$ et son remplissage a pris $\mathcal{O}(n/{2^i})$ opérations</li>
  <li>…</li>
  <li>le $\log_2(n)$ tableau précédent était de taille $n / {2^{\log_2(n}} = 1$ et son remplissage a pris un nombre d’opérations de $\mathcal{O}(n / {2^{\log_2(n}}) = \mathcal{O}(1)$ opérations</li>
</ul>

<p>La complexité totale est donc de :</p>

\[C(n) = \mathcal{O}(n + n + \frac{n}{2} + \frac{n}{4} + \frac{n}{8} + \dots + 1) = \mathcal{O}(n + \sum_{i=0}^{\log_2(n)}\frac{n}{2^i}) = \mathcal{O}(n(1+\sum_{i=0}^{\log_2(n)}\frac{1}{2^i}))\]

<p><a href="https://fr.wikipedia.org/wiki/1/2_%2B_1/4_%2B_1/8_%2B_1/16_%2B_%E2%8B%AF">Comme</a> $\sum_{i=0}^{+\infty}\frac{1}{2^i} = 1$, on a :</p>

\[(1+\sum_{i=0}^{\log_2(n)}\frac{1}{2^i})) \leq (1+\sum_{i=0}^{+\infty}\frac{1}{2^i})) \leq 2\]

<p>Et donc : $C(n) = \mathcal{O}(n)$</p>

</div></details>

<p>On appelle <strong>complexité amortie</strong> d’un algorithme la complexité d’effectuer $n$ fois une opération le tout divisé par $n$. Dans le cas d’une structure simple, la complexité amortie est égale à la complexité puisque l’on fait $n$ fois la même chose mais pour des structure plus complexe comme les listes, lorsque l’on ajoute $n$ fois un élément, cette opération n’est coûteuse qu’un petit nombre de fois.</p>

<p>La complexité amortie d’ajout de $n$ éléments dans une liste est alors $\mathcal{O}(1)$. En effet :
${\mbox{complexité d’ajout de n éléments dans une liste }} / {n} = {\mathcal{O}(n)} / {n} = \mathcal{O}(1)$</p>

<p>Il est donc légitime d’admettre  que la complexité d’insertion d’un élément en fin de liste est en $\mathcal{O}(1)$ :</p>
<blockquote class="note">
  <p>On considère que La complexité de l’ajout d’un élément en fin de liste est en $\mathcal{O}(1)$ opérations.</p>
</blockquote>

<p>La complexité amortie est un concept avancé. Il ne faut pas le confondre avec la complexité en moyenne, c’est bien $n$ fois la complexité maximale que l’on considère lorsque l’on effectue les opération successivement. C’est un moyen efficace de calculer la complexité d’un algorithme lorsque l’on utilise des structures dont l’opération coûteuse n’est faite qu’un petit nombre de fois.</p>

<h2 id="attention">Attention</h2>

<p>Un piège courant lorsque l’on débute avec les liste en python est d’ajouter un élément en fin de liste avec la commande : <code class="language-plaintext highlighter-rouge">l = l + [x]</code>. C’est une erreur car la complexité est beaucoup plus importante que si l’on utilise la méthode <code class="language-plaintext highlighter-rouge">append</code>:</p>

<ul>
  <li>complexité de <code class="language-plaintext highlighter-rouge">l = l + [x]</code> : $\mathcal{O}(\mbox{len}(l))$ car on crée une nouvelle liste !</li>
  <li>complexité de : <code class="language-plaintext highlighter-rouge">l.append(x)</code> : $\mathcal{O}(1)$ car on ajoute à la fin d’une liste déjà existante</li>
</ul>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique de François Brucker.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
