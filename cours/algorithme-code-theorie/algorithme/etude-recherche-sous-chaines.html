<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>étude / recherche de sous-chaines | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="étude / recherche de sous-chaines">
<meta name="author" content="François Brucker">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique de François Brucker.">
<meta property="og:description" content="Support de cours/td d’informatique de François Brucker.">
<link rel="canonical" href="/cours_informatique/cours/algorithme-code-theorie/algorithme/etude-recherche-sous-chaines.html">
<meta property="og:url" content="/cours_informatique/cours/algorithme-code-theorie/algorithme/etude-recherche-sous-chaines.html">
<meta property="og:site_name" content="cours d’informatique">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="étude / recherche de sous-chaines">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"François Brucker"},"description":"Support de cours/td d’informatique de François Brucker.","headline":"étude / recherche de sous-chaines","url":"/cours_informatique/cours/algorithme-code-theorie/algorithme/etude-recherche-sous-chaines.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">étude / recherche de sous-chaines</h1>Auteur : <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">François Brucker</span></span>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/algorithme-code-theorie/">Algorithme, code et théorie</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/algorithme/">algorithmie</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/algorithme/etude-recherche-sous-chaines.html">étude : recherche de sous-chaines</a></p>

  <p>prérequis :</p>

  <ul>
    <li><a href="/cours_informatique/cours/algorithme-code-theorie/algorithme/complexite-moyenne.html">complexité en moyenne</a></li>
    <li><a href="/cours_informatique/cours/algorithme-code-theorie/algorithme/structure-chaine-de-caracteres.html">structure : chaine de caractères</a></li>
    <li><a href="/cours_informatique/cours/algorithme-code-theorie/theorie/fonctions-hash.html">fonctions de hash</a></li>
  </ul>

</blockquote>

<p>Nous allons dans cette partie analyser le problème de la <em>recherche d’une sous-chaîne</em> :</p>

<blockquote class="note">
  <p><strong>Problème de la recherche d’une sous-chaîne</strong> :</p>

  <ul>
    <li>
<strong>Données</strong> :
      <ul>
        <li>une chaîne de caractère de $a$ de longueur $n$</li>
        <li>une chaîne de caractère de $b$ de longueur $m$, avec $m \leq n$</li>
      </ul>
    </li>
    <li>
<strong>question</strong> :
      <ul>
        <li>$b$ est-il une <em>sous-chaîne</em> de $a$ ?</li>
      </ul>
    </li>
    <li>
<strong>réponse</strong> :
      <ul>
        <li>oui ou non.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Une définition formelle de <em>sous-chaîne</em> étant :</p>

<blockquote class="note">
  <p>Soient $a$ et $b$ deux chaines de caractères de longueurs $n$ et $m &lt;n$ respectivement.</p>

  <p>La chaîne $b$ est une <strong>sous-chaîne</strong> de $a$ s’il existe $0 \leq i &lt; n$ tel que l’on ait pour tout $0 \leq j &lt; m$  :</p>

\[b[j] = a[i + j]\]

</blockquote>

<h2 id="algorithme-naïf">algorithme naïf</h2>

<p>La première idée pour résoudre le problème de <em>la recherche d’une sous-chaîne</em> est de vérifier pour pour tout $0 \leq i &lt; n$ si la définition est correcte :</p>

<style>
    table, td, tr, th, pre {
        padding:0;
        margin:0;
        border:none
    }
</style>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">sous_chaine_naif</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]:</span>
                <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">trouvé</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<h3 id="pièges">pièges</h3>

<p>L’algorithme semble une application directe de la définition, et pourtant… Attention aux multiples pièges de ce genre d’algorithme. Il faut <strong>toujours</strong> vérifier très consciencieusement :</p>

<ul>
  <li>les limites de boucles</li>
  <li>les conditions d’arrêt</li>
</ul>

<p>Essayez de comprendre pourquoi les solutions suivantes ne fonctionnent pas en exhibant un contre-exemple.</p>

<h4 id="limites-de-boucles">limites de boucles</h4>

<p>Attention aux limites des boucles <code class="language-plaintext highlighter-rouge">for</code> ! Il faut <strong>toujours</strong> vérifier les bornes.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_naif_FAUX_1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
        <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]:</span>
                <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">trouvé</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<details><summary>quelle est l’erreur ?</summary><div>
<p>Pas de sentinelle sur le positionnement. On peut avoir  $i + j \geq m$ et donc <code class="language-plaintext highlighter-rouge">a[i + j]</code> provoquer une erreur. Par exemple <code class="language-plaintext highlighter-rouge">sous_chaine_naif("aaa", "ca")</code></p>

</div></details>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_naif_FAUX_2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
        <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]:</span>
                <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">trouvé</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<details><summary>quelle est l’erreur ?</summary><div>
<p>On ne va pas assez loin. Par exemple <code class="language-plaintext highlighter-rouge">sous_chaine_naif("ab", "b")</code></p>

</div></details>

<h4 id="conditions-darrêt">conditions d’arrêt</h4>

<p>Une erreur classique :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_naif_FAUX_3</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<details><summary>quelle est l’erreur ?</summary><div>
<p>Ce n’est pas parce que l’on ne trouve pas la sous-chaine en $i=$ que ce n’et pas vrai pour $i=1$…</p>

<p>Exemple : <code class="language-plaintext highlighter-rouge">sous_chaine_naif("ab", "b")</code></p>

</div></details>

<p>Une variation sur l’erreur précédente :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_naif_FAUX_4</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]:</span>
                <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="n">trouvé</span>
</code></pre></div></div>

<details><summary>quelle est l’erreur ?</summary><div>
<p>Erreur inverse du cas précédent. Il suffit que l’on ne trouve pas le sous-mot à une position pour que l’algorithme réponde faux : <code class="language-plaintext highlighter-rouge">sous_chaine_naif("ba", "b")</code>.</p>

</div></details>

<h3 id="complexité">complexité</h3>

<h4 id="complexité-maximale">complexité maximale</h4>

<p>Calculons la complexité ligne à ligne :</p>

<ol>
  <li>définition d’un fonction : $\mathcal{O}(1)$ opérations</li>
  <li>boucle de $\mathcal{O}(n - m)$ itérations.</li>
  <li>affectation : $\mathcal{O}(1)$ opérations</li>
  <li>boucle de $\mathcal{O}(m)$ itérations.</li>
  <li>positionnement dans 2 tableaux et test : $\mathcal{O}(1)$ opérations</li>
  <li>affectation : $\mathcal{O}(1)$ opérations</li>
  <li>test : $\mathcal{O}(1)$ opérations</li>
  <li>retour de fonction : $\mathcal{O}(1)$ opérations</li>
  <li>retour de fonction : $\mathcal{O}(1)$ opérations</li>
</ol>

<p>On en conclut que la complexité totale se niche dans l’exécution des deux boucles <code class="language-plaintext highlighter-rouge">for</code> imbriquées, et est donc de complexité : $\mathcal{O}((n - m) \cdot m) = \mathcal{O}(nm + m^2) \sim \mathcal{O}(n\cdot m)$ si $m \gg n$ ce qui est généralement le cas.</p>

<h4 id="complexité-minimale">complexité minimale</h4>

<p>La complexité minimale est atteinte lorsque la sous-chaine est trouvée dès $i=0$. Dans ce cas là, il aura fallu $\mathcal{O}(m)$ opérations.</p>

<h4 id="complexité-en-moyenne">complexité en moyenne</h4>

<p>On pourrait envisager deux calculs possible :</p>

<ul>
  <li>complexité en moyenne lorsque $b$ est une sous-chaine de $a$</li>
  <li>complexité en moyenne lorsque $b$ n’est pas une sous-chaine de $a$</li>
</ul>

<p>Le premier cas dépend uniquement de la position de la sous-chaine $b$ dans $a$, pas de la <em>structure</em> de $a$ ou de $b$. Il est donc très dépendant de l’application et il n’y a aucune raison de choisir un modèle purement aléatoire (il  y a très peu d’application où il faut chercher si un mot aléatoire est présent dans une chaine également aléatoire)</p>

<p>Le second cas est le cas le pire et à un nombre constant d’opérations : $\mathcal{O}(nm)$.</p>

<h4 id="attention">attention</h4>

<p>Attention ! L’algorithme suivant, qui utilise la comparaison de listes en python, n’est <strong>pas</strong> de complexité inférieure.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_naif_2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>En effet, la complexité de l’égalité entre deux liste est égale à la taille de la plus petite des listes.</p>

<h3 id="une-amélioration-subtile">une amélioration subtile</h3>

<p>La boucle en $j$ (lignes 4-6) de l’algorithme <code class="language-plaintext highlighter-rouge">sous_chaine_naif</code> pourrait être améliorée en l’arrêtant dès que <code class="language-plaintext highlighter-rouge">trouvé</code> est mis à <code class="language-plaintext highlighter-rouge">False</code>.</p>

<p>On peut pour cela utiliser l’instruction <code class="language-plaintext highlighter-rouge">break</code> qui permet de sortir de la boucle la plus imbriquée (ici la boucle for en $j$ de la ligne 4). Lisez la <a href="https://docs.python.org/fr/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops">documentation</a> à ce sujet, elle est éclairante.</p>

<p>On a alors l’algorithme suivant :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_naif_amélioré</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]:</span>
                <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">trouvé</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>Cela peut sembler une amélioration de bout de chandelles car cela ne change pas la complexité maximale de l’algorithme. Mais… Cela va changer la complexité en moyenne lorsque $b$ n’est pas une sous-chaine de $a$.</p>

<h4 id="calcul-de-la-complexité-en-moyenne">calcul de la complexité en moyenne</h4>

<p>On suppose que l’on ait dans le cas où $b$ n’est pas une sous-chaine de $a$. Pour ce calcul on va se placer dans le cas fictif où chaque lettre est équiprobable. La probabilité que deux lettres soient égales est alors $p = \frac{1}{A}$ où $A$ est la taille de l’alphabet utilisé. C’est le cas le plus défavorable pour notre calcul.</p>

<p>A $i$ fixé, on a alors :</p>

<ol>
  <li>la probabilité que $b[0] \neq a[i]$ vaut $1-p$</li>
  <li>la probabilité que $b[0] = a[i]$ et $b[1] \neq a[i + 1]$ vaut $p\cdot (1-p)$</li>
  <li>la probabilité que $b[j] = a[i + j]$ pour $0\leq j &lt; 2$ et $b[1] \neq a[i + 2]$ vaut $p^2\cdot (1-p)$</li>
  <li>…</li>
  <li>la probabilité que $b[j] = a[i + j]$ pour $0 \leq j &lt; k$ et $b[k] \neq a[i + k]$ vaut $p^k\cdot (1-p)$</li>
  <li>…</li>
  <li>la probabilité que $b[j] = a[i + j]$ pour $0\leq j &lt; m - 1$ et $b[m-1] \neq a[i + m - 1]$ vaut $p^{m-1}\cdot (1-p)$</li>
</ol>

<p>Le nombre moyens d’itérations de la boucle <code class="language-plaintext highlighter-rouge">for</code> en $j$ est alors :</p>

\[1\cdot (1-p) + 2 \cdot p(1-p) + 3 \cdot p^2(1-p) + ... + m \cdot p^{m-1}(1-p) = \frac{1-p}{p}\sum_{k=1}^{m}k\cdot p^k\]

<p>Comme $p &lt; 1$ la série $\sum_{k=1}^{m}k\cdot p^k$ est convergente et est toujours inférieure à $\sum_{k=1}^{+\infty}k\cdot p^k$ qui ne dépend plus de $m$.</p>

<details><summary>preuve de la convergence de la série</summary><div>
<p>Si l’on note $f_m(x) = \sum_{k=1}^mx^k$, on a : $\sum_{k=1}^mk\cdotp^k = p\cdot f’_m(p)$.</p>

<p>Comme une récurrence immédiate montre que $f_m(x) = \frac{x^{m+1} - 1}{x-1}$, on a :</p>

\[\sum_{k=1}^mk\cdot p^k = p \frac{(m+1)p^m(p-1)-(p^{m+1}-1)}{(p-1)^2} = \frac{p}{(p-1)^2}\cdot(mp^{m+1}-(m+1)p^m + 1)\]

<p>comme $p &lt; 1$, $mp^m$ tend vers $0$ lorsque $m$ tend vers $+\infty$ et donc $\sum_{k=1}^mk\cdot p^k$ tend vers $ \frac{p}{(p-1)^2}$ lorsque $m$ tend vers $+\infty$.</p>

<p>On en conclut :</p>

\[\sum_{k=1}^{+\infty}k\cdot p^k =  \frac{p}{(p-1)^2}\]

</div></details>

<p>Le nombre moyen d’itérations de la boucle for en $j$ est donc indépendant de $m$ ! Il ne dépend que de $p$. De là, la complexité moyenne de l’algorithme est ainsi $\mathcal{O}(n)$.</p>

<p>Enfin, comme le cas où $$ n’est pas une sous-chaine de $a$ est le cas le plus défavorable, on en conclut que la complexité en moyenne de l’algorithme est de $\mathcal{O}(n)$ opérations.</p>

<blockquote class="note">
  <p>Un simple <code class="language-plaintext highlighter-rouge">break</code> a rendu linéaire la complexité en moyenne de l’algorithme.</p>
</blockquote>

<h4 id="break-continue-et-while">
<code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code> et <code class="language-plaintext highlighter-rouge">while</code>
</h4>

<p>L’instruction <code class="language-plaintext highlighter-rouge">break</code> de l’algorithme <code class="language-plaintext highlighter-rouge">sous_chaine_naif_amélioré</code> aurait très bien pu s’écrire avec une boucle <code class="language-plaintext highlighter-rouge">while</code> :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_naif_amélioré_sans_break</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]:</span>
                <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">trouvé</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p><strong>Mais</strong> la lecture aurait été moins aisée. L’utilisation de l’instruction <code class="language-plaintext highlighter-rouge">break</code> permet :</p>

<ul>
  <li>d’expliciter le cas général (la boucle for)</li>
  <li>le cas particulier : le <code class="language-plaintext highlighter-rouge">break</code>.</li>
</ul>

<p>Le pendant l’instruction <code class="language-plaintext highlighter-rouge">break</code> est l’instruction <code class="language-plaintext highlighter-rouge">continue</code> qui permet d’aller à la prochaine itération de la boucle la plus imbriquée.</p>

<p>Comparez par exemple ces 2 implémentations d’un même algorithme dont le but est à partir d’une liste d’entiers $L$ de faire un traitement uniquement si l’élément est non nul.</p>

<p>Sans utilisation de <code class="language-plaintext highlighter-rouge">continue</code>, le cas général est traité dans un bloc <code class="language-plaintext highlighter-rouge">if</code> :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">element</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># ...
</span></code></pre></div></div>

<p>Utilisation de <code class="language-plaintext highlighter-rouge">continue</code>, le cas particulier est évacué directement.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">element</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">continue</span>
    
    <span class="c1"># ...
</span></code></pre></div></div>

<p>Le second cas est bien plus clair.</p>

<blockquote class="note">
  <p>L’utilisation de <code class="language-plaintext highlighter-rouge">break</code> et de <code class="language-plaintext highlighter-rouge">continue</code> permet de distinguer clairement dan l’algorithme ce qui est de l’ordre du cas général (la boucle) et du cas particulier (sortie de boucle)</p>
</blockquote>

<h3 id="trouver-toutes-les-sous-chaines">trouver toutes les sous-chaines</h3>

<p>Si l’on cherche à trouver tous les indices où se trouvent $b$ dans $a$, il faut modifier l’algorithme.</p>

<details><summary>solution</summary><div>
<blockquote class="tbd">
  <p>à faire</p>
</blockquote>

</div></details>

<p>Quel est sa complexité ?</p>

<details><summary>solution</summary><div>
<blockquote class="tbd">
  <p>à faire</p>
</blockquote>

</div></details>

<h2 id="algorithme-de-knuth-morris-pratt">Algorithme de Knuth-Morris-Pratt</h2>

<p>L’algorithme <code class="language-plaintext highlighter-rouge">sous_chaine_naif_amélioré</code> est construit autour de la boucle for en <code class="language-plaintext highlighter-rouge">i</code> qui teste si $b$ est présent à partir de chaque position de $a$. A chaque étape on compare un élément de $b$ à l’élément de l’index $i + j$ de $a$. Le principal soucis de l’algorithme est que le nombre $i+j$ peut diminuer.</p>

<p>Par exemple si on cherche la chaine <code class="language-plaintext highlighter-rouge">aab</code> dans la chaine <code class="language-plaintext highlighter-rouge">aaaaaaaa</code> $i+j$ vaudra :</p>

<ol>
  <li>$i+j=0+0 = 0$</li>
  <li>$i+j=0+1 = 1$</li>
  <li>$i+j=0+2 = 2$</li>
  <li>$i+j=1+0 = 1$</li>
  <li>$i+j=1+1 = 2$</li>
  <li>$i+j=1+2 = 3$</li>
  <li>$i+j=2+0 = 2$</li>
  <li>…</li>
</ol>

<p>Chaque élément de $a$ sera vu $m$ fois.</p>

<p>L’algorithme de <a href="https://fr.wikipedia.org/wiki/Algorithme_de_Knuth-Morris-Pratt">Knuth, Morris et Pratt</a> publié en 1977 est une réponse optimale à ce problème. Il permet de trouver une sous-chaine $b$ d’une chaine $a$ en $\mathcal{O}(m + n)$ opérations. Il est basée sur une optimisation du décalage de $i$ et $j$ que permet de rendre la somme $i+j$ croissante (on ne se répète plus).</p>

<h3 id="décalage-adapté">décalage adapté</h3>

<p>Pour accélérer l’algorithme il faut pouvoir garantir que :</p>

<ul>
  <li>soit $i+j$ augmente à chaque étape</li>
  <li>soit $i+j$ est constant mais $i$ augmente (ce qui signifie que l’on a décalé la comparaison).</li>
</ul>

<p>Il faut donc que si on est dans la position suivante à la fin d’une étape :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i + j :         v
a:       ....aaaaaaaaa....
b:           bbbbbb         
i/j:         i  j
</code></pre></div></div>

<p>Alors à l’étape suivante on ait :</p>

<ol>
  <li>
    <p>soit :</p>

    <div class="language-text highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> i + j :          v
 a:       ....aaaaaaaaa....
 b:           bbbbbb         
 i/j:         i   j
</code></pre></div>    </div>

    <p>Qui correspond au fait que l’on continue de chercher si $b$ est une sous-chaine de $a$ à commençant à la position $i$</p>
  </li>
  <li>
    <p>soit :</p>

    <div class="language-text highlighter-rouge">
<div class="highlight"><pre class="highlight"><code> i + j :         v
 a:       ....aaaaaaaaa....
 b:            bbbbbb         
 i/j:          i j
</code></pre></div>    </div>

    <p>Qui correspond au fait que l’on chercher si $b$ est une sous-chaine de $a$ à commençant à une nouvelle position. Dans ce cas là, on est pas obligé de recommencer à $j=0$ car on connaît déjà les premiers caractères de $a$.</p>
  </li>
</ol>

<blockquote class="note">
  <p>Le <em>curseur</em> <code class="language-plaintext highlighter-rouge">v</code> (à la position $i+j$ ne doit qu’augmenter)</p>
</blockquote>

<p>Prenons un cas concret. Supposons que l’on se trouve dans cette configuration :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i + j :         v
a:       ....ATATGACT....
b:           ATATCG          
i/j:         i  j
</code></pre></div></div>

<p>Comme les caractères $a[i +j]$ et $b[j]$ coïncident, l’étape suivante consistera à augmenter $j$ pour continuer la vérification :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i + j :          v
a:       ....ATATGACT....
b:           ATATCG          
i/j:         i   j
</code></pre></div></div>

<p>Le nombre $i+j$ aura augmenté strictement.</p>

<p>Si en revanche, la comparaison échoue, par exemple dans ce cas là :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i + j :          v
a:       ....ATATGACT....
b:           ATATCG          
i/j:         i   j
</code></pre></div></div>

<p>On peut continuer la comparaison à la même position, mais en décalant $i$ :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i + j :          v
a:       ....ATATGACT....
b:             ATATCG          
i/j:           i j
</code></pre></div></div>

<p>Le nombre $i+j$ n’augmentera pas, mais $i$ aura augmenté strictement.</p>

<p>Le nombre minimum de décalage possible peut être formalisé comme suit :</p>

<blockquote class="note">
  <p>Si à la fin d’une étape on a :</p>

  <ul>
    <li>$j &gt; 0$</li>
    <li>$a[i + k] = b[k]$ pour tout $0 \leq k &lt; j$</li>
    <li>$a[i + j] \neq b[j]$</li>
  </ul>

  <p>Soit $l$ le plus petit entier strictement positif tel que $a[i + l + k] = b[k]$ pour tout $0 \leq k &lt; j - l$.</p>

  <p>On peut continuer l’étape suivante avec :</p>

  <ul>
    <li>$i’ = i + l$</li>
    <li>$j’ = j - l$</li>
  </ul>

</blockquote>

<p>On peut noter que $l$ existe toujours, au pire il vaut $j$ et que comme $a[i + l + k] = b[l + k]$, cela revient à chercher $l$ tel que :</p>

<ul>
  <li>$0 &lt; l \leq j &lt; m$</li>
  <li>$b[l + k] = b[k]$ pour tout $0 \leq k &lt; j - l$</li>
</ul>

<blockquote class="note">
  <p>On a plus besoin de $a$ dans le calcul de $l$ !</p>
</blockquote>

<p>On peut donc considérer, pour toute chaine $b$ de longueur $m$ un tableau $T_b$ tel que :</p>

<ul>
  <li>$T_b$ soit de longueur $m - 1$</li>
  <li>$T_b[j - 1] = j - l$ pour $0 &lt; j &lt; m$, avec $l$ le plus petit entier tel que :
    <ul>
      <li>$0 &lt; l \leq j &lt; m$</li>
      <li>$b[l + k] = b[k]$ pour tout $0 \leq k &lt; j - l$</li>
    </ul>
  </li>
</ul>

<blockquote class="note">
  <p>La valeur $T_b[j-1]$ correspond à la longueur maximale d’un début de $b$ qui correspond à une fin de $b[1:j]$ (ce n’est <strong>pas</strong> de $b[:j]$ car il <strong>faut</strong> décaler $b$ d’au moins 1 case).</p>
</blockquote>

<p>Nous donnerons plus tard un moyen efficace de le calculer. Mais si $b$ vaut <code class="language-plaintext highlighter-rouge">ATATCG</code> on aurait par exemple $T_b = [0, 0, 1, 2, 0]$.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00120 
ATATCG
  ATATCG
</code></pre></div></div>

<h3 id="algorithme">algorithme</h3>

<p>En supposant que l’on connaisse un moyen de créer $T_b$, l’algorithme de recherche d’une sous-chaine de Knuth, Morris et Pratt est alors :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_KMP</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">Tb</span> <span class="o">=</span> <span class="n">cree_tableau</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">Tb</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="n">l</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="n">l</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>Comme à chaque itération, soit $i+j$ croit strictement, soit $i$ croit strictement il y a au plus $2n$ étapes à l’algorithme et donc sa complexité est de l’ordre $\mathcal{O}(n + K(m))$ où $K(m)$ est la complexité de la fonction <code class="language-plaintext highlighter-rouge">cree_tableau(b)</code></p>

<h3 id="création-de-la-table-de-décalage">création de la table de décalage</h3>

<p>Créer la table de décalage revient à chercher les répétitions dans la chaîne $b$.</p>

<p>En reprenant la chaine $b$ valant <code class="language-plaintext highlighter-rouge">ACGAGACGACT</code> on note les répétitions possibles  :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0123456789    : index
ACGAGACGACT   : la chaîne b
   A          : une répétition de 1 caractères
     ACGA     : une répétition de 4 caractères
        AC    : une répétition de 2 caractères
</code></pre></div></div>

<p>On peut maintenant construire le tableau $T_b$ tel que $T_b[j-1]$, $1 \leq j &lt; m$, correspond à la longueur maximale d’un début de $b$ qui correspond à une fin de $b[1:j]$ :</p>

<ol>
  <li>$j=1$. On a <code class="language-plaintext highlighter-rouge">b[1:1] = ""</code>. La fin  ne correspond à aucun début de $b$ : $T[1-1] = 0$</li>
  <li>$j=2$. On a <code class="language-plaintext highlighter-rouge">b[1:2] = "C"</code>. La fin ne correspond à aucun début de $b$ : $T[2-1] = 0$</li>
  <li>$j=3$. On a <code class="language-plaintext highlighter-rouge">b[1:3] = "CG"</code>. La fin ne correspond à aucun début de $b$ : $T[3-1] = 0$</li>
  <li>$j=4$. On a <code class="language-plaintext highlighter-rouge">b[1:4] = "CGA"</code>. La fin correspond à <code class="language-plaintext highlighter-rouge">b[:1] = "A"</code> : $T[4-1] = 1$</li>
  <li>$j=5$. On a <code class="language-plaintext highlighter-rouge">b[1:5] = "CGAG"</code>. La fin ne correspond à aucun début de $b$ : $T[5-1] = 0$</li>
  <li>$j=6$. On a <code class="language-plaintext highlighter-rouge">b[1:6] = "CGAGA"</code>. La fin correspond à <code class="language-plaintext highlighter-rouge">b[:1] = "A"</code> :  : $T[6-1] = 1$</li>
  <li>$j=7$. On a <code class="language-plaintext highlighter-rouge">b[1:7] = "CGAGAC"</code>. La fin correspond à <code class="language-plaintext highlighter-rouge">b[:2] = "AC"</code> : $T[7-1] = 2$</li>
  <li>$j=8$. On a <code class="language-plaintext highlighter-rouge">b[1:8] = "CGAGACG"</code>. La fin correspond à <code class="language-plaintext highlighter-rouge">b[:3] = "ACG"</code> : $T[8-1] = 3$</li>
  <li>$j=9$. On a <code class="language-plaintext highlighter-rouge">b[1:9] = "CGAGACGA"</code>. La fin correspond à <code class="language-plaintext highlighter-rouge">b[:4] = "ACGA"</code> : $T[9-1] = 4$</li>
  <li>$j=10$. On a <code class="language-plaintext highlighter-rouge">b[1:10] = "CGAGACGAC"</code>. La fin correspond à <code class="language-plaintext highlighter-rouge">b[:1] = "AC"</code> : $T[10-1] = 2$</li>
</ol>

<p>Le tableau $T_b$ vaut : $[0, 0, 0, 1, 0, 1, 2, 3, 4, 2]$.</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0123456789    : index
ACGAGACGACT   : la chaîne b
   A          : une répétition de 1 caractères
     ACGA     : une répétition de 4 caractères
        AC    : une répétition de 2 caractères
0001012342    : Tb
</code></pre></div></div>

<p>Ceci nous permet de créer un algorithme naïf pour trouver $T_b$.</p>
<details><summary>écrivez cet algorithme</summary><div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">algo_naif_construction_t</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="n">T_b</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
        <span class="n">T_b</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">chaîne</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">j</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chaîne</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">chaîne</span><span class="p">[</span><span class="o">-</span><span class="n">k</span><span class="p">:]:</span>
                <span class="n">T_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>

    <span class="k">return</span> <span class="n">T_b</span>
</code></pre></div></div>

</div></details>

<p>La complexité de cet algorithme est clairement en $\mathcal{O}(m^2)$. Utiliser cet algorithme pour créer $T_b$ nous donne alors une complexité de $\mathcal{O}(n + m^2)$ :</p>

<ul>
  <li>c’est mieux que l’algorithme naïf dans le cas le max</li>
  <li>c’est moins bien en moyenne</li>
</ul>

<p>ON peut faire bien mieux avec un algorithme (très bel) algorithme de Knuth, Morris et Pratt. Ils ont en remarqué que l’on peut construire le tableau de façon itérative et en $\mathcal{O}(m)$ opérations !</p>

<p>Décrivons cette idée. On commence avec un tableau où seul $T_b[0] = 0$ est rempli (pour $j=1$). On considère que $j \geq 2$ et on note $c = b[j-1]$</p>

<p>On cherche $i$ tel que $b[:i]$ coïncide avec la fin de la chaîne $b[1:j-1] + [c]$ : il y a 2 cas à considérer :</p>

<ol>
  <li>on peut continuer la chaine commencée avec $j-1$. Ceci se passe si $b[k] = c$ avec  $T_b[(j-1)-1] = k$. Dans ce cas là $T_b[j-1] = k + 1$</li>
  <li>on ne peut pas continuer la chaine commencée avec $j-1$. Ceci se passe si $b[k] \neq c$ avec  $T_b[(j-1) -1] = k$. On a alors 2 sous-cas :
    <ul>
      <li>$k \leq 1$ (et $b[k] \neq c$) : on a $T_b[j-1] = 0$</li>
      <li>$k &gt; 1$ (et $b[k] \neq c$). Ce problème est équivalent à trouver :
        <ul>
          <li>le plus grand $k’$ possible tel que début de $b$ qui coïncide avec la fin de $b[1:(j-1)-1]$</li>
          <li>et tel que $b[k’ + 1] = c$</li>
        </ul>

        <p>On a déjà fait une grande partie du travail puisque : $k’$ est aussi le plus grand entier tel que la fin de $b[1:k + 1]$ coincide avec le début de $b$.</p>

        <p>On peut donc poser $j = k + 1$ et continuer l’algorithme.</p>
      </li>
    </ul>
  </li>
</ol>

<p>Cette procédure peut s’écrire très simplement avec l’algorithme suivant :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">cree_tableau</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="n">T_b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">T_b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">T_b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">T_b</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
            <span class="n">T_b</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                        
            <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">T_b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">T_b</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">T_b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">T_b</span>
</code></pre></div></div>

<p>Calculons la complexité de cette algorithme. Elle est proportionnelle au nombre d’étapes puisque toutes les autres opérations sont en $\mathcal{O}(1)$.</p>

<p>À chaque étape :</p>

<ul>
  <li>soit $k$ reste constant à 0</li>
  <li>soit $k$ augmente de 1</li>
  <li>soit $k$ diminue strictement</li>
</ul>

<p>Il y a donc au plus autant d’étapes où $k$ diminue que d’étapes où $k$ augmente ou reste constant.</p>

<p>Comme $j$ augmente lorsque $k$ reste constant ou augmente, et que l’on s’arrête lorsque $j$ vaut $m-1$, il y a au plus $m$ étapes où $k$ reste constant ou augmente.</p>

<p>On en déduit qu’il a donc également au plus $m$ étapes où $k$ diminue.</p>

<p>Le nombre total d’étape est en $\mathcal{O(m)}$.</p>

<blockquote class="note">
  <p>La complexité de la création de $T_b$ est en $\mathcal{O(m)}$.</p>

  <p>La complexité de l’algorithme de Knuth-Morris-Pratt est en $\mathcal{O}(n +n)$ opérations : elle est minimale.</p>
</blockquote>

<h3 id="trouver-toutes-les-sous-chaines-1">trouver toutes les sous-chaines</h3>

<p>Si l’on cherche à trouver tous les indices où se trouvent $b$ dans $a$, il faut modifier l’algorithme.</p>

<details><summary>solution</summary><div>
<blockquote class="tbd">
  <p>à faire</p>
</blockquote>

</div></details>

<p>Quel est sa complexité ?</p>

<details><summary>solution</summary><div>
<blockquote class="tbd">
  <p>à faire</p>
</blockquote>

</div></details>

<h2 id="autre-algorithmes">Autre algorithmes</h2>

<p>Nous dne détaillerons pas les autres algorithmes, nous nous contenteront de donner les liens wikipedia et d’indiquer leur intérêt</p>

<ul>
  <li>
<a href="https://fr.wikipedia.org/wiki/Algorithme_de_Rabin-Karp">Rabin-Karp</a>. Cet algorithme est intéressant car :
    <ul>
      <li>plutôt que de chercher la sous-chaine directement, on passe par une fonction de hashage. On compare donc des valeur de hash plutôt que des sous-chaine ce qui est plus rapide en général</li>
      <li>la fonction de hashage utilisée (nommée <a href="https://fr.wikipedia.org/wiki/Algorithme_de_Rabin-Karp#Empreinte_de_Rabin">empreinte de Rabin</a>) est très facilement itérativement calculable.</li>
    </ul>
  </li>
  <li>
<a href="https://fr.wikipedia.org/wiki/Algorithme_de_Boyer-Moore-Horspool">Boyer-Moore-Horspool</a>. Intéressant car on compare de la fin au début et la fonction de saut est plus simple à comprendre que celle de Knuth-Morris-Pratt. En revanche, sa complexité est en $\mathcal{O}(mn)$ et n’a donc que peu d’intérêt à part historique</li>
  <li>
<a href="https://fr.wikipedia.org/wiki/Algorithme_de_Boyer-Moore">Boyer-Moore</a>. Algorithme également linéaire. Sa fonction de saut est compliquée à comprendre (presque autant que celle de Knuth-Morris-Pratt). Son intérêt — à part historique — est le calcul de la complexité qui est tout sauf trivial. On la doit à <a href="http://static.cs.brown.edu/courses/csci1810/resources/ch2_readings/kmp_strings.pdf">Knuth, Morris et Pratt (p343-346)</a> (oui oui, c’est dans le même article où ils présentent leurs propre algorithme).</li>
</ul>

<h2 id="vers-les-expressions-régulières">vers les expressions régulières</h2>

<p>La recherche de sous-chaine n’est presque jamais utilisée en tant que tel en informatique car il faut trouver l’expression exacte :</p>

<ul>
  <li>on ne cherche pas les formes proches (ce qui est possible en utilisant l’alignement de séquences)</li>
  <li>on ne cherche pas de motifs (on appelle cela des <a href="https://fr.wikipedia.org/wiki/Expression_r%C3%A9guli%C3%A8re">expression régulières</a>)</li>
</ul>

<p>Les expressions régulières dépassent de loin le cadre de ce cours mais c’est un sujet à la fois marrant, utile et intéressant. Si vous voulez vous initier en douceur, lisez <a href="https://docs.python.org/fr/3/howto/regex.html">le tuto python</a> qui y est consacré, ou passez directement à <a href="https://www.oreilly.com/library/view/introducing-regular-expressions/9781449338879/">O’reilly</a>.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique de François Brucker.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
