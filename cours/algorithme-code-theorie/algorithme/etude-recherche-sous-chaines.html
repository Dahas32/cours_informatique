<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>étude / recherche de sous-chaines | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="étude / recherche de sous-chaines">
<meta name="author" content="François Brucker">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique de François Brucker.">
<meta property="og:description" content="Support de cours/td d’informatique de François Brucker.">
<link rel="canonical" href="/cours_informatique/cours/algorithme-code-theorie/algorithme/etude-recherche-sous-chaines.html">
<meta property="og:url" content="/cours_informatique/cours/algorithme-code-theorie/algorithme/etude-recherche-sous-chaines.html">
<meta property="og:site_name" content="cours d’informatique">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="étude / recherche de sous-chaines">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"François Brucker"},"description":"Support de cours/td d’informatique de François Brucker.","headline":"étude / recherche de sous-chaines","url":"/cours_informatique/cours/algorithme-code-theorie/algorithme/etude-recherche-sous-chaines.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">étude / recherche de sous-chaines</h1>Auteur : <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">François Brucker</span></span>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/algorithme-code-theorie/">Algorithme, code et théorie</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/algorithme/">algorithmie</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/algorithme/etude-recherche-sous-chaines.html">étude : recherche de sous-chaines</a></p>

  <p>prérequis :</p>

  <ul>
    <li><a href="/cours_informatique/cours/algorithme-code-theorie/algorithme/complexite-moyenne.html">complexité en moyenne</a></li>
    <li><a href="/cours_informatique/cours/algorithme-code-theorie/algorithme/structure-chaine-de-caracteres.html">structure : chaine de caractères</a></li>
    <li><a href="/cours_informatique/cours/algorithme-code-theorie/theorie/fonctions-hash.html">fonctions de hash</a></li>
  </ul>

</blockquote>

<p>Nous allons dans cette partie analyser le problème de la <em>recherche d’une sous-chaîne</em> :</p>

<blockquote class="note">
  <p><strong>Problème de la recherche d’une sous-chaîne</strong> :</p>

  <ul>
    <li>
<strong>Données</strong> :
      <ul>
        <li>une chaîne de caractère de $a$ de longueur $n$</li>
        <li>une chaîne de caractère de $b$ de longueur $m$, avec $m \leq n$</li>
      </ul>
    </li>
    <li>
<strong>question</strong> :
      <ul>
        <li>$b$ est-il une <em>sous-chaîne</em> de $a$ ?</li>
      </ul>
    </li>
    <li>
<strong>réponse</strong> :
      <ul>
        <li>oui ou non.</li>
      </ul>
    </li>
  </ul>
</blockquote>

<p>Une définition formelle de <em>sous-chaîne</em> étant :</p>

<blockquote class="note">
  <p>Soient $a$ et $b$ deux chaines de caractères de longueurs $n$ et $m &lt;n$ respectivement.</p>

  <p>La chaîne $b$ est une <strong>sous-chaîne</strong> de $a$ s’il existe $0 \leq i &lt; n$ tel que l’on ait pour tout $0 \leq j &lt; m$  :</p>

\[b[j] = a[i + j]\]

</blockquote>

<h2 id="algorithme-naïf">algorithme naïf</h2>

<p>La première idée pour résoudre le problème de <em>la recherche d’une sous-chaîne</em> est de vérifier pour pour tout $0 \leq i &lt; n$ si la définition est correcte :</p>

<style>
    table, td, tr, th, pre {
        padding:0;
        margin:0;
        border:none
    }
</style>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">sous_chaine_naif</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]:</span>
                <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">trouvé</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<h3 id="pièges">pièges</h3>

<p>L’algorithme semble une application directe de la définition, et pourtant… Attention aux multiples pièges de ce genre d’algorithme. Il faut <strong>toujours</strong> vérifier très consciencieusement :</p>

<ul>
  <li>les limites de boucles</li>
  <li>les conditions d’arrêt</li>
</ul>

<p>Essayez de comprendre pourquoi les solutions suivantes ne fonctionnent pas en exhibant un contre-exemple.</p>

<h4 id="limites-de-boucles">limites de boucles</h4>

<p>Attention aux limites des boucles <code class="language-plaintext highlighter-rouge">for</code> ! Il faut <strong>toujours</strong> vérifier les bornes.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_naif_FAUX_1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
        <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]:</span>
                <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">trouvé</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<details><summary>quelle est l’erreur ?</summary><div>
<p>Pas de sentinelle sur le positionnement. On peut avoir  $i + j \geq m$ et donc <code class="language-plaintext highlighter-rouge">a[i + j]</code> provoquer une erreur. Par exemple <code class="language-plaintext highlighter-rouge">sous_chaine_naif("aaa", "ca")</code></p>

</div></details>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_naif_FAUX_2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
        <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]:</span>
                <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">trouvé</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<details><summary>quelle est l’erreur ?</summary><div>
<p>On ne va pas assez loin. Par exemple <code class="language-plaintext highlighter-rouge">sous_chaine_naif("ab", "b")</code></p>

</div></details>

<h4 id="conditions-darrêt">conditions d’arrêt</h4>

<p>Une erreur classique :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_naif_FAUX_3</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>
</code></pre></div></div>

<details><summary>quelle est l’erreur ?</summary><div>
<p>Ce n’est pas parce que l’on ne trouve pas la sous-chaine en $i=$ que ce n’et pas vrai pour $i=1$…</p>

<p>Exemple : <code class="language-plaintext highlighter-rouge">sous_chaine_naif("ab", "b")</code></p>

</div></details>

<p>Une variation sur l’erreur précédente :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_naif_FAUX_4</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]:</span>
                <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="n">trouvé</span>
</code></pre></div></div>

<details><summary>quelle est l’erreur ?</summary><div>
<p>Erreur inverse du cas précédent. Il suffit que l’on ne trouve pas le sous-mot à une position pour que l’algorithme réponde faux : <code class="language-plaintext highlighter-rouge">sous_chaine_naif("ba", "b")</code>.</p>

</div></details>

<h3 id="complexité">complexité</h3>

<h4 id="complexité-maximale">complexité maximale</h4>

<p>Calculons la complexité ligne à ligne :</p>

<ol>
  <li>définition d’un fonction : $\mathcal{O}(1)$ opérations</li>
  <li>boucle de $\mathcal{O}(n - m)$ itérations.</li>
  <li>affectation : $\mathcal{O}(1)$ opérations</li>
  <li>boucle de $\mathcal{O}(m)$ itérations.</li>
  <li>positionnement dans 2 tableaux et test : $\mathcal{O}(1)$ opérations</li>
  <li>affectation : $\mathcal{O}(1)$ opérations</li>
  <li>test : $\mathcal{O}(1)$ opérations</li>
  <li>retour de fonction : $\mathcal{O}(1)$ opérations</li>
  <li>retour de fonction : $\mathcal{O}(1)$ opérations</li>
</ol>

<p>On en conclut que la complexité totale se niche dans l’exécution des deux boucles <code class="language-plaintext highlighter-rouge">for</code> imbriquées, et est donc de complexité : $\mathcal{O}((n - m) \cdot m) = \mathcal{O}(nm + m^2) \sim \mathcal{O}(n\cdot m)$ si $m \gg n$ ce qui est généralement le cas.</p>

<h4 id="complexité-minimale">complexité minimale</h4>

<p>La complexité minimale est atteinte lorsque la sous-chaine est trouvée dès $i=0$. Dans ce cas là, il aura fallu $\mathcal{O}(m)$ opérations.</p>

<h4 id="complexité-en-moyenne">complexité en moyenne</h4>

<p>On pourrait envisager deux calculs possible :</p>

<ul>
  <li>complexité en moyenne lorsque $b$ est une sous-chaine de $a$</li>
  <li>complexité en moyenne lorsque $b$ n’est pas une sous-chaine de $a$</li>
</ul>

<p>Le premier cas dépend uniquement de la position de la sous-chaine $b$ dans $a$, pas de la <em>structure</em> de $a$ ou de $b$. Il est donc très dépendant de l’application et il n’y a aucune raison de choisir un modèle purement aléatoire (il  y a très peu d’application où il faut chercher si un mot aléatoire est présent dans une chaine également aléatoire)</p>

<p>Le second cas est le cas le pire et à un nombre constant d’opérations : $\mathcal{O}(nm)$.</p>

<h4 id="attention">attention</h4>

<p>Attention ! L’algorithme suivant, qui utilise la comparaison de listes en python, n’est <strong>pas</strong> de complexité inférieure.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_naif_2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>En effet, la complexité de l’égalité entre deux liste est égale à la taille de la plus petite des listes.</p>

<h3 id="une-amélioration-subtile">une amélioration subtile</h3>

<p>La boucle en $j$ (lignes 4-6) de l’algorithme <code class="language-plaintext highlighter-rouge">sous_chaine_naif</code> pourrait être améliorée en l’arrêtant dès que <code class="language-plaintext highlighter-rouge">trouvé</code> est mis à <code class="language-plaintext highlighter-rouge">False</code>.</p>

<p>On peut pour cela utiliser l’instruction <code class="language-plaintext highlighter-rouge">break</code> qui permet de sortir de la boucle la plus imbriquée (ici la boucle for en $j$ de la ligne 4). Lisez la <a href="https://docs.python.org/fr/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops">documentation</a> à ce sujet, elle est éclairante.</p>

<p>On a alors l’algorithme suivant :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_naif_amélioré</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]:</span>
                <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">trouvé</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>Dès le premier élément qui ne correspond pas, on sort de la boucle for. Cela peut sembler une amélioration de bout de chandelles car cela ne change pas la complexité maximale de l’algorithme. Mais on le verra, cela va changer la complexité en moyenne lorsque $b$ n’est pas une sous-chaine de $a$.</p>

<h4 id="break-continue-et-while">
<code class="language-plaintext highlighter-rouge">break</code>, <code class="language-plaintext highlighter-rouge">continue</code> et <code class="language-plaintext highlighter-rouge">while</code>
</h4>

<p>L’instruction <code class="language-plaintext highlighter-rouge">break</code> de l’algorithme <code class="language-plaintext highlighter-rouge">sous_chaine_naif_amélioré</code> aurait très bien pu s’écrire avec une boucle <code class="language-plaintext highlighter-rouge">while</code> :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_naif_amélioré_sans_break</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]:</span>
                <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">trouvé</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p><strong>Mais</strong> la lecture aurait été moins aisée. L’utilisation de l’instruction <code class="language-plaintext highlighter-rouge">break</code> permet :</p>

<ul>
  <li>d’expliciter le cas général (la boucle for)</li>
  <li>le cas particulier : le <code class="language-plaintext highlighter-rouge">break</code>.</li>
</ul>

<p>Le pendant l’instruction <code class="language-plaintext highlighter-rouge">break</code> est l’instruction <code class="language-plaintext highlighter-rouge">continue</code> qui permet d’aller à la prochaine itération de la boucle la plus imbriquée.</p>

<p>Comparez par exemple ces 2 implémentations d’un même algorithme dont le but est à partir d’une liste d’entiers $L$ de faire un traitement uniquement si l’élément est non nul.</p>

<p>Sans utilisation de <code class="language-plaintext highlighter-rouge">continue</code>, le cas général est traité dans un bloc <code class="language-plaintext highlighter-rouge">if</code> :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">element</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># ...
</span></code></pre></div></div>

<p>Utilisation de <code class="language-plaintext highlighter-rouge">continue</code>, le cas particulier est évacué directement.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">element</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">continue</span>
    
    <span class="c1"># ...
</span></code></pre></div></div>

<p>Le second cas est bien plus clair.</p>

<blockquote class="note">
  <p>L’utilisation de <code class="language-plaintext highlighter-rouge">break</code> et de <code class="language-plaintext highlighter-rouge">continue</code> permet de distinguer clairement dan l’algorithme ce qui est de l’ordre du cas général (la boucle) et du cas particulier (sortie de boucle)</p>
</blockquote>

<h4 id="calcul-de-la-complexité-en-moyenne">calcul de la complexité en moyenne</h4>

<p>On suppose que l’on ait dans le cas où $b$ n’est pas une sous-chaine de $a$. Pour ce calcul on va se placer dans le cas fictif où chaque lettre est équiprobable. La probabilité que deux lettres soient égales est alors $p = \frac{1}{A}$ où $A$ est la taille de l’alphabet utilisé. C’est le cas le plus défavorable pour notre calcul.</p>

<p>A $i$ fixé, on a alors :</p>

<ol>
  <li>la probabilité que $b[0] \neq a[i]$ vaut $1-p$</li>
  <li>la probabilité que $b[0] = a[i]$ et $b[1] \neq a[i + 1]$ vaut $p\cdot (1-p)$</li>
  <li>la probabilité que $b[j] = a[i + j]$ pour $0\leq j &lt; 2$ et $b[1] \neq a[i + 2]$ vaut $p^2\cdot (1-p)$</li>
  <li>…</li>
  <li>la probabilité que $b[j] = a[i + j]$ pour $0 \leq j &lt; k$ et $b[k] \neq a[i + k]$ vaut $p^k\cdot (1-p)$</li>
  <li>…</li>
  <li>la probabilité que $b[j] = a[i + j]$ pour $0\leq j &lt; m - 1$ et $b[m-1] \neq a[i + m - 1]$ vaut $p^{m-1}\cdot (1-p)$</li>
</ol>

<p>Cette probabilité devient vite très faible. Par exemple, si on a un alphabet à 2 caractères (0 et 1), la probabilité de s’arrêter au bout de 10 itérations vaut : $(\frac{1}{2})^10 = 0.1\%$.</p>

<p>De là, la probabilité que l’on s’arrête après :</p>

<ul>
  <li>1 itérations de la boucle <code class="language-plaintext highlighter-rouge">for</code> en $j$  est égale à $(1-p)$</li>
  <li>2 itérations de la boucle <code class="language-plaintext highlighter-rouge">for</code> en $j$  est égale à $p(1-p)$</li>
  <li>…</li>
  <li>$j$ itérations de la boucle <code class="language-plaintext highlighter-rouge">for</code> en $j$  est égale à $p^{j-1}(1-p)$</li>
  <li>…</li>
  <li>$m$ itérations de la boucle <code class="language-plaintext highlighter-rouge">for</code> en $j$  est égale à $p^{m-1}(1-p)$</li>
</ul>

<p>Le nombre moyens d’itérations de la boucle <code class="language-plaintext highlighter-rouge">for</code> en $j$ est alors :</p>

\[1\cdot (1-p) + 2 \cdot p(1-p) + 3 \cdot p^2(1-p) + ... + m \cdot p^{m-1}(1-p) = \frac{1-p}{p}\sum_{k=1}^{m}k\cdot p^k\]

<p>Et comme chaque itération se fait en $\mathcal{O}(1)$ opérations, La complexité en moyenne du passage dans la boucle <code class="language-plaintext highlighter-rouge">for</code> en $j$ vaut :</p>

\[\mathcal{O}(1) \cdot \frac{1-p}{p}\sum_{k=1}^{m}k\cdot p^k = \mathcal{O}(\frac{1-p}{p}\sum_{k=1}^{m}k\cdot p^k) = \mathcal{O}(\sum_{k=1}^{m}k\cdot p^k)\]

<p>Comme :</p>

\[\sum_{k=1}^mk\cdot p^k = \frac{p}{(p-1)^2}\cdot(mp^{m+1}-(m+1)p^m + 1)\]

<details><summary>preuve</summary><div>
<p>Si l’on note $f_m(x) = \sum_{k=1}^mx^k$, on a : $\sum_{k=1}^mk\cdotp^k = p\cdot f’_m(p)$. De là, une récurrence immédiate montre que $f_m(x) = \frac{x^{m+1} - 1}{x-1}$. Ainsi :</p>

\[\sum_{k=1}^mk\cdot p^k = p \frac{(m+1)p^m(p-1)-(p^{m+1}-1)}{(p-1)^2} = \frac{p}{(p-1)^2}\cdot(mp^{m+1}-(m+1)p^m + 1)\]
</div></details>

<p>Comme $p &lt; 1$, on a que :</p>

\[\lim_{m \rightarrow +\infty} \frac{p}{(p-1)^2}\cdot(mp^{m+1}-(m+1)p^m + 1) = \frac{p}{(p-1)^2}\]

<p>Et donc, pour tout $m$ :</p>

\[\sum_{k=1}^mk\cdot p^k \leq \frac{p}{(p-1)^2}\]

<p>Donc :</p>

\[\mathcal{O}(\sum_{k=1}^{m}k\cdot p^k) = \mathcal{O}(\frac{p}{(p-1)^2}) = \mathcal{O}(1)\]

<p>Le nombre moyen d’itérations de la boucle for en $j$ est donc toujours plus petit qu’une constante : c’est indépendant de $m$ et ne dépend que de $p$ !</p>

<p>Ceci s’explique par le fait que la probabilité de s’arrêter au bout de $j$ itération devient très vite très petite, et d’autant plus petite que l’alphabet augmente. On s’arrêtera quasi toujours avant d’arriver à la fin de $b$.</p>

<p>Ce résultat surprennent amène à un autre résultat tout aussi surprenant : comme le reste de l’algorithme est de complexité $\mathcal{O}(n)$ :</p>

<blockquote class="note">
  <p>la complexité en moyenne de l’algorithme naif est $\mathcal{O}(n)$.</p>
</blockquote>

<p>Un simple <code class="language-plaintext highlighter-rouge">break</code> a rendu linéaire la complexité en moyenne de l’algorithme.</p>

<h3 id="trouver-toutes-les-sous-chaines">trouver toutes les sous-chaines</h3>

<p>Si l’on cherche à trouver tous les indices où se trouvent $b$ dans $a$, il faut modifier l’algorithme pour stocker les indices où $b$ commence. Ceci se fait aisément :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_naif_tous</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]:</span>
                <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">trouvé</span><span class="p">:</span>
            <span class="n">indices</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">indices</span>
</code></pre></div></div>

<p>Donnez les complexités de ce nouvel algorithme.</p>
<details><summary>solution</summary><div>
<p>Les complexités maximale et en moyenne de l’algorithme n’ont pas changé. Seule la complexité minimale est passé de $\mahtcal{O}(m)$ à $\mathcal{O}(n)$ puisque l’on parcours toute la chaine à chaque fois.</p>

</div></details>

<h2 id="améliorations">améliorations</h2>

<p>it autour de la boucle for en <code class="language-plaintext highlighter-rouge">i</code> qui teste si $b$ est présent à partir de chaque position de $a$. A chaque étape on compare un élément de $b$ à l’élément de l’index $i + j$ de $a$. Le principal soucis de l’algorithme est que le nombre $i+j$ peut diminuer.</p>

<p>Par exemple si on cherche la chaine <code class="language-plaintext highlighter-rouge">b=CGT</code> dans la chaine <code class="language-plaintext highlighter-rouge">a=CGACGACGACGA</code> $i+j$ vaudra :</p>

<ol>
  <li>$i+j=0+0 = 0$</li>
  <li>$i+j=0+1 = 1$</li>
  <li>$i+j=0+2 = 2$</li>
  <li>$i+j=1+0 = 1$</li>
  <li>$i+j=1+1 = 2$</li>
  <li>$i+j=1+2 = 3$</li>
  <li>$i+j=2+0 = 2$</li>
  <li>…</li>
</ol>

<p>Chaque élément de $a$ sera vu $m$ fois.</p>

<p>Accélérer l’algorithme revient à faire en sorte que le nombre $i+j$ soit croissant le plus souvent possible.</p>

<h3 id="prétraitement-utilisant-a">prétraitement utilisant $a$</h3>

<p>Une première idée que l’on peut avoir pour accélérer le processus et de remarquer que ça ne sert à rien de faire commencer la recherche de $b$ dans $a$ à l’index $i$ si $a[i] \neq b[0]$.</p>

<p>Ceci peut se faire en $\mathcal{O}(n)$ opérations en utilisant <code class="language-plaintext highlighter-rouge">sous_chaine_naif_tous(a, b[0])</code>. On utilise ensuite ces indices dans notre algorithme accéléré :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_naif_acceleration_1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sous_chaine_naif_tous</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]:</span>
                <span class="n">trouvé</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">trouvé</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>Il faut maintenant tenir compte du prétraitement dans le calcul de la complexité.</p>

<ul>
  <li>ce qu’on fait en plus : on parcourt toute la chaine $a$ pour rendre le tableau d’indices. Cela se fait en $\mathcal{O}(n)$ opérations</li>
  <li>ce qu’on fait en moins : on ne parcourt plus que certains indices $i$ et pas tous.</li>
</ul>

<p>Mais au final, on ne gagne rien… En effet le temps gagné pour ne parcourir que certains indices est compenser par le fait qu’il faut les trouver. 
L’algorithme naïf ne prend pas plus de temps que notre optimisation car si $a[i] \neq b[0]$ on passe tout de suite à l’indice suivant.</p>

<p>Si on veut augmenter la rapidité de l’algorithme, il faut travailler sur $b$ pour optimiser les décalages.</p>

<h3 id="prétraitement-sur-b">prétraitement sur $b$</h3>

<p>Notre objectif est toujours de rendre la somme $i+j$ la plus croissante possible pour éviter les répétitions. Comment adapter l’idée précédente en ne travaillant que sur $b$ ?</p>

<p>Pour comprendre, regardons tous les cas possibles avec notre algorithme naïf :</p>

<p>On débute une recherche en comparant $a[i + 0]$ à $b[0] :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>             i  
a:     ...aaa?aaaaaaaa....
b:           bbbbbb         
             j
</code></pre></div></div>

<p>Si $a[i] = b[0]$ alors on décale $j$ d’un cran :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>             i  
a:     ...aaab?aaaaaaa....
b:           bbbbbb         
              j
</code></pre></div></div>

<p>Sinon, on a pas vraiment d’autre choix que de décaler i de 1 :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>              i  
a:     ...aaaa?aaaaaaa....
b:            bbbbbb         
              j
</code></pre></div></div>

<p>Il n’y a pas vraiment de moyen de gagner des opérations dans ce cas là.</p>

<p>Supposons maintenant que l’on ait un peu avancé :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>             i  
a:     ...aaabbb?aaaaa....
b:           bbbbbb         
                j
</code></pre></div></div>

<p>On a $a[i + k] = b[k]$ pour tout $0 \leq k &lt; j$. Et on compare $a[i + j]$ à $b[j]$.</p>

<p>Si $a[i + j] = b[j]$ alors on décale $j$ d’un cran et on recommence si $j &lt; m$ et sinon on s’arrête puisque l’on a trouvé $b$ dans $a$. Mais si $a[i + j] \neq b[j]$ on replace $j$ à 0 et on augmente $i$. Cette augmentation peut être de 1 à $j$ :</p>

<ul>
  <li>
    <p>augmentation de 1 (comme pour le l’algorithme naïf)</p>

    <div class="language-text highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>               i  
  a:     ...aaabbb?aaaaa....
  b:            bbbbbb         
                j
</code></pre></div>    </div>
  </li>
  <li>
    <p>augmentation max :</p>

    <div class="language-text highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>                  i  
  a:     ...aaabbb?aaaaa....
  b:              bbbbbb         
                  j
</code></pre></div>    </div>
  </li>
  <li>
    <p>augmentation entre les deux :</p>

    <div class="language-text highlighter-rouge">
<div class="highlight"><pre class="highlight"><code>                 i  
  a:     ...aaabbb?aaaaa....
  b:             bbbbbb         
                 j
</code></pre></div>    </div>
  </li>
</ul>

<p>En réutilisant la partie précédente, on a clairement que l’augmentation minimale de $i$ que l’on peut avoir est :</p>

<ul>
  <li>$i=i+j$ s’il n’existe pas $0 &lt; k &lt; j$ tel que $a[i+k] = b[j]$</li>
  <li>$i=i+k$ avec $0 &lt; k \leq j$ le plus petit entier tel que $a[i+k] = b[0]$, sinon</li>
</ul>

<p>Comme on sait que $a[i:i+j]$ vaut $b[:j]$ on peut précalculer ces déplacements !</p>

<p>On commence par chercher le premier endroit où $b[0]$ est répété dans $b$. On peut utiliser <code class="language-plaintext highlighter-rouge">sous_chaine_naif_tous(b, b[0])</code> et prendre, s’il existe, le deuxième élément de la sortie, disons $p$. Si cet élément n’existe pas, on note $p=m$</p>

<p>Ensuite, si :</p>

<ul>
  <li>$a[i + k] = b[k]$ pour tout $0 \leq k &lt; j$</li>
  <li>$a[i + j] \neq b[j]$</li>
</ul>

<p>On peut déplacer $i$ de :</p>

<ul>
  <li>1 si $j=0$</li>
  <li>$p$ si $p &lt; j$</li>
  <li>$j$ sinon</li>
</ul>

<p>Pour préparer la suite, on va ranger ces informations dans un tableau $T_b$ de longueur $m-1$ tel que :</p>

<ul>
  <li>$T_b[j-1] = 0$  pour tout $1 \leq j \leq p$</li>
  <li>$T_b[j-1] = j - p$  pour tout $p &lt; j \leq m-1$</li>
</ul>

<p>Par exemple, pour $b=ACATGA$, on aurait : $T_b = [0, 0, 1, 2, 3]$</p>

<p>Avec ce tableau, notre algorithme devient alors :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_naif_acceleration_2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">T_b</span> <span class="o">=</span> <span class="n">creation_tableau_opti_1</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="n">T_b</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<p>On a donc 2 décalages possibles :</p>

<ul>
  <li>soit on déplace $i$ sur $j$ (on est avant le nouveau début)</li>
  <li>soit on déplace i pour que a[i] soit un début de b (lorsque l’on a $j \geq p$ et que que l’on connaît le début de $a$)</li>
</ul>

<p>Plus il y a de 0 dans $T_b$ plus les décalages seront importants</p>

<p>Cependant, la forme de $T_b$ sera toujours $[0, 0, …, 0, 1, 2, …, k]$. On gagne de l’optimisation puisque l’on avance toujours du maximum possible jusqu’à la 1ère répétition.</p>

<h3 id="amélioration-de-lamélioration">amélioration de l’amélioration</h3>

<p>L’amélioration précédente permet d’avancer $i$ jusqu’au second départ de $b$ — le premier indice $p &gt; 0$ tel que b[0] = b[p]$ — si $j &gt; p$. Plaçons nous dans ce cas là :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            i  
a:     .....abbbaa?aaa....
b:          bbbbbbbb         
                p j
</code></pre></div></div>

<p>On a :</p>

<ul>
  <li>$p&gt;0$ le premier indice tel que $b[0] = b[p]$</li>
  <li>$a[i + k] = b[k]$ pour tout $0 \leq k &lt; j$</li>
  <li>$p &lt; j$</li>
  <li>$a[i + j] \neq b[j]$</li>
</ul>

<p>On sait donc aussi que $a[i + p] = b[0]$.</p>

<p>L’amélioration précédente revient à poser :</p>

<ul>
  <li>$i’ = i + p$</li>
  <li>$j’ = 0$</li>
</ul>

<p>On se retrouve alors dans ce cas là :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            i  
                i'
a:     .....abbbaa?aaa....
b:              bbbbbbbb         
                j' 
                  j
</code></pre></div></div>

<p>Avec :</p>

<ul>
  <li>$a[i’] = b[0] = b[p]$</li>
  <li>$a[i’ + k] = b[p + k]$ pour tout $k &lt; j-p$</li>
</ul>

<p>On a alors deux choix :</p>

<ul>
  <li>soit $b[k] = b[p + k]$ pour tout $k &lt; j-p$ et on peut poser $j’ = i + j - p$ (on remet j’ au niveau du ?)</li>
  <li>soit ce n’est pas le cas et ça ne sert à rien de regarder si $b$ commence en $i’$ parce que ce n’est pas possible</li>
</ul>

<p>Remarquez que ceci peut se faire sans $a$. Ceci nous donne une nouvelle possibilité d’amélioration :</p>

<blockquote class="note">
  <p>si :</p>
  <ul>
    <li>$j &gt; 0$</li>
    <li>$a[i + k] = b[k]$ pour tout $0 \leq k &lt; j$</li>
    <li>$a[i + j] \neq b[j]$</li>
  </ul>

  <p>alors soit $k’$ le plus petit entier tel que $b[:k’] == b[j-k’:j]$ (au pire $k’=0$). 
Avec :</p>

  <ul>
    <li>$i’ = i + j - k$</li>
    <li>$j’ = k$</li>
  </ul>

  <p>On a que :</p>

  <ul>
    <li>$i’$ est le prochain indice de $a$ où $b$ peut être une sous-chaine de $a$</li>
    <li>$a[i’ + l] = b[l]$ pour tout $0 \leq l &lt; j’$</li>
  </ul>

</blockquote>

<p>C’est cette procédure que mets (optimalement) en œuvre l’algorithme de Knuth, Morris et Pratt.</p>

<h2 id="algorithme-de-knuth-morris-pratt">Algorithme de Knuth-Morris-Pratt</h2>

<p>L’algorithme de <a href="https://fr.wikipedia.org/wiki/Algorithme_de_Knuth-Morris-Pratt">Knuth, Morris et Pratt</a> publié en 1977, reprend l’idée de l’optimisation précédente mais la sublime. Il trouve un tableau $T_b$ optimal permettant de trouver un algorithme en $\mathcal{O}(n +m)$, c’est à dire de façon optimale.</p>

<p>Nous allons procéder par étape pour essayer de le comprendre.</p>

<h3 id="décalage-adapté">décalage adapté</h3>

<p>L’idée force de l’algorithme est que les éléments $T_b[j]$ ne sont plus la distance à la première répétition du premier caractère, mais compte le nombre de caractères dont la fin de $b[:j+1]$ sont un début de $b$ différent de $b[:j+1]$.</p>

<p>Ce tableau permet également d’avancer $i$ plus que l’algorithme naïf. Avant de formaliser tout ça regardons ce que ça donne sur un exemple :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0123456789    : index
ACGAGACGACT   : la chaîne b
   A          : une répétition de 1 caractères
     ACGA     : une répétition de 4 caractères
        AC    : une répétition de 2 caractères
</code></pre></div></div>

<p>Le tableau $T_b$ vaudra alors : $[0, 0, 0, 1, 0, 1, 2, 3, 4, 2]$.</p>

<ol>
  <li>$j=0$ par convention on note $T_b[0] = 0$</li>
  <li>$j=1$. On a <code class="language-plaintext highlighter-rouge">b[:2] = "AC"</code>. La fin ne correspond à aucun début de $b$ à part $b[:2]$ : $T[1] = 0$</li>
  <li>$j=2$. On a <code class="language-plaintext highlighter-rouge">b[:3] = "ACG"</code>. La fin ne correspond à aucun début de $b$ à part $b[:3]$: $T[2] = 0$</li>
  <li>$j=3$. On a <code class="language-plaintext highlighter-rouge">b[:4] = "ACGA"</code>. La fin correspond à <code class="language-plaintext highlighter-rouge">b[:1] = "A"</code> : $T[3] = 1$</li>
  <li>$j=4$. On a <code class="language-plaintext highlighter-rouge">b[:5] = "ACGAG"</code>. La fin ne correspond à aucun début de $b$ à par $b[:5]$ : $T[4] = 0$</li>
  <li>$j=5$. On a <code class="language-plaintext highlighter-rouge">b[:6] = "ACGAGA"</code>. La fin correspond à <code class="language-plaintext highlighter-rouge">b[:1] = "A"</code> :  : $T[5] = 1$</li>
  <li>$j=6$. On a <code class="language-plaintext highlighter-rouge">b[:7] = "ACGAGAC"</code>. La fin correspond à <code class="language-plaintext highlighter-rouge">b[:2] = "AC"</code> : $T[6] = 2$</li>
  <li>$j=7$. On a <code class="language-plaintext highlighter-rouge">b[:8] = "ACGAGACG"</code>. La fin correspond à <code class="language-plaintext highlighter-rouge">b[:3] = "ACG"</code> : $T[7] = 3$</li>
  <li>$j=8$. On a <code class="language-plaintext highlighter-rouge">b[:9] = "ACGAGACGA"</code>. La fin correspond à <code class="language-plaintext highlighter-rouge">b[:4] = "ACGA"</code> : $T[8] = 4$</li>
  <li>$j=9$. On a <code class="language-plaintext highlighter-rouge">b[:10] = "ACGAGACGAC"</code>. La fin correspond à <code class="language-plaintext highlighter-rouge">b[:1] = "AC"</code> : $T[9] = 2$</li>
</ol>

<p>Formalisons ça.</p>

<blockquote class="note">
  <p>Soit $T_b$ un tableau de longueur $m-1$</p>

  <ul>
    <li>T_b[0] = 0</li>
    <li>pour tout $1 \leq j &lt; m-1$, on note $T_b[j]$ le plus grand entier $k &lt; j +1$ tel que $b[:k] = b[j+1-k:j+1]$.</li>
  </ul>

</blockquote>

<p>On peut noter que $T_b[j]$ existe toujours puisque $b[:0]$ et $b[k:k]$ sont la chaine vide pour tout $k$.</p>

<p>On peut facilement calculer $T_b$, par exemple avec cet algorithme :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">algo_naif_construction_t</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="n">T_b</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)):</span>
        <span class="n">T_b</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">chaîne</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">j</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chaîne</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">b</span><span class="p">[:</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">chaîne</span><span class="p">[</span><span class="o">-</span><span class="n">k</span><span class="p">:]:</span>
                <span class="n">T_b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>

    <span class="k">return</span> <span class="n">T_b</span>
</code></pre></div></div>

<p>La complexité de cet algorithme est cependant assez grande, puisqu’elle est en $\mathcal{O}(m^3)$.</p>

<h3 id="algorithme">algorithme</h3>

<p>Avec le tableau $T_b$ défini comme précédemment, on a un gain monumental par rapport à l’optimisation précédente. On a plus besoin de revenir en arrière : on peut faire augmenter (au sens large) $i+j$ à chaque étape.</p>

<p>Prenons un cas concret. Supposons que l’on se trouve dans cette configuration :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i + j :         v
a:       ....ATATGACT....
b:           ATATCG          
i/j:         i  j
</code></pre></div></div>

<p>Comme les caractères $a[i +j]$ et $b[j]$ coïncident, l’étape suivante consistera à augmenter $j$ pour continuer la vérification :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i + j :          v
a:       ....ATATGACT....
b:           ATATCG          
i/j:         i   j
</code></pre></div></div>

<p>Le nombre $i+j$ aura augmenté strictement.</p>

<p>Si en revanche, la comparaison échoue, par exemple dans ce cas là :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i + j :          v
a:       ....ATATGACT....
b:           ATATCG          
i/j:         i   j
</code></pre></div></div>

<p>On peut continuer la comparaison à la même position, mais en décalant $i$ de $T_b[j-1] = T_b[3] = 2$ :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>i + j :          v
a:       ....ATATGACT....
b:             ATATCG          
i/j:           i j
</code></pre></div></div>

<p>Le nombre $i+j$ n’augmentera pas, mais $i$ aura augmenté strictement.</p>

<p>En supposant que la fonction  <code class="language-plaintext highlighter-rouge">cree_tableau(b)</code> crée $T_b$, l’algorithme de recherche d’une sous-chaine de Knuth, Morris et Pratt est alors :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">sous_chaine_KMP</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">Tb</span> <span class="o">=</span> <span class="n">cree_tableau</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        
            <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">True</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span> <span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">Tb</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="n">l</span>
                <span class="n">j</span> <span class="o">-=</span> <span class="n">l</span>
    <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>

<blockquote>
  <p>par rapport à l’algorithme précédent, $T_b$ est différent et la mise à jour de $j$ n’est plus forcément égale à 0.</p>
</blockquote>

<p>Comme à chaque itération, soit $i+j$ croit strictement, soit $i$ croit strictement il y a au plus $2n$ étapes à l’algorithme et donc sa complexité est de l’ordre $\mathcal{O}(n + K(m))$ où $K(m)$ est la complexité de la fonction <code class="language-plaintext highlighter-rouge">cree_tableau(b)</code></p>

<h3 id="création-de-la-table-de-décalage">création de la table de décalage</h3>

<p>L’algorithme naïf de création de la table est en $\mathcal{O}(m^3)$ ce qui n’est pas vraiment optimal. L’algorithme utilisé par Knutt, Morris-et Pratt est de complexité bien meilleure puisqu’il permet de créer le tableau $T_b$ en $\mathcal{O}(m)$ opérations !</p>

<p>Décrivons l’idée. On commence avec un tableau où seul $T_b[0] = 0$ est rempli (pour $j=1$). On considère que $j \geq 2$ et on note $c = b[j-1]$</p>

<p>On cherche $i$ tel que $b[:i]$ coïncide avec la fin de la chaîne $b[1:j-1] + [c]$ : il y a 2 cas à considérer :</p>

<ol>
  <li>on peut continuer la chaine commencée avec $j-1$. Ceci se passe si $b[k] = c$ avec  $T_b[(j-1)-1] = k$. Dans ce cas là $T_b[j-1] = k + 1$</li>
  <li>on ne peut pas continuer la chaine commencée avec $j-1$. Ceci se passe si $b[k] \neq c$ avec  $T_b[(j-1) -1] = k$. On a alors 2 sous-cas :
    <ul>
      <li>$k \leq 1$ (et $b[k] \neq c$) : on a $T_b[j-1] = 0$</li>
      <li>$k &gt; 1$ (et $b[k] \neq c$). Ce problème est équivalent à trouver :
        <ul>
          <li>le plus grand $k’$ possible tel que début de $b$ qui coïncide avec la fin de $b[1:(j-1)-1]$</li>
          <li>et tel que $b[k’ + 1] = c$</li>
        </ul>

        <p>On a déjà fait une grande partie du travail puisque : $k’$ est aussi le plus grand entier tel que la fin de $b[1:k + 1]$ coincide avec le début de $b$.</p>

        <p>On peut donc poser $j = k + 1$ et continuer l’algorithme.</p>
      </li>
    </ul>
  </li>
</ol>

<p>Cette procédure peut s’écrire très simplement avec l’algorithme suivant :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">cree_tableau</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="n">T_b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">T_b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">T_b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">T_b</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">b</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
            <span class="n">T_b</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                        
            <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">T_b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">T_b</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                <span class="n">j</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">T_b</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">T_b</span>
</code></pre></div></div>

<p>Calculons la complexité de cette algorithme. Elle est proportionnelle au nombre d’étapes puisque toutes les autres opérations sont en $\mathcal{O}(1)$.</p>

<p>À chaque étape :</p>

<ul>
  <li>soit $k$ reste constant à 0</li>
  <li>soit $k$ augmente de 1</li>
  <li>soit $k$ diminue strictement</li>
</ul>

<p>Il y a donc au plus autant d’étapes où $k$ diminue que d’étapes où $k$ augmente ou reste constant.</p>

<p>Comme $j$ augmente lorsque $k$ reste constant ou augmente, et que l’on s’arrête lorsque $j$ vaut $m-1$, il y a au plus $m$ étapes où $k$ reste constant ou augmente.</p>

<p>On en déduit qu’il a donc également au plus $m$ étapes où $k$ diminue.</p>

<p>Le nombre total d’étape est en $\mathcal{O(m)}$.</p>

<blockquote class="note">
  <p>La complexité de la création de $T_b$ est en $\mathcal{O(m)}$.</p>

  <p>La complexité de l’algorithme de Knuth-Morris-Pratt est en $\mathcal{O}(n +n)$ opérations : elle est minimale.</p>
</blockquote>

<h2 id="autres-algorithmes">Autres algorithmes</h2>

<p>Nous ne détaillerons pas les autres algorithmes, nous nous contenteront de donner les liens wikipedia et d’indiquer leur intérêt</p>

<ul>
  <li>
<a href="https://fr.wikipedia.org/wiki/Algorithme_de_Rabin-Karp">Rabin-Karp</a>. Cet algorithme est intéressant car :
    <ul>
      <li>plutôt que de chercher la sous-chaine directement, on passe par une fonction de hashage. On compare donc des valeur de hash plutôt que des sous-chaine ce qui est plus rapide en général</li>
      <li>la fonction de hashage utilisée (nommée <a href="https://fr.wikipedia.org/wiki/Algorithme_de_Rabin-Karp#Empreinte_de_Rabin">empreinte de Rabin</a>) est très facilement itérativement calculable.</li>
    </ul>
  </li>
  <li>
<a href="https://fr.wikipedia.org/wiki/Algorithme_de_Boyer-Moore-Horspool">Boyer-Moore-Horspool</a>. Intéressant car on compare de la fin au début et la fonction de saut est plus simple à comprendre que celle de Knuth-Morris-Pratt. En revanche, sa complexité est en $\mathcal{O}(mn)$ et n’a donc que peu d’intérêt à part historique</li>
  <li>
<a href="https://fr.wikipedia.org/wiki/Algorithme_de_Boyer-Moore">Boyer-Moore</a>. Algorithme également linéaire. Sa fonction de saut est compliquée à comprendre (presque autant que celle de Knuth-Morris-Pratt). Son intérêt — à part historique — est le calcul de la complexité qui est tout sauf trivial. On la doit à <a href="http://static.cs.brown.edu/courses/csci1810/resources/ch2_readings/kmp_strings.pdf">Knuth, Morris et Pratt (p343-346)</a> (oui oui, c’est dans le même article où ils présentent leurs propre algorithme).</li>
</ul>

<h2 id="vers-les-expressions-régulières">vers les expressions régulières</h2>

<p>La recherche de sous-chaine n’est presque jamais utilisée en tant que tel en informatique car il faut trouver l’expression exacte :</p>

<ul>
  <li>on ne cherche pas les formes proches (ce qui est possible en utilisant l’alignement de séquences)</li>
  <li>on ne cherche pas de motifs (on appelle cela des <a href="https://fr.wikipedia.org/wiki/Expression_r%C3%A9guli%C3%A8re">expression régulières</a>)</li>
</ul>

<p>Les expressions régulières dépassent de loin le cadre de ce cours mais c’est un sujet à la fois marrant, utile et intéressant. Si vous voulez vous initier en douceur, lisez <a href="https://docs.python.org/fr/3/howto/regex.html">le tuto python</a> qui y est consacré, ou passez directement à <a href="https://www.oreilly.com/library/view/introducing-regular-expressions/9781449338879/">O’reilly</a>.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique de François Brucker.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
