<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>étude : voyageur de commerce | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="étude : voyageur de commerce">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique de François Brucker.">
<meta property="og:description" content="Support de cours/td d’informatique de François Brucker.">
<link rel="canonical" href="/cours_informatique/cours/algorithme-code-theorie/algorithme/etude-voyageur-de-commerce.html">
<meta property="og:url" content="/cours_informatique/cours/algorithme-code-theorie/algorithme/etude-voyageur-de-commerce.html">
<meta property="og:site_name" content="cours d’informatique">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="étude : voyageur de commerce">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Support de cours/td d’informatique de François Brucker.","headline":"étude : voyageur de commerce","url":"/cours_informatique/cours/algorithme-code-theorie/algorithme/etude-voyageur-de-commerce.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">étude : voyageur de commerce</h1>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/algorithme-code-theorie/">Algorithme, code et théorie</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/algorithme/">algorithmie</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/algorithme/etude-voyageur-de-commerce.html">étude : voyageur de commerce</a></p>

  <p><strong>prérequis :</strong></p>

  <ul>
    <li><a href="/cours_informatique/cours/algorithme-code-theorie/algorithme/methode-gloutons.html">algorithmes gloutons</a></li>
    <li><a href="/cours_informatique/cours/algorithme-code-theorie/code/projet-exponentiation.html">projet : exponentiation</a></li>
  </ul>

</blockquote>

<p>Nous allons étudier ici un problème d’intérêt pratique nommé le <a href="https://fr.wikipedia.org/wiki/Probl%C3%A8me_du_voyageur_de_commerce">problème du voyageur de commerce</a>. On peut le formuler ainsi :</p>

<p><em>“un voyageur de commerce doit visiter $n$ villes dans la journée. Il veut donc partir de chez lui, parcourir toutes les villes puis revenir chez lui en ayant parcouru le minimum de distance”</em>.</p>

<p>L’étude de ce problème (ainsi que le problème associé traitant des graphes connexe) nous permettra d’utiliser des techniques de design d’algorithmes connus comme les algorithmes gloutons ou d’en découvrir d’autres comme la programmation dynamique.</p>

<p>En plus d’être des problèmes courants, ils sont très jolis algorithmiquement. On espère que vous aimerez la ballade.</p>

<h2 id="graphes-connexes">graphes connexes</h2>

<p>Les problèmes que nous allons étudier dans cette partie sont tous plus ou moins reliés à la notion de <strong>graphe</strong>. Nous n’allons pas faire un cours de graphe ici (une introduction est disponible <a href="/cours_informatique/cours/graphes/">ici</a> pour les personnes intéressées), juste donner quelques définitions et propriétés utiles :</p>

<blockquote class="note">
  <p>Un <strong>graphe</strong> $G = (V, E)$ est un couple où $E$ est un ensemble de sous-ensembles à 2 éléments de $V$. $E$ est l’ensemble des <strong>sommets</strong> de $G$ et $E$ l’ensemble des <strong>arêtes</strong> (on notera les arêtes $xy$ plutôt que ${x, y}$ pour rendre les notations plus digestes).</p>

  <p>Une <strong>valuation</strong> d’un graphe $G = (V, E)$ est une fonction $\omega: E \rightarrow \mathbb{R}^+$</p>
</blockquote>

<p>Nous allons en particulier nous intéresser aux problématiques de chemins et cycles dans un graphe, que l’on peut définir ainsi :</p>

<blockquote class="note">
  <p>Pour un graphe $G=(V, E)$ :</p>

  <ul>
    <li>un <strong>chemin</strong> est une suite de sommets $v_1,\dots, v_i, \dots, v_m$ tels que $v_iv_{i+1} \in E$ pour tout $1\leq i &lt; m$.</li>
    <li>un <strong>cycle</strong> est un chemin dont le premier et le dernier élément sont identiques.</li>
  </ul>

</blockquote>

<p>Enfin, nous introduisons la notion de connexité d’un graphe :</p>

<blockquote class="note">
  <p><strong>Problème de connexité d’un graphe</strong> :</p>

  <ul>
    <li>
<strong>Données</strong> :
      <ul>
        <li>un graphe $G = (V, E)$ à $n$ sommets</li>
      </ul>
    </li>
    <li>
<strong>question</strong> :
      <ul>
        <li>peut-on trouver un chemin entre $x$ et $y$, quelque soient $x, y \in V$ ?</li>
      </ul>
    </li>
  </ul>

</blockquote>

<p>Les graphes qui répondent OUI à cette question sont dit <strong>connexes</strong>.</p>

<p>Remarquez que le problème de connexité est équivalent au problème suivant (pour un graphe donné, les réponses aux deux problèmes sont identiques), alors qu’il semble pourtant plus simple :</p>

<blockquote class="note">
  <p><strong>Problème des chemins à partir d’un sommet</strong> :</p>

  <ul>
    <li>
<strong>Données</strong> :
      <ul>
        <li>un graphe $G = (V, E)$ à $n$ sommets</li>
        <li>un sommet $x \in V$</li>
      </ul>
    </li>
    <li>
<strong>question</strong> :
      <ul>
        <li>peut-on trouver un chemin entre $x$ et $y$, quelque soit $xy \in V$ ?</li>
      </ul>
    </li>
  </ul>

</blockquote>
<details><summary>preuve de l’équivalence</summary><div>
<p>Soit $G = (V, E)$ un graphe. Il est clair que s’il est connexe, le <em>problème des chemins à partir d’un sommet</em> est aussi vrai, $\forall x \in V$</p>

<p>Réciproquement, supposons que le <em>problème des chemins à partir d’un sommet</em> est vrai pour $G$ et un sommet $x^\star$</p>

<p>Soient alors $x \neq y \in V$. Il existe :</p>

<ul>
  <li>un chemin $u_1\dots u_k$ entre $x^\star$ et $x$ ($u_1 = x^\star$ et $u_k = x$)</li>
  <li>un chemin $v_1\dots v_l$ entre $y$ et $x^\star$ ($v_l = y$ et $v_l = x^\star$)</li>
</ul>

<p>On peut alors noter $i^\star$ le plus grand indice tel qu’il existe $j^\star$ avec : $u_{i^\star} = v_{j^\star}$. Comme $u_1 = v_l$, $i^\star$ existe.</p>

<p>La suite $v_1 \dots v_{j^\star} u_{i^\star+1} \dots u_k$ est alors un chemin entre $x$ et $y$.</p>

<p>Comme $x$ et $y$ ont été pris au hasard, on en conclut que $G$ est connexe.</p>

</div></details>

<p>La preuve de l’équivalence entre ces deux problèmes nous donne une propriété fondamentale de la connexité :</p>

<blockquote class="note">
  <p>Soit $G=(V, E)$ un graphe. S’il existe un chemin allant de $x$ à $y$ et un chemin allant de $y$ à $z$ dans $G$, alors il existe un chemin allant de $x$ à $z$.</p>
</blockquote>

<p>De là, la propriété suivante :</p>

<blockquote class="note">
  <p>Soit $G=(V, E)$ un graphe. Une <strong>composante connexe</strong> de $G$ est un sous-ensemble $A$ de sommets de $G$, maximal pour l’inclusion, tel que le graphe $G \vert_A = (A, \{ uv \in E \mid u, v \in A\})$, restriction de $G$ à $A$, est connexe.</p>

  <p>En ajoutant à $G$ une arête $xy$ où $x$ et $y$ sont dans des composantes connexes différentes, l’union de ces deux ensembles forme une unique composante connexe dans le nouveau graphe.</p>
</blockquote>

<p>Il faut donc un petit nombre d’arête à un graphe pour qu’il soit connexe :</p>

<blockquote class="note">
  <p>Si $G=(V, E)$ est un graphe connexe, alors $\vert E \vert \geq \vert V \vert -1$.</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>On le prouve par récurrence sur $\vert V \vert$. Si le graphe contient 1 sommet, la propriété est vérifiée. Supposons la propriété vrai pour $n-1$ sommet et considérons un graphe connexe à $n &gt; 1$ sommet.</p>

<p>Choisissons un sommet $x$ du graphe et supprimons le de $G$. La restriction de $G$ contient alors $k$ composantes connexes à $n_i$ sommets ($1 \leq i \leq k$), contenant (par hypothèse de récurrence) chacune au moins $n_i -1$ arêtes.</p>

<p>Comme $G$ était connexe, $x$ était relié à chacune des composantes connexes par une arête, c’est à dire au moins $k$. De là, le nombre d’arête de $G$ est :</p>

\[\vert E\vert \geq \sum_{i=1}^k (n_i -1) + k = \sum_{i=1}^k n_i = n - 1\]

</div></details>

<blockquote class="attention">
  <p>La réciproque est cependant fausse… Il existe des graphes $G=(V, E)$ non connexes ayant plus de $\vert V\vert -1$ arêtes.</p>
</blockquote>

<p>Ces diverses propriétés vont nous permettre de créer à coût min un réseau routier entre villes.</p>

<h2 id="relier-des-villes-entre-elles">Relier des villes entre elles</h2>

<p>Avant de voyager de ville en ville, commençons par nous mettre dans la peau d’une entreprise de travaux public dont le but est de construire un réseau routier :</p>

<blockquote class="note">
  <p><strong>réseau routier à coût min</strong></p>

  <ul>
    <li>
<strong>Données</strong> :
      <ul>
        <li>$V$, un ensemble de $n$ villes</li>
        <li>$c: V \times V \rightarrow \mathbb{R}^+$ une fonction de coût pour créer une route à double sens entre 2 villes.</li>
      </ul>
    </li>
    <li>
<strong>question</strong> :
      <ul>
        <li>donnez un graphe $G=(V, E)$ connexe telle que $\sum_{xy \in E} c(x, y)$  soit minimum parmi tous les graphes connexes.</li>
      </ul>
    </li>
  </ul>

</blockquote>

<p>On peut utiliser un algorithme glouton pour résoudre ce problème. Comme tout algorithme glouton, on peut le réduire à :</p>

<ol>
  <li>$E = \emptyset$</li>
  <li>pour chaque couple $xy$ : si le graphe $G=(V, E \cup {xy})$ a moins de composantes connexes que $G=(V, E)$ alors $E = E \cup { xy }$</li>
</ol>

<blockquote class="a-faire">
  <p>Combien d’arêtes aura $E$ à la fin de l’algorithme ?</p>
</blockquote>
<details><summary>solution</summary><div>
<p>Lorsque l’on ajoute une arête, on diminue de 1 le nombre de composantes connexes de $G$. Comme au départ il y en a $n$, $E$ aura exactement $n-1$ arêtes : ce sera un graphe connexe avec un nombre minimum d’arêtes.</p>
</div></details>

<p>Il reste deux inconnues :</p>

<ol>
  <li>dans quel ordre parcourir les différents couples ?</li>
  <li>comme vérifier efficacement qu’un graphe a moins de composantes connexes qu’un autre</li>
</ol>

<p>En répondant à la première question, on démontrera que notre algorithme glouton est optimal et en répondant à la seconde question, on le fera rapidement.</p>

<blockquote class="a-faire">
  <p>Montrer qu’en parcourant les arêtes par coût croissant, on obtient un graphe connexe de coût minimum.</p>
</blockquote>
<details><summary>solution</summary><div>
<p>Soit $E^\star$ une solution optimale et considérons le déroulement de l’algorithme étape par étape. On suppose que $E \neq E^\star$. On s’arrête alors à la <strong>première</strong> étape telle que soit :</p>

<ol>
  <li>l’algorithme rejette $xy$ alors qu’il est dans $E^\star$</li>
  <li>l’algorithme accepte $xy$ alors qu’il n’est pas $E^\star$</li>
</ol>

<p>On peut même sans perte de généralité considérer que parmi toutes les solutions optimales, $E^\star$ est celle qui coïncide le plus longtemps avec $E$.</p>

<p>Le premier cas est impossible car si l’algorithme rejette $xy$, c’est que cette arête ne diminue pas le nombre de composantes connexes, on pourrait donc la supprimer de $E^\star$ sans altérer le nombre de composantes connexes du graphe.</p>

<p>Dans le deuxième cas. Si $xy$ n’est pas dans $E^\star$ c’est qu’il existe un chemin allant de $x$ à $y$ dans $E^\star$ dont au moins une arête, disons $uv$ n’est pas dans $E$. Cette arête est de coût supérieur à celui de $xy$ ($xy$ est la première arête qui diffère entre $E$ et $E^\star$, donc on a pas encore vu $uv$ lorsque l’on examine $xy$).</p>

<p>L’ensemble $E^\star \backslash { uv } \cup { xy }$ serait alors encore connexe, mais de coût inférieur. Ceci est doublement impossible car on aurait une solution optimale qui coïnciderait plus longtemps avec $E$ que $E^\star$ ce qui est impossible par hypothèse.</p>

</div></details>

<blockquote class="a-faire">
  <p>Soit $G=(V, E)$. Supposons que l’on ait une fonction $f: V \rightarrow V$ telle que $f(x) = f(y)$ si et seulement si il existe un chemin entre $x$ et $y$.</p>

  <ul>
    <li>quand est-ce que $x$ est dans la même composante connexe que $y$ ?</li>
    <li>comment mettre à jour $f$ si on ajoute l’arête $xy$ à $G$ ?</li>
  </ul>
</blockquote>
<details><summary>algorithme</summary><div>
<p>Le sommet $x$ est dans la même composante connexe que $y$ si et seulement si $f(x) == f(y)$</p>

<p>La mise à jour se fait ainsi :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">c</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">V</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">f</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="n">c</span><span class="p">:</span>
        <span class="n">f</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</code></pre></div></div>

<blockquote class="attention">
  <p>la variable <code class="language-plaintext highlighter-rouge">c</code> est <strong>indispensable</strong>. Si on fait le fest <code class="language-plaintext highlighter-rouge">if f(z) == f(x):</code> à la place, une fois qu’on a examiné $x$, son $f$ aura changé et le test ne fonctionnera plus…</p>
</blockquote>

</div></details>

<blockquote class="a-faire">
  <p>Déduire de tout ce qu’on a fait précédemment un algorithme en $\mathcal{O}(n^2\log(n))$ permettant de résoudre le problème du <strong>réseau routier à coût min</strong> pour $n$ villes.</p>
</blockquote>
<details><summary>algorithme</summary><div>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def reseau(V, d):
    Soit E l'ensemble vide

    Soit F l'ensemble des couples (x, y) avec x ≠ y triés par ordre croissant
    pour chaque x de V:
        f(x) = x
    
    pour chaque xy de F:
        si f(x) ≠ f(y):
            ajoute xy à E
            c = f(x)
            pour chaque z de V:
                si f(z) == c:
                    f(z) = f(y)
            
    rendre E
</code></pre></div></div>

<p>Cet algorithme s’appelle l’algorithme de Kruskal dans le cadre de la théorie des graphes.</p>

<p>Sa complexité est la suivante :</p>

<ul>
  <li>tris de $\frac{n(n-1)}{2}$ couples : $\mathcal{O}(n^2\log(n^2)) = \mathcal{O}(n^2 \cdot2\cdot \log(n)) = \mathcal{O}(n^2\log(n))$</li>
  <li>assignation d’une valeur à $f$ pour chaque élément de $V$ : $\mathcal{O}(n)$</li>
  <li>parcours de tous les couples ($\frac{n(n-1)}{2}$ couples), et on met à jour $f$ en $\mathcal{O}(n)$ opérations. Comme on ne fait la modification de $f$ que si le nombre de composantes connexes diminue, c’est à dire au maximum $n$ fois,  la complexité totale de cette partie est en $\mathcal{O}(n^2)$</li>
</ul>

</div></details>

<h2 id="voyageur-de-commerce">Voyageur de commerce</h2>

<p>Il existe de nombreuses formalisation du problème du voyageur de commerce, nous allons en donner la version euclidienne qui est la plus utilisée car elle s’applique directement aux villes sur une carte (la distance routière entre 2 villes étant une distance) :</p>

<blockquote class="note">
  <p><strong>Voyageur de commerce (euclidien)</strong> : Soit $V$ un ensemble de $n$ éléments et $d: V \times V \rightarrow \mathbb{R}^+$ une distance (donc symétrique et respectant l’inégalité triangulaire) sur $V$.</p>

  <p>Donnez un ordre $v_1, \dots, v_n$ entre les villes minimisant :</p>

\[\sum_{i=1}^{i=n-1} d(v_i, v_{i+1}) + d(v_n, v_1)\]

</blockquote>

<h2 id="résolution-exacte">résolution exacte</h2>

<p>Nous n’allons pas chercher à résoudre par un algorithme polynomial le problème du voyageur de commerce, car c’est un problème NP-difficile et que beaucoup (tous ?) les informaticiens ont tenté au moins une fois de le faire sans y parvenir. En revanche, on peut trouver une solution exacte à notre problème en utilisant un algorithme exponentiel.</p>

<blockquote class="note">
  <p>Le problème du voyageur de commerce fait parti des problèmes NP-difficiles (une variante des problèmes <a href="https://fr.wikipedia.org/wiki/Probl%C3%A8me_NP-complet">NP complets</a>) : on ne connait pas d’algorithmes polynomial pour le résoudre.</p>

  <p>Ces problèmes sont théoriquement intéressants car ce sont des <strong>problèmes universels</strong> : si on sait résoudre un seul problème NP-difficile avec un algorithme polynomial, le même algorithme permettrait de résoudre non seulement tous les problèmes NP-difficiles mais également tous les problèmes résolubles par un ordinateur.</p>

</blockquote>

<h3 id="énumération-de-tous-les-cycles">énumération de tous les cycles</h3>

<p>On peut tenter d’énumérer tous les cycles possibles et en garder le minimum.</p>

<blockquote class="a-faire">
  <p>Combien de cycles différents faut-il examiner ?</p>

  <p>Donnez un algorithme pour les générer.</p>
</blockquote>
<details><summary>solution</summary><div>
<p>Comme le cycle doit passer par tous les sommets, je peux considérer que je commence toujours en $v_1$, il faut donc ensuite passer par $n-1$ autres villes, dans un ordre donné (il y en a $(n-1)!$).</p>

<p>De plus, un cycle peut être parcouru dans 2 sens différents, un cycle donné correspond ainsi à 2 ordres différents ($v_1v_2\dots v_n$ et $v_n v_{n-1}\dots v_2$ correspondent au même cycle parcouru dans un sens ou dans l’autre).</p>

<p>Il faut donc générer $\frac{(n-1)!}{2}$ cycles différents.</p>

<p>Pour ne générer qu’une seule fois chaque ordre on peut considérer tous les cycles :</p>

\[v_1v_{\sigma(1)}\dots v_{\sigma(n-1)}v_1\]

<p>Avec :</p>

<ul>
  <li>$\sigma$ une permutation de $[2..n]$</li>
  <li>$\sigma(1) &lt; \sigma(n-1)$</li>
</ul>

<p>On peut alors utiliser l’algorithme <code class="language-plaintext highlighter-rouge">permutation(T)</code> de l’<a href="/cours_informatique/cours/algorithme-code-theorie/algorithme/etude-melange.html#algo-toutes-permutations">étude sur les mélanges</a> :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
Cycles = [] 
de i allant de 2 à n-1:
    de j allant de i+1 à n:
        L = l'ensemble des permutation de la liste contenant tous les entiers de de 2 à n sans i ni j
        pour chaque P de L:
            ajouter [1] + [i] + L + [j] + [1] à Cycles
</code></pre></div></div>

</div></details>

<blockquote class="a-faire">
  <p>Ecrivez l’algorithme qui énumère tous les cycles et en garde le minimum.</p>

  <p>Montrez que sa complexité peut être estimée à $\mathcal{O}(n!)$.</p>

</blockquote>
<details><summary>solution</summary><div>
<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cycle_min = [1, 2, 3, ..., n, 1]
valeur_min = somme des couts de cycle_min

pour chaque cycle de n villes:
    si la valeur du cycle est plus petite strictement que valeur_min:
        cycle_min = cycle
        valeur_min = somme des couts de cycle_min
</code></pre></div></div>

<p>Il faut parcourir les $\frac{(n-1)!}{2}$ cycles et pour chacun calculer son cout (ce qui peut se faire en $\mathcal{O}(n)$ opérations). La complexité totale de l’algorithme est donc de $\mathcal{O}(n!)$ opérations.</p>

</div></details>

<h3 id="résolution-par-programmation-dynamique">résolution par programmation dynamique</h3>

<p>Générer tous les cycles prend énormément de temps. On va de plus refaire plein de fois les mêmes erreurs (faire plein de fois Brest -&gt; Marseille -&gt; Rennes -&gt; Paris par exemple alors qu’on peut localement faire bien mieux) : on va utiliser une méthode de programmation appelé <strong>programmation dynamique</strong> qui va nous permettre de factoriser des résultats.</p>

<blockquote class="note">
  <p>La <a href="https://fr.wikipedia.org/wiki/Programmation_dynamique"><strong>programmation dynamique</strong></a> est une méthode de création d’algorithme basée sur le fait qu’une solution minimale est composée de sous-solutions elles-mêmes minimales.</p>
</blockquote>

<p>L’exemple classique donné pour expliquer la programmation dynamique est : si un chemin $\mathcal{C}$ le plus court entre 2 points $A$ et $B$ passe par le point $C$, alors le chemin de $A$ vers $C$ et le chemin de $C$ vers $B$ dans $\mathcal{C}$ sont tous deux minimaux (s’il existait par exemple un chemin plus court entre $A$ et $C$ il suffirait de l’emprunter et $\mathcal{C}$ ne serait plus minimal).</p>

<p>Le principe de création d’algorithme utilisant la programmation dynamique est alors le suivant : on essaie de créer des solution optimales avec des solutions partielles elles-même optimales.</p>

<p>Ceci se concrétise souvent par une équation récurrente à vérifier. Dans le cas du voyageur de commerce à $n$ villes $(v_i)_{1\leq i \leq n}$ et avec $c$ comme fonction de coût, on peut construire un algorithme de programmation dynamique en remarquant que :</p>

<blockquote class="note">
  <p>Soit $I$ un sous ensemble de $[1 \mathrel{ {.}\,{.} } n]$ contenant $1$, et $j\notin I$.</p>

  <p>Si l’on note $C(I, j)$ le coût d’un plus court chemin allant de $v_1$ à $v_j$ en utilisant que des villes de ${ v_i \mid i \in I }$, on peut écrire :</p>

\[C(I, j) = \min_{k \in I \backslash \{ 1 \}} (C(I \backslash \{ k\}, k) + c(v_k, v_j))\]

</blockquote>

<p>L’équation ci-dessous nous donne un moyen de construire itérativement des chemins minimaux jusqu’à arriver au calcul final :</p>

\[\min_{k \in [1 \mathrel{ {.}\,{.} } n] \backslash \{ 1 \}} (C([1 \mathrel{ {.}\,{.} } n] \backslash \{ k\}, k) + c(v_k, v_1))\]

<p>Qui est le coût minimal du voyageur de commerce.</p>

<blockquote class="a-faire">
  <p>En supposant que l’on connaisse $C(I, j)$ pour tous les sous-ensembles $I$ à $k$ éléments et tous les $j$, écrivez l’algorithme qui calcule tous les $C(I’, j)$ pour tous les sous-ensembles $I’$ à $k+1$ éléments.</p>
</blockquote>
<details><summary>solution</summary><div>
<p>On a :</p>

\[C(I', j) =  \min_{k \in I' \backslash \{ 1 \}} (C(I' \backslash \{ k\}, k) + c(v_k, v_j))\]

<p>Comme j n’est pas dans $I’$, ceci est équivalent à :</p>

\[C(I', j) = \min_{I \cup \{ \{ k\}\} = I'} (C(I, k) + c(v_k, v_j))\]

<p>On peut donc écrire :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    pour chaque I de E:
        pour chaque l de [1..n] qui n'est pas dans I:
            pour chaque j de [1..n] qui n'est pas dans I et qui n'est pas l:                        
                m = C(I, l) + c(v_l, v_j)
                si C(I + {l}, j) n'existe pas:
                    C(I + {l}, j) = m
                sinon:
                    C(I + {l}, j) = min(C(I + {l}, j), m)
</code></pre></div></div>

<p>La complexité de cet algorithme est en $\mathcal{O}((n-k)(n-k-1))$ pour chaque élément de $E$ et comme il y en a $2^k$ éléments, la complexité totale de cet algorithme est :
\(\mathcal{O}(2^k(n-k)^2)\)</p>
</div></details>

<blockquote class="a-faire">
  <p>Ecrivez l’algorithme de résolution du problème du voyageur de commerce itérativement en partant de l’ensemble $E = {{1}}$.</p>

  <p>Montrez que sa complexité peut être estimée à $\mathcal{O}(n^22^n)$.</p>
</blockquote>
<details><summary>solution</summary><div>
<p>Il suffit d’appliquer itérativement l’algorithme précédent jusqu’à obtenir $C(I, k)$ pour tous les sous-ensembles à $n-1$ éléments contenant 1.</p>

<p>La complexité totale est donc : $\mathcal{O}(\sum_{k=1}^{n-1}2^k \cdot (n-k)^2) = \mathcal{O}(n^22^n)$</p>

</div></details>

<p>Cette complexité est importante, mais tout de même plus petite que l’énumération de tous les cycles : on ne garde qu’une solution pour un sous-ensemble donné et pas tous les cycles possibles.</p>

<h2 id="heuristiques">heuristiques</h2>

<p>Les deux algorithmes exacts sont impossibles à mettre en pratique pour un nombre de villes plus grand que 10 environ. Il y a tout simplement trop d’opérations à effectuer.</p>

<p>Nous allons montrer ici quelques algorithmes approchés (appelées <a href="https://fr.wikipedia.org/wiki/Heuristique">heuristiques</a>) permettant de trouver une solution acceptable au problème du voyageur de commerce.</p>

<h3 id="aléatoire">aléatoire</h3>

<blockquote class="a-faire">
  <p>Créez un algorithme permettant de résoudre le problème du voyageur de commerce en donnant un cycle aléatoire.</p>
</blockquote>

<p>Cet algorithme n’est pas du tout performant, mais va servir de base à d’autres algorithmes.</p>

<h3 id="gloutons">gloutons</h3>

<blockquote class="a-faire">
  <p>Créez un algorithme glouton permettant de résoudre le problème du voyageur de commerce.</p>

  <p>Montrez qu’il existe des cas où votre algorithme glouton ne trouvera pas la solution.</p>
</blockquote>
<details><summary>solution</summary><div>
<p>On commence par une ville au hasard, puis on prend à chaque étape la ville la pus proche de la dernière ville choisie.</p>

<p>Il ne sera jamais optimal pour le graphe suivant :</p>

<p><img src="./assets/voyageur_commerce_1_2.png" alt="croisements" style="margin: auto;display: block;"></p>

</div></details>

<h2 id="raffinage-de-solutions">raffinage de solutions</h2>

<p>L’algorithme glouton et l’algorithme aléatoire ne produisent pas vraiment de bons résultats. L’idée est alors :</p>

<ol>
  <li>de relancer plusieurs fois l’algorithmes (en particulier celui qui rend des cycles aléatoires) et de prendre la meilleure solution</li>
  <li>de raffiner la solution pour en trouver une meilleure</li>
</ol>

<p>Nous allons montrer deux idées pour mettre en œuvre la deuxième idée. Ces méthodes sont génériques et peuvent être appliquées à de nombreux problèmes, on les appelles des <a href="https://fr.wikipedia.org/wiki/M%C3%A9taheuristique">méta-heuristiques</a>, et dans notre cas font toutes deux parties des méthodes dites de <a href="https://fr.wikipedia.org/wiki/M%C3%A9taheuristique">recherche locale</a> où l’on optimise localement une solution admissible.</p>

<p>Ces procédures d’optimisation dépendent de paramètres qui dépendent des données : il faut donc en essayer plusieurs…</p>

<h3 id="2-opt">2-opt</h3>

<p>La méthode couramment utilisée est appelée <a href="https://fr.wikipedia.org/wiki/2-opt">2-opt</a> :</p>

<blockquote class="note">
  <p>L’algorithme 2-opt consiste à itérativement modifier localement une solution en échangeant 2 arêtes du cycle $c$ à optimiser.</p>

  <ol>
    <li>on commence par choisir une ville $v_1$ comme début du cycle : $c = v_1 \dots v_n v_1$</li>
    <li>on choisit ensuite une ville $v_i$ telle que $2 &lt; i &lt; n$</li>
    <li>on considère le cycle $c’ = v_1v_{i} v_{i-1}\dots v_{2} v_{i+1}\dots v_n v_1$</li>
    <li>si le coût de $c’$ est inférieure strictement au coût de $c$ on le conserve, sinon on le rejette et on conserve $c$.</li>
  </ol>

</blockquote>

<p>L’algorithme 2-opt permet de <em>décroiser</em> localement les cycles, comme dans l’exemple suivant :</p>

<p><img src="./assets/voyageur-1.png" alt="croisements" style="margin: auto;display: block;"></p>

<p>On peut alors exécuter cet algorithme de 2 façons différentes :</p>

<ul>
  <li>on regarde exhaustivement toutes les possibilités et on continue tant qu’il existe une amélioration possible (tant que tous les couples n’ont pas été examinés sans aucune amélioration).</li>
  <li>on exécute le 2-opt un nombre fixé de fois pour des couples pris aléatoirement.</li>
</ul>

<p>L’inconvénient de cette méthode est qu’elle peut durer longtemps sans garantir que l’optimum local trouvé soit pertinent. C’est pourquoi on a coutume de favoriser la seconde façon de faire.</p>

<h3 id="recuit-simulé">recuit simulé</h3>

<p>Le problème de n’accepter la modification que lorsque l’on améliore la solution est que l’on est souvent bloqué dans des minima locaux :</p>

<p><img src="./assets/recuit-1.png" alt="minimum local" style="margin: auto;display: block;"></p>

<p>Pour trouver la solution en ne faisant que des changements locaux, il faut parfois accepter une solution moins bonne de temps en temps :</p>

<p><img src="./assets/recuit-2.png" alt="solution moins bonne" style="margin: auto;display: block;"></p>

<p>pour trouver le minimum global :</p>

<p><img src="./assets/recuit-3.png" alt="solution moins bonne" style="margin: auto;display: block;"></p>

<p>Il existe plusieurs techniques pour faire cela, la méthode du <a href="https://fr.wikipedia.org/wiki/Recuit_simul%C3%A9">recuit simulé</a> accepte une solution moins bonne avec une probabilité qui va diminuer avec le nombre d’itérations.</p>

<p>L’algorithme du recuit simulé appliqué au voyageur de commerce est alors (avec <code class="language-plaintext highlighter-rouge">P()</code> un réel aléatoire entre 0 et 1) :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
c = cycle initial
cycle_min = c

pour k allant de 1 à n:
    c' = 2-opt-aléatoire(c)
    si le coût de c' est inférieur au cout de c ou si P() ≤ P_k:
        c = c'
    
    si le cout de c est strictement inférieur au cout de cycle_min:
        cycle_min = c

rendre cycle_min
</code></pre></div></div>

<p>Dans le recuit simulé, la probabilité de choisir une solution moins bonne est égale à :</p>

\[P_k = e^\frac{-(C'-C)}{T_k}\]

<p>Où :</p>

<ul>
  <li>$C’$ et $C$ sont les cout du circuit $c’$ et $c$ respectivement</li>
  <li>$T_k = \lambda T_{k-1}$ avec $\lambda &lt; 1$</li>
</ul>

<h2 id="algorithmes-à-performances-garanties">algorithmes à performances garanties</h2>

<p>Pour résoudre le problème du voyageur de commerce on a pour l’instant vu deux méthodes :</p>

<ul>
  <li>un calcul optima, mais qui prend trop de temps pour être utilisé en pratique</li>
  <li>un calcul par heuristique, mais qui rend une solution dont on ne sait pas si elle est correcte ou non</li>
</ul>

<p>Il existe une troisième voie, qui consiste à créer des algorithmes qui vont trouver une solution dont on peut garantir la performance.</p>

<p>On va montrer dans ce qui suit que l’on peut forger une solution qui sera au pire 2 fois moins bonne que la solution optimale. On ne rentrera cependant pas dans les détails algorithmiques de cet algorithme qui nécessiterait un cours supplémentaire de théorie des graphes.</p>

<p>Le principe est le suivant :</p>

<ol>
  <li>on crée le réseau routier minimum</li>
  <li>on voyage sur le réseau routier minimum</li>
  <li>on optimise pour ne pas repasser 2 fois par la même ville.</li>
</ol>

<p>Pour voir ce qu’il se passe regardons ce qu’il se passe avec l’exemple suivant :</p>

<p><img src="./assets/voyageur-2-opti-1.png" alt="les villes" style="margin: auto;display: block;"></p>

<p>Créons le réseau routier :</p>

<p><img src="./assets/voyageur-2-opti-2.png" alt="le réseau" style="margin: auto;display: block;"></p>

<p>On parcours ensuite toute les villes sur ce réseau routier (on utilise un <a href="https://fr.wikipedia.org/wiki/Algorithme_de_parcours_en_profondeur">parcours en profondeur</a> c’est à dire qu’on part le plus loin possible avant de revenir)</p>

<p><img src="./assets/voyageur-2-opti-3.png" alt="le parcours sur le réseau" style="margin: auto;display: block;"></p>

<p>Puis on supprime les villes par lesquelles on est déjà passé pour créer le cycle final :</p>

<p><img src="./assets/voyageur-2-opti-4.png" alt="cycle final" style="margin: auto;display: block;"></p>

<p>Ce qui est beau, c’est que la longueur de ce cycle est au pire 2 fois plus longueur que la longueur du cycle optimal.</p>

<blockquote class="a-faire">
  <p>Prouvez-le.</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Le cycle optimal est un graphe connexe. Il est donc de cout plus grand que la somme de toutes les arêtes de notre réseau routier.</p>

<p>Lorsque l’on suit le parcours sur le réseau routier, on passe exactement 2 fois par chaque arête, le coût de ce parcours est donc exactement 2 fois le coût du réseau qui est plus petit ou égal à 2 fois le coût du cycle minimal.</p>

<p>Enfin, le coût du cycle final ne peut être plus grand que le coût du parcours sur le réseau routier car les distances respectent l’inégalité triangulaire.</p>

</div></details>

<blockquote>
  <p>On peut faire mieux en utilisant l’<a href="https://fr.wikipedia.org/wiki/Algorithme_de_Christofides">algorithme de Christofides</a> qui est au pire 1.5 fois plus long que la longueur minimale,  mais cela nous mènerait encore trop loin. Mais jetez-y un coup d’oeil si cela vous intéresse, l’algorithme est superbe et combine de nombreuses techniques informatiques et de théorie des graphes en un tout élégant et performant.</p>
</blockquote>

<h2 id="code">code</h2>

<h3 id="génération-de-villes">génération de villes</h3>

<p>Nous allons ici générer des villes aléatoires dans un carré unité.</p>

<blockquote class="a-faire">
  <p>Créez un fonction <code class="language-plaintext highlighter-rouge">villes_aleatoires(n)</code> qui rend un tableau de <code class="language-plaintext highlighter-rouge">n</code> couples <code class="language-plaintext highlighter-rouge">(x, y)</code> où <code class="language-plaintext highlighter-rouge">x</code> et <code class="language-plaintext highlighter-rouge">y</code> sont des nombres aléatoires entre 0 et 1.</p>
</blockquote>

<p>En utilisant ce que vous avez vu dans le <a href="/cours_informatique/cours/algorithme-code-theorie/code/projet-exponentiation.html">projet : exponentiation</a> :</p>

<blockquote class="a-faire">
  <p>Représentez graphiquement avec matplotlib la liste de villes crée par la fonction <code class="language-plaintext highlighter-rouge">villes_aleatoires(n)</code>.</p>
</blockquote>

<h3 id="réseau-routier">réseau routier</h3>

<blockquote class="a-faire">
  <p>A partir d’une liste de villes (représentées chacune par un couple de coordonnées) rendez une liste d’arêtes représentant le réseau routier de valuation minimal reliant toutes les villes entre elles</p>
</blockquote>
<details><summary>indice d’implémentation</summary><div>
<p>Vous pourrez utiliser un dictionnaire pour gérer la marque <code class="language-plaintext highlighter-rouge">f(x)</code> associée à chaque ville.</p>

<p>Pour le tri des arêtes selon leur valuation (ici la distance), vous pourrez utiliser l’argument <code class="language-plaintext highlighter-rouge">key</code> de la méthode <code class="language-plaintext highlighter-rouge">sort</code> des listes.</p>

<p>La commande <code class="language-plaintext highlighter-rouge">l.sort(key=f)</code> permet de trier la liste <code class="language-plaintext highlighter-rouge">l</code>  par rapport à l’ordre $x &lt; y$ si  $f(x) &lt; f(y)$.</p>

<p>Le code suivant est un exemple concret de comment tout ça fonctionne :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ma_liste</span> <span class="o">=</span> <span class="p">[</span><span class="s">"1001"</span><span class="p">,</span> <span class="s">"0011111"</span><span class="p">,</span> <span class="s">"000"</span><span class="p">]</span>

<span class="n">ma_liste</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">ma_liste</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nombre_de_1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="s">"1"</span><span class="p">)</span>

<span class="n">ma_liste</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">nombre_de_1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">ma_liste</span><span class="p">)</span>
</code></pre></div></div>

</div></details>

<p>Une fois l’algorithme crée et testé vous pourrez :</p>

<blockquote class="a-faire">
  <p>Représentez graphiquement avec matplotlib le réseau routier d’une liste de villes.</p>
</blockquote>

<h3 id="glouton">glouton</h3>

<blockquote class="a-faire">
  <p>Créez l’algorithme glouton qui permet de créer de proche en proche un cycle.</p>
</blockquote>

<p>Une fois crée et testé vous pourrez :</p>

<blockquote class="a-faire">
  <p>Représentez graphiquement avec matplotlib le cycle issu de l’algorithme glouton pour une liste de villes.</p>
</blockquote>

<h3 id="recuit-simulé-1">recuit simulé</h3>

<blockquote class="a-faire">
  <p>Implémentez l’algorithme du recuit simulé qui , à partir d’un cycle aléatoire le raffine pendant $k$ itérations.</p>
</blockquote>

<h3 id="algorithme-exact">algorithme exact</h3>

<blockquote class="a-faire">
  <p>Implémentez l’algorithme exact qui, à partir d’une liste de ville rend le cycle optimal.</p>
</blockquote>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique de François Brucker.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
