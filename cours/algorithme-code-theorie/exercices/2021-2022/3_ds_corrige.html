<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>DS | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="DS">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique de François Brucker.">
<meta property="og:description" content="Support de cours/td d’informatique de François Brucker.">
<link rel="canonical" href="/cours_informatique/cours/algorithme-code-theorie/exercices/2021-2022/3_ds_corrige.html">
<meta property="og:url" content="/cours_informatique/cours/algorithme-code-theorie/exercices/2021-2022/3_ds_corrige.html">
<meta property="og:site_name" content="cours d’informatique">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="DS">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Support de cours/td d’informatique de François Brucker.","headline":"DS","url":"/cours_informatique/cours/algorithme-code-theorie/exercices/2021-2022/3_ds_corrige.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">DS</h1>Auteurs :
      <ul>
      
        <li><span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">François Brucker</span></span></li>
      
      </ul>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/algorithme-code-theorie/">Algorithme, code et théorie</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/exercices/">exercices</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/exercices/2021-2022/">2021-2022</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/exercices/2021-2022/3_ds_corrige.html">sucorrigéjet DS</a></p>
</blockquote>

<h2 id="introduction">Introduction</h2>

<blockquote class="tbd">
  <p>ventilation des notes</p>

</blockquote>

<h3 id="remarques">remarques</h3>

<ul>
  <li>les 3 exercices doivent être faisable en 2h.</li>
  <li>optimisez votre temps. Si vous bloquez passez à un autre exercice. Les premières questions sont souvent plus faisables que les dernières (Si vous prenez une copie par exercice cela permet de revenir à une exercice plus tard sans perdre le correcteur)</li>
</ul>

<h3 id="erreurs-communes">erreurs communes</h3>

<ol>
  <li>question 1
    <ul>
      <li>1.1 rogntujdu ! Les 3 qui sont tout aussi importants l’un que l’autre. Seuls 2 personnes ont eu juste.</li>
      <li>1.2.2 : peu de bonnes solutions. On démontre en &gt;2 temps :
        <ol>
          <li>on prouve une borne minium</li>
          <li>on montre qu’elle est atteinte pour un algorithme qu’on exhibe.</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>question 2
    <ul>
      <li>votre algorithme de retournement fait souvent identité (il retourne 2 fois et fait donc un virage à 360 degrés). Il faut s’arrêter à la moitié.</li>
      <li>il y a 2 paramètres à l’algorithme de retournement : la liste et la position de la spatule</li>
    </ul>
  </li>
  <li>question 3
    <ul>
      <li>
<code class="language-plaintext highlighter-rouge">T[T[0]], T[0] = T[0], T[T[0]]</code> et pas le contraire. C’est une erreur subtile que je n’ai pas compté. C’est que l’écriture ne se fais pas en même temps. n commence par celui de gauche.</li>
    </ul>
  </li>
</ol>

<h2 id="question-1">Question 1</h2>

<h3 id="11">1.1</h3>

<p>Les <strong>trois</strong> parties sont tout aussi importantes les unes que les autres !</p>

<ol>
  <li>sans programme principal, ça ne sert à rien de coder. En revanche, un programme principal ne fait rien sans les fonctions</li>
  <li>sans fonctions, le programme ne fait rien. En revanche, on ne sait pas si les fonctions sont sans erreurs sans les tests</li>
  <li>un test n’a d’intérêt que si la fonction est utilisée pour autre chose. En revanche on ne sait pas si le code est sans erreur sans les tests</li>
</ol>

<h3 id="12">1.2</h3>

<h4 id="121">1.2.1</h4>

<ul>
  <li>la complexité maximale d’un algorithme est le nombre maximum d’opérations dont aura besoin l’algorithme pour se terminer pour une entrée de taille donnée</li>
  <li>la complexité minimale d’un algorithme est le nombre minimum d’opérations dont aura besoin l’algorithme pour se terminer pour une entrée de taille donnée</li>
  <li>la complexité en moyenne d’un algorithme est le nombre moyenne d’opérations dont aura besoin l’algorithme pour se terminer pour toutes les entrées d’une taille donnée</li>
  <li>la complexité d’un problème est le minimum de la complexité maximale pour tous les algorithmes le résolvant</li>
</ul>

<h4 id="122">1.2.2</h4>

<p>Pour connaitre la complexité du problème du tri, on procède en 2 temps :</p>

<ol>
  <li>on cherche une borne minimum de complexité (maximale) pour tout algorithme résolvant le problème du tri</li>
  <li>on exhibe un algorithme ayant cette borne min comme complexité.</li>
</ol>

<p>Un algorithme de tri devra, pour un tableau de taille $n$, distinguer parmi $n!$ cas (toutes les permutations possibles du tableau) pour rendre le tableau triée. Sa complexité sera donc au minimum de $\mathcal{O}(\ln(n!)) = \mathcal{O}(n\ln(n))$.</p>

<p>Comme le tri fusion vu en cours est de cette complexité on en déduit que la complexité du problème du tri d’un tableau de taille $n$ est en $\mathcal{O}(n\ln(n))$.</p>

<h2 id="questions-2">Questions 2</h2>

<p>Le <a href="https://fr.wikipedia.org/wiki/Tri_de_cr%C3%AApes">tri de crêpes</a> est un problème originellement étudié par Bill Gates (oui, lui même) et Chritos Papadimitriou (un grand nom de l’informatique théorique) dans <a href="https://www.sciencedirect.com/science/article/pii/0012365X79900682?via%3Dihub">un papier de decrete mathematics</a>. Il y démontre une borne supérieure bien meilleure que celle que l’on vous fait calculer. Mais lisez ce papier, il est facile à comprendre.</p>

<h3 id="21">2.1</h3>

<p>Pour les $n$ crêpes, on peut les ordonner par taille de la plus petite à la plus grande. On peut donc associer à chaque crêpe son ordre - 1 dans cet ordre : les crêpes peuvent être vues comme un nombre entre 0 et $n-1$.</p>

<p>La pile de crêpes est alors un tableau $T$ de taille $n$, la plus haute en première position, chaque crêpe étant représenté par sa position moins 1 dans l’ordre des tailles. Ce tableau est une permutation de $[0 \mathrel{ {.}\,{.} } n-1]$</p>

<p>Ordonner les crêpes par taille est alors équivalent à ordonner le tableau $T$ par ordre croissant.</p>

<p>L’opération de retournement revient à retourner le début du tableau T.</p>

<h3 id="22">2.2</h3>

<p>Il faut 2 paramètres pour l’algorithme de retournement : la liste et la position de la spatule</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">retournement</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">spatule</span><span class="p">):</span>
    <span class="n">T2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spatule</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">T2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spatule</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">)):</span>
        <span class="n">T2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">T2</span>
</code></pre></div></div>

<p>L’algorithme est constitué de deux boucles for, la première de $\mbox{spatule}+1$ itérations et la seconde de $\mid T \mid - \mbox{spatule}-1$ opérations. Toutes les autres opérations sont en $\mathcal{O}(1)$, l’algorithme s’arrête bien et est de complexité $\mathcal{O}(\mid T \mid)$.</p>

<p>La première boucle for effectue le retournement du tableau $T[:r+1]$, c’est à dire des $r+1$ premières crêpes de la pile (de l’indice 0 à $r$ inclus), la seconde ajoute dans le même ordre la fin de la pile.</p>

<h3 id="23">2.3</h3>

<h4 id="231">2.3.1</h4>

<p>Pour un tableau $T$, <code class="language-plaintext highlighter-rouge">retournement(T, r)</code> retourne les $r+1$ premiers éléments du tableau, et donc $T[r]$  avant l’opération de retournement se retrouve en $T[0]$ après le retournement. On peut donc placer n’importe quel élément de la pile en 1ère position.</p>

<p>De même l’élément en $T[0]$ avant retournement se retrouve en position $T[r]$ après le retournement <code class="language-plaintext highlighter-rouge">retournement(T, r)</code> : on peut placer l’élément d’indice 0 du tableau en n’importe quelle position en 1 opération de retournement.</p>

<h4 id="232">2.3.2</h4>

<p>Comme les tailles sont des entiers de 0 à $n-1$, on connait le maximum du tableau. On a écrit le code de l’algorithme en python mais on aurait tout aussi bien pu l’écrire en pseudo-code</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tri</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>  <span class="c1">#  de t=n-1 à t=0
</span>        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>                     <span class="c1"># trouve l'indice i tel que T[i] == t
</span>        <span class="k">while</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">T</span> <span class="o">=</span> <span class="n">retournement</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">retournement</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">T</span>
</code></pre></div></div>

<ol>
  <li>complexité en nombre de retournements : $\mathcal{O}(n)$ itérations dans la boucle for, et deux retournements par itérations.</li>
  <li>preuve de l’algorithme par invariant de boucle : <em>à la fin d’une itération de la boucle for, $T[i] = i$ pour tout $i \geq t$.</em>. Sa preuve est immédiate car elle découle de la question 2.3.1</li>
</ol>

<h5 id="233">2.3.3</h5>

<p>On note $n$ la taille de la liste.</p>

<p>On pourrait croire que notre algorithme de tri en $\mathcal{O}(n)$ retournement est inférieur à la complexité du tri qui est de $\mathcal{O}(n\ln(n))$ ($n &lt; n \ln(n)$ si $n &gt; e$).</p>

<p>Mais l’opération de retournement est en $\mathcal{O}(n)$ opérations. Donc notre algorithme de tri est en réalité en $\mathcal{O}(n^2)$ opérations, ce i est plus grand que la complexité du problème du tri. C’est cohérent.</p>

<h3 id="24">2.4</h3>

<h4 id="241">2.4.1</h4>

<p>Notre algorithme est en $\mathcal{O}(\mid T \mid)$ retournement, c’est donc une borne maximum du problème du retournement de crêpes.</p>

<h4 id="242">2.4.2</h4>

<ol>
  <li>une adjacence étant un un couple $(i, i+1)$ tel que $\mid T[i] - T[i+1] \mid &gt; 1$,il faut que $0 \leq i &lt; \mid T \mid -1 = n -1$</li>
  <li>Si $(i-1, i)$ et $(i, i+1)$ sont deux adjacences, alors :
    <ol>
      <li>prouvons $n-1$ adjacences implique trié.
        <ul>
          <li>soit $T[i-1] &lt; T[i]$ et donc $T[i] = T[i-1] - 1$. De là on ne peut avoir $T[i] &gt; T[i+1]$ car sinon $T[i+1] = T[i-1]$ ce qui est impossible. On a donc $T[i-1] &lt; T[i] &lt; T[i+1]$</li>
          <li>soit $T[i-1] &gt; T[i]$ et un raisonnement similaire au précédent nous permet de montrer que $T[i-1] &gt; T[i] &gt; T[i+1]$.</li>
        </ul>

        <p>Donc s’il y a $n-1$ adjacences, $T$ est trié par ordre croissant ou par ordre décroissant.</p>
      </li>
      <li>réciproquement, si la liste est triée avec le plus grand élément à la fin, il y a bien $n-1$ adjacences.</li>
    </ol>
  </li>
  <li>un retournement <code class="language-plaintext highlighter-rouge">retournement(T, r)</code> ne peut changer les adjacences pour $i &lt; r - 1$ (si (i, i+1) est une adjacence avant retournement, alors $(r-i-1, r-i)$  est une adjacence après retournement), et pour $i \geq r$. La seule adjacence qui peut être modifiée est $(r-1, r)$.</li>
  <li>L’ordre $[n-2, n-4, \dots, (1\mbox{ ou }0\mbox{ selon la parité de }n), n-1, n-3, \dots, 0\mbox{ ou }1\mbox{ selon la parité de }n]$ a bien 0 adjacences et si $n \geq 4$.</li>
</ol>

<p>Pour trier la pile il faut au moins autant de retournements que de paires non adjacentes plus 1 pour mettre l’élément $n-1$ en fin de liste qui est une opération qui ne change pas le nombre d’adjacences.</p>

<h2 id="question-3">Question 3</h2>

<h3 id="31">3.1</h3>

<h4 id="311">3.1.1</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">echange</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">T</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="312">3.1.2</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="32">3.2</h3>

<p>A la fin d’une itération de l’algorithme on a $a = T[a]$ avec $a \neq 0$. L’indice $a$ ne changera plus jamais tout au long de l’algorithme, donc $L(T)$ a un 1 de plus si $0 \neq T[0]$ à la fin de l’itération.</p>

<p>Lors de la dernière itération, comme $a= T[a]$ et $0 = T[0]$, $L(T)$ augmente de deux 1.</p>

<h4 id="33">3.3</h4>

<p>Comme le nombre de 1 de $L(T)$ augmente strictement à chaque étape et qu’il ne peut y a voir que $n$ 1 à la fin : l’algorithme s’arrête bien au bout d’au pire $n$ itérations.</p>

<h4 id="34">3.4</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">tri</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">)):</span>
        <span class="k">while</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">T</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
</code></pre></div></div>

<p>On ajoute une boucle qui parcours tous les éléments et qui fait les permutations si $T[i] \neq i$.</p>

<p>La complexité est bien en $\mathcal{O}(n)$ car à chaque itération de la boucle while $L(T)$ augmente strictement : on ne peut rentrer dans la boucle while qu’au pire $n$ fois.</p>

<h4 id="35">3.5</h4>

<p>Ici on doit trier une permutation des n premiers entiers. C’est bien plus restrictif que le problème du tri où les éléments à trier peuvent avoir des égalités, et des éléments non consécutifs.</p>

<p>En fait, l’algorithme le plus simple qui trie les $n$ premiers entiers est :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">tri</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">T</span><span class="p">)))</span>
</code></pre></div></div>

<p>Qui est bien en $\mathcal{O}(n)$…</p>

<p>Notre problème est un <strong>sous-problème</strong> du problème du tri et pas le problème général du tri : il peut admettre une complexité plus faible.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique de François Brucker.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
