<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>fonction de hash | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="fonction de hash">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique de François Brucker.">
<meta property="og:description" content="Support de cours/td d’informatique de François Brucker.">
<link rel="canonical" href="/cours_informatique/cours/algorithme-code-theorie/theorie/fonctions-hash.html">
<meta property="og:url" content="/cours_informatique/cours/algorithme-code-theorie/theorie/fonctions-hash.html">
<meta property="og:site_name" content="cours d’informatique">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="fonction de hash">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Support de cours/td d’informatique de François Brucker.","headline":"fonction de hash","url":"/cours_informatique/cours/algorithme-code-theorie/theorie/fonctions-hash.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">fonction de hash</h1>
  </header>

  <div class="post-content">
    <p>Les fonctions de hachage. De la définition mathématique à son utilité en informatique.</p>

<blockquote class="chemin">
  <p><a href="/cours_informatique/cours/algorithme-code-theorie/">Algorithme, code et théorie</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/theorie/">théorie</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/theorie/fonctions-hash.html">fonctions de hash</a></p>

  <p><strong>prérequis :</strong></p>

  <ul>
    <li><a href="/cours_informatique/cours/algorithme-code-theorie/theorie/fonctions.html">fonctions</a></li>
  </ul>

</blockquote>

<h2 id="définition">définition</h2>

<p>Dans notre cas, en informatique, on peut définir une <a href="https://fr.wikipedia.org/wiki/Fonction_de_hachage">fonction de hachage</a> $f$ comme étant :</p>

<blockquote class="note">
  <p>Une <strong>fonction de hachage</strong> est une fonction $f$ :</p>

\[f: \mathbb{N} \rightarrow [0 \mathrel{ {.}\,{.} } m]\]

  <p>où $m$  est un entier positif.</p>
</blockquote>

<p>Une définition alternative, également souvent utilisée, est :</p>

<blockquote class="note">
  <p>Une <strong>fonction de hachage</strong> est une fonction $f$ qui associe à tout mot de $\{0, 1\}^\star$ un mot de $\{0, 1\}^k$.</p>

  <p>où $k$  est un entier positif.</p>
</blockquote>

<p>Enfin, comme tout en informatique est codé comme une suite de 0 et de 1, une fonction de hachage peut ainsi être vue comme :</p>

<blockquote>
  <p>Une <strong>fonction de hachage</strong> est une fonction qui associe à tout <strong>objet</strong> soit :</p>

  <ul>
    <li>un entier entre 0 et $m$</li>
    <li>un mot de $\{0, 1\}^k$</li>
  </ul>

</blockquote>

<p>En python par exemple, on peut utiliser la fonction <a href="https://docs.python.org/fr/3/library/functions.html?highlight=hash#hash"><code class="language-plaintext highlighter-rouge">hash</code></a> :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nb">hash</span><span class="p">(</span><span class="s">"du texte"</span><span class="p">)</span>
<span class="mi">1183064373567153871</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">hash</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">hash</span><span class="p">(</span><span class="mf">3.14</span><span class="p">)</span>
<span class="mi">322818021289917443</span>
</code></pre></div></div>

<blockquote>
  <p>Remarquez que la fonction de hash utilisée dépend du type d’objet.</p>

  <p>De plus, comme un hash est défini à la création d’un objet, il n’existe pas de hash pour des objet mutable en python. Ainsi <code class="language-plaintext highlighter-rouge">hash([])</code> produira une erreur (<code class="language-plaintext highlighter-rouge">TypeError: unhashable type: 'list'</code>).</p>
</blockquote>

<p>La principale raison de l’utilisation des fonctions de hachage est :</p>

<blockquote class="note">
  <p>Si $f$ est une fonction de hachage, alors :</p>

\[f(a) \neq f(b) \Rightarrow a \neq b\]

</blockquote>

<p>Une fonction de hachage permet de partitionner les entiers (<em>ie.</em> les objets) en $m+1$ classes. Pour que ce partitionnement soit utile, on demande à une <em>bonne</em> fonction de hachage d’avoir en plus les propriétés suivantes :</p>

<blockquote class="note">
  <p>Pour qu’une fonction de hachage $f: \mathbb{N} \rightarrow [0\mathrel{ {.}\,{.} } m]$ soit <strong>utile</strong>, elle doit avoir les 3 propriétés suivantes :</p>

  <ol>
    <li>elle doit être <strong>déterministe</strong> : un même message doit toujours avoir la même valeur de hachage.</li>
    <li>elle doit être <strong>facilement calculable</strong>
</li>
    <li>elle doit être  <strong>uniforme</strong> : la probabilité que $f(a) = i$ doit être de $\frac{1}{m+1}$ pour tout $a\in \mathcal{N}$ et $0 \leq i \leq m$</li>
  </ol>

</blockquote>

<h2 id="exemples">exemples</h2>

<h3 id="une-constante">une constante</h3>

<p>La fonction constante :</p>

\[\begin{array}{ccccc}
f &amp; : &amp; \mathbb{N} &amp; \to &amp; [0\mathrel{ {.}\,{.} } m] \\
 &amp; &amp; x &amp; \mapsto &amp; f(x)=0 \\
\end{array}\]

<p>est une fonction de hachage.</p>

<p>Elle n’est cependant que peu utile, car elle n’est pas uniforme. Ceci dit, elle est utilisé plus souvent qu’on ne le croit par des informaticiens trop pressés par le temps…</p>

<h3 id="le-modulo">le modulo</h3>

<p>La fonction modulo (le reste de la division entière) :</p>

\[\begin{array}{ccccc}
f &amp; : &amp; \mathbb{N} &amp; \to &amp; [0\mathrel{ {.}\,{.} } m] \\
 &amp; &amp; x &amp; \mapsto &amp; f(x) = x \mod m \\
\end{array}\]

<p>est une fonction de hachage.</p>

<p>Sous certaines conditions, elle respecte bien les 3 propriétés d’une fonction de hachage utile.</p>

<h4 id="déterministe">déterministe</h4>

<p>Comme $a \mod m$  est égal au reste de la division entière de $a$ par $m$ son calcul est bien déterministe.</p>

<h4 id="facilement-calculable">facilement calculable</h4>

<p>Même lorsque les objets deviennent grand, le calcul du modulo peut se faire aisément. En effet le fait que :</p>

<ul>
  <li>$(a + b) \mod m$ = $((a \mod m) + (b\mod m)) \mod m$</li>
  <li>$(a \times b) \mod m$ = $((a \mod m) \times (b\mod m)) \mod m$</li>
</ul>

<p>Par exemple :</p>

<ul>
  <li>$7 \mod 3 = (4 \mod 3) + (3 \mod 3) = 1 + 0 = 1$</li>
  <li>$4 \times 3 \mod 3 = (4 \mod 3) \times (3 \mod 3) = 1 \times 0 = 0$</li>
</ul>

<p>Ce qui permet de calculer le modulo <em>par morceau</em>.</p>

<p>Per exemple, prenons un objet $n$, qui est représenté en mémoire par une suite de $k \times l$ $0$ et $1$ :</p>

\[n = \underbrace{0 \cdots 1}_{k \times l}\]

<p>On peut alors le découper en paquets de $k$ bits (souvent $k = 256$) :</p>

\[n = \underbrace{0 \cdots 1}_{k} \cdots \underbrace{1 \cdots 0}_{k} \cdots \underbrace{1 \cdots 1}_{k}\]

<p>Et calculer le modulo sur chacun de ces paquets indépendamment, puis sommer le tout (en faisant à chaque fois le modulo).</p>

<p>Par exemple, en notant $n_i$ le nombre associé aux $i$ème $k$ bits de $n$ on a :</p>

\[\begin{array}{lcl}
n &amp;=&amp; n_l2^{kl} + n_{l-1} 2^{k(l-1)} + \dots + n_{i} 2^{ki} + \dots + n_0\\
&amp; &amp; \sum_{i=0}^l n_i2^{ki}
\end{array}\]

<p>De la un pseudo-code du calcul du modulo de $n$ est alors :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">exp</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">k</span><span class="p">)</span> <span class="n">mod</span> <span class="n">k</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">n_0</span> <span class="n">mod</span> <span class="n">k</span>
<span class="k">for</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">k</span><span class="p">:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">exp</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="n">mod</span> <span class="n">k</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">n_i</span><span class="p">)</span> <span class="n">mod</span> <span class="n">k</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">res</span> <span class="o">+</span> <span class="n">c</span><span class="p">)</span> <span class="n">mod</span> <span class="n">k</span>
</code></pre></div></div>

<p>Comme accéder à $k$ bits dans la mémoire ou faire le modulo d’un nombre de taille fixe est très facile pour un ordinateur, on peut facilement calculer le modulo d’un objet aussi grand qu’il soit.</p>

<h4 id="équiprobable">équiprobable</h4>

<p>Si les nombres à hacher sont pris aléatoirement, le modulo est bien uniforme quelque soit $m$.</p>

<p>Attention cependant :</p>

\[(k \times p) \mod (p \times q) = (k \mod q) \times p\]

<p>Les nombres qui ont un diviseur commun avec $m$ seront hachés par un nombre qui est un multiple de ce diviseur !
De là, si l’ensemble de nombre que l’on a à hacher n’est pas uniforme mais admets des diviseurs commun, ce qui arrive souvent, la probabilité de hachage ne sera pas uniforme.</p>

<p>Pour palier ce problème :</p>

<blockquote class="note">
  <p>Si l’on utilise le modulo comme fonction de hachage, il est recommandé d’utiliser un nombre $m$ premier.</p>
</blockquote>

<h4 id="hash-de-structures-composées">hash de structures composées</h4>

<p>Par exemple considérons le tuple suivant : <code class="language-plaintext highlighter-rouge">(1, 'un', 3.14)</code>. Il contient 3 types de données différents. On pourrait très bien utiliser sa représentation binaire et faire le hash de cet objet mais, souvent, ce n’est pas cette approche qui est utilisée. On préfère combiner les hash des des différents types d’objets en un hash unique.</p>

<p>En java par exemple, une façon classique de procéder est de :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>res = 0
pour chaque élément e du tuple:
    res = hash(31 * res + hash(e))

</code></pre></div></div>

<p>Ceci assure :</p>

<ul>
  <li>d’avoir un hash facile à calculer si le chaque de chaque élément l’est</li>
  <li>de ne pas avoir de soucis de diviseurs (voir le soucis du modulo) grâce à la multiplication par 31 qui va <em>mélanger</em> le tout à chaque fois</li>
</ul>

<h2 id="collisions">collisions</h2>

<blockquote class="note">
  <p>Une <strong>collision</strong> pour une fonction de hachage $h$ est deux nombre $a$ et $b$ telle que $f(a) = f(b)$</p>
</blockquote>

<p>Le but est — bien sûr — de minimiser les collisions.</p>

<blockquote class="note">
  <p>Pour une fonction de hachage $f: \mathbb{N} \rightarrow [0 \mathrel{ {.}\,{.} } m]$ uniforme, la probabilité $\bar{p}(n, m)$ de tirer $n &gt; 1$ nombres au hasard sans avoir de collisions est de :</p>

\[\bar{p}(n, m) = \prod_{i=1}^{n-1}(1-\frac{i}{m+1})\]

</blockquote>
<details><summary>preuve</summary><div>
<p>A chaque fois que l’on tire un nombre au hasard, il faut que son hash soit différent de ceux des tirages précédents. Au $i$ème essai il y a donc une probabilité de $\frac{i-1}{m+1}$ de tomber sur un hash déjà vu et une probabilité de $1-\frac{i-1}{m+1}$ d’en obtenir un nouveau.</p>

</div></details>

<p>On peut en extraire des solutions approchées si $m$ est très grand devant $n$ :</p>

<blockquote class="note">
  <p>Si $m$ est grand devant $n$, on a :</p>

\[\bar{p}(n, m) \simeq \exp(-\frac{n^2}{2(m+1)})\]

  <p>et donc :</p>

\[n \simeq \sqrt{2(m+1)\ln(\frac{1}{\bar{p}(n, m)})}\]

</blockquote>
<details><summary>preuve</summary><div>
\[\begin{array}{lcll}
 \bar{p}(n, m)&amp;=&amp;\prod_{i=1}^{n-1}(1-\frac{i}{m+1})&amp;\\
 \ln(\bar{p}(n, m))&amp;=&amp;\ln(\prod_{i=1}^{n-1}(1-\frac{i}{m+1}))&amp;\mbox{car }\ln \mbox{ est une fonction croissante}\\
 \ln(\bar{p}(n, m))&amp;=&amp;\sum_{i=1}^{n-1}\ln((1-\frac{i}{m+1}))&amp;\mbox{car }\ln(ab) = \ln(a) + \ln(b)\\
 \ln(\bar{p}(n, m))&amp;\simeq&amp;\sum_{i=1}^{n-1}(-\frac{i}{m+1})&amp;\mbox{car }\ln(1+x) \simeq x\mbox{ si } x \simeq 0\\
 \ln(\bar{p}(n, m))&amp;\simeq&amp;\frac{-1}{m+1}\sum_{i=1}^{n-1}i&amp;\\
 \ln(\bar{p}(n, m))&amp;\simeq&amp;\frac{-1}{m+1}\frac{n(n-1)}{2}&amp;\\
 \ln(\bar{p}(n, m))&amp;\simeq&amp;\frac{-n^2}{2(m+1)}&amp; \mbox{car } n \simeq n-1\\
\end{array}\]

<p>La dernière égalité nous nonne aisément la deuxième égalité à prouver, et en repassant aux exponentielle on en déduit aussi la première égalité.</p>

</div></details>

<p>Ces inégalités permettent par exemple de calculer le nombre d’étudiants qu’il faut avoir dans une classe pour avoir 50% de chances d’avoir deux dates d’anniversaires identiques. Ce résultat est connu sous le nom de <a href="https://fr.wikipedia.org/wiki/Paradoxe_des_anniversaires">paradoxe des anniversaires</a>, car le nombre de 23 ($\sqrt{2\times 365 \ln(1/.5)} \simeq 22.5$) semble très petit.</p>

<p>Si l’on prend un exemple réaliste de fonction de hash, par exemple celle utilisée par <a href="https://fr.wikipedia.org/wiki/Git">git</a>, qui rend un mot de $\{0, 1\}^{160}$ (git utilise la fonction de hachage <a href="https://fr.wikipedia.org/wiki/SHA-1">sha-1</a>), il faudrait avoir un nombre de tirage de :</p>

\[n = \sqrt{2\times 2^{160}\ln(\frac{1}{.5})} \simeq 2^{80}\]

<p>Pour avoir 50% de chance d’obtenir une collision. Ce qui fait tout de même un sacré paquet !</p>

<h2 id="utilisation">utilisation</h2>

<p>On l’a vue, si la taille du hashage est grand, il faut a priori un grand nombre d’objet pour espérer avoir une collision. C’est pourquoi on considère souvent que :</p>

<blockquote class="note">
  <p><em>En pratique</em> une fonction de hashage utile est une <strong>injection</strong> de l’ensemble des objets utilisés dans le programme dans $[0 \mathrel{ {.}\,{.} } m]$ ou $\{0, 1\}^k$  selon la fonction utilisée</p>
</blockquote>

<p>Cette propriété permet d’utiliser les fonctions de hashage pour :</p>

<ul>
  <li>proposer des résumés d’un objet (c’est comme ça que git stocke ses objets) : deux objets sont considérés identiques si’l ont le même hash, ce qui est bien plus rapide que de comparer bit à bit les 2 objets.</li>
  <li>créer des structures de données avancées comme les dictionnaires</li>
</ul>

<p>Les fonctions de hachages sont même utilisées pour stocker les mots de passe sur votre ordinateur, mais pour que ne soit pas (ou très difficilement) piratable, il faut utiliser des fonctions de hashage dites <em>cryptographique</em>.</p>

<h2 id="hash-cryptographique">hash cryptographique</h2>

<p>Les fonctions de hash sont très utilisée en cryptographie. Pour être robuste, elles doivent cependant avoir <a href="https://fr.wikipedia.org/wiki/Fonction_de_hachage_cryptographique">des propriétés spécifiques</a> :</p>

<ol>
  <li>elles doivent être utiles (déterministe, facilement calculable et uniforme)</li>
  <li>une petite modification de l’entrée doit produire une grosse modification du hash</li>
  <li>en connaissant une valeur de hash $x$ il est très difficile de retrouver un $a$ tel que $f(a) = x$</li>
  <li>en connaissant $a$ il est très difficile de trouver $b \neq a$ tel que $f(b) = f(a)$</li>
</ol>

<p>En cryptographie, <strong>très difficile</strong> signifie que le temps pour le faire doit être supérieure à la durée de vie (l’utilité) du message.</p>

<p>Ici l’utilité réside dans le fait qu’en pratique :</p>

<ul>
  <li>la fonction de hash est une injection</li>
  <li>il est impossible de trouver un objet ayant un hash donné.</li>
</ul>

<p>La fonction de hash ($f$) peut alors être utilisée comme une serrure ($x$) qui ne s’ouvre que si l’on a la bonne clé (un $a$ tel que $f(a) = x$).</p>

<p>Craquer une fonction hash cryptographique revient soit :</p>

<ul>
  <li>à pouvoir trouver 2 éléments $a$ et $a’$ tels que $f(a) = f(a’)$ : trouver des collision montrerait que la fonction n’est pas injective et donc $a$ n’est pas une clé unique</li>
  <li>pouvoir trouver $a$ tel que $f(a) = x$ en ne connaissant que $x$ : revient à forger une clé en ne connaissant que la serrure.</li>
</ul>

<h3 id="comment">comment</h3>

<p>Plusieurs méthode de hash cryptographique existent. On peut en citer deux, issues de sha :</p>

<ul>
  <li>
<a href="https://fr.wikipedia.org/wiki/SHA-1">sha-1</a> utilisé par git mais plus trop de façon cryptographique</li>
  <li>SHA256 (protocole <a href="https://fr.wikipedia.org/wiki/SHA-2">sha-2</a>)</li>
</ul>

<blockquote class="note">
  <p>On recommande actuellement d’utiliser l’algorithme SHA256 ou SHA512 pour un usage cryptographique.</p>
</blockquote>

<p>Ils sont directement utilisable :</p>

<ul>
  <li>
<a href="https://fre.applersg.com/check-sha1-checksum-mac-os-x">sous mac</a> et <a href="https://www.lojiciels.com/quest-ce-que-shasum-sous-linux/">linux</a> avec le programme <code class="language-plaintext highlighter-rouge">shasum</code>
</li>
  <li>
<a href="https://lecrabeinfo.net/verifier-integrite-calculer-empreinte-checksum-md5-sha1-sha256-fichier-windows.html">sous windows</a> avec la commande <a href="module">Get-FileHash</a> sous powershell.</li>
</ul>

<h3 id="exemple-dutilisation">exemple d’utilisation</h3>

<h4 id="vérification-de-lintégrité-dun-fichier">vérification de l’intégrité d’un fichier</h4>

<p>Si l’on connait le hash d’un fichier et qu’il est impossible de le modifier en conservant le même hash. On peut être sur qu’un fichier n’a pas été modifié. Dans ce cadre là, on appelle cette valeur de hash le <a href="https://fr.wikipedia.org/wiki/Somme_de_contr%C3%B4le">checksum ou somme de contrôle</a></p>

<h4 id="stockage-des-mots-de-passes">stockage des mots de passes</h4>

<p>Les mots de passe d’un système son normalement stockés sous la forme d’un hash, auquel on ajoute un <em>sel</em> aléatoire. Voir par exemple <a href="https://patouche.github.io/2015/03/21/stocker-des-mots-de-passe/">ce post de blog</a> qui vous explique un peu comment tout ça fonctionne.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique de François Brucker.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
