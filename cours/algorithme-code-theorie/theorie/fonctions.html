<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Algorithme et fonctions | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="Algorithme et fonctions">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique de François Brucker.">
<meta property="og:description" content="Support de cours/td d’informatique de François Brucker.">
<link rel="canonical" href="/cours_informatique/cours/algorithme-code-theorie/theorie/fonctions.html">
<meta property="og:url" content="/cours_informatique/cours/algorithme-code-theorie/theorie/fonctions.html">
<meta property="og:site_name" content="cours d’informatique">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Algorithme et fonctions">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Support de cours/td d’informatique de François Brucker.","headline":"Algorithme et fonctions","url":"/cours_informatique/cours/algorithme-code-theorie/theorie/fonctions.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Algorithme et fonctions</h1>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/algorithme-code-theorie/">Algorithme, code et théorie</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/theorie/">théorie</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/theorie/fonctions.html">fonctions</a></p>

  <p><strong>prérequis :</strong></p>

  <ul>
    <li><a href="/cours_informatique/cours/algorithme-code-theorie/algorithme/algorithmes.html">algorithmes</a></li>
  </ul>
</blockquote>

<p>Un algorithme, <a href="/cours_informatique/cours/algorithme-code-theorie/algorithme/algorithmes.html#algorithme">on l’a vu</a>, c’est :</p>

<blockquote class="note">
  <p>Un algorithme est une succession d’instructions simples et clairement définies. A partir d’entrées, il produit une sortie en un nombre fini d’instructions.</p>
</blockquote>

<p>Nous allons dans cette partie, sans aucun présupposé sur les instructions à utiliser, montrer que l’on peut préciser ce qu’est un algorithme sous la forme de fonctions, juste en utilisant la finitude de sa description.</p>

<p>Ce qu’il faut retenir de cette partie :</p>

<ul>
  <li>un algorithme peut-être vue une fonction prenant <strong>un</strong> mot composé de 0 et de 1 en entrée et qui donne un mot composé de 0 et de 1 en sortie</li>
  <li>que l’on ne peut pas manipuler de réels directement que des approximations</li>
  <li>que toutes les fonctions prenant <strong>un</strong> mot composé de 0 et de 1 en entrée et qui donne un mot composé de 0 et de 1 en sortie ne peuvent pas être calculées par un algorithme (et savoir pourquoi)</li>
</ul>

<h2 id="objets-et-instructions-dun-algorithme">objets et instructions d’un algorithme</h2>

<p>Le terme <strong>fini</strong> de la définition d’un algorithme est crucial : pour qu’un humain comprenne, et surtout puisse agir, il ne faut pas qu’il y ait un nombre infini de choses à regarder (chaque chose à faire prend un temps de réflexion non nul, une instruction contenant un nombre infini n’est humainement pas réalisable).</p>

<h3 id="instructions-dun-algorithme">instructions d’un algorithme</h3>

<p>On en déduit la définition (très générale) d’une instruction d’un algorithme :</p>

<blockquote class="note">
  <p>Une <strong>instruction</strong> d’un algorithme est une règle définie par un nombre <strong>fini</strong> de symboles.</p>
</blockquote>

<p>Fini ne veut pas dire petit nombre. Un algorithme peut utiliser des nombres entiers aussi grand qu’il
le veut, du moment qu’ils ne soient pas infini.</p>

<h3 id="objet-manipulables">objet manipulables</h3>

<p>Puisque l’on a le droit de ne manipuler que des choses finies, un algorithme ne peut manipuler que des <a href="https://fr.wikipedia.org/wiki/Mot_(math%C3%A9matiques)">mots d’un alphabet fini</a>. La conséquence fondamentale de ceci est que :</p>

<blockquote class="note">
  <p><strong>un algorithme ne peut pas manipuler de nombres réels</strong>. On ne peut considérer un réel que comme une abstraction (un symbole particulier) ou une approximation (on ne considère qu’un nombre fini de décimales).</p>
</blockquote>

<p>Prenons $\pi$ par exemple. Il existe des algorithmes qui <a href="https://fr.wikipedia.org/wiki/Approximation_de_%CF%80#Calcul_de_la_n-i%C3%A8me_d%C3%A9cimale_de_%CF%80">calculent les décimales de pi</a>, mais on ne pourra jamais écrire que pi est le résultat d’un algorithme, puisque l’algorithme doit s”arrêter : on aura qu’un nombre fini de décimales, donc on aura pas $\pi$.</p>

<p>On ne peut le considérer que de deux manières : comme le symbole $\pi$ et de là faire des opérations sur lui (comme $2 \cdot \pi$, ou $\frac{3\pi}{3}$, …) de façon formelle, c’est à dire sans jamais connaître sa valeur ou comme une valeur approchée de lui (3.1415 par exemple) et ainsi rendre des valeurs approchées des différentes opérations. On ne pourra cependant <strong>jamais</strong> avoir la valeur exacte de $\pi$ avec un algorithme (et ce même s’il avait une mémoire infinie).</p>

<p>Ce n’est pas bien grave en général puisque les lois physiques sont presque tout le temps stables (de petits effets impliquent de petites causes) : considérer les réels en <a href="https://fr.wikipedia.org/wiki/Notation_scientifique">notation scientifique</a> en se fixant une précision ne gène pas les calculs physiques.</p>

<blockquote>
  <p>Faites tout de même attention car parfois, c’est problématique. Pour le calcul d’effets chaotiques comme la météo où <a href="https://fr.wikipedia.org/wiki/Effet_papillon">de petits effets produisent de grandes causes</a>, certes, mais aussi lorsque l’on prend l’inverse de choses très petites qui du coup deviennent très grandes. Ce sont des problèmes dit de <a href="https://fr.wikipedia.org/wiki/Stabilit%C3%A9_num%C3%A9rique">stabilité numérique</a>.</p>
</blockquote>

<p>En conclusion :</p>

<blockquote class="note">
  <p>Les objets manipulables par un algorithme sont uniquement :</p>

  <ul>
    <li>les entiers finis</li>
    <li>les approximations finies de réels</li>
    <li>les chaînes de caractères</li>
  </ul>

</blockquote>

<h2 id="nombre-algos">nombre d’algorithmes</h2>

<p>Comme un algorithme peut-être décrit par une description finie de son déroulé, qu’il ne peut utiliser qu’un nombre fini d’instructions et que chaque instruction doit être elle-même décrite de façon finie, on en déduit qu’un algorithme est une chaîne de caractères particulière (qu’on peut limiter aux mots Français si on a envie).</p>

<p>De là :</p>

<blockquote class="note">
  <p>Il ne peut y avoir plus d’algorithmes que de chaine de caractères écrites en Français.</p>
</blockquote>

<p>Ça en fait un sacré paquet. Tentons d’être un peu plus précis. Comme chaque chaîne de caractères peut être associée à un entier en concaténant  un à un le code <a href="https://fr.wikipedia.org/wiki/Unicode">unicode</a> associé à chaque caractère de la description de l’algorithme et des instructions utilisées (comme si on sauvait le fichier au format texte sur un ordinateur) :</p>

<blockquote class="note">
  <p>Il ne peut y avoir plus d’algorithmes que de nombres entiers.</p>
</blockquote>

<h2 id="fonctions">fonctions</h2>

<p>Un algorithme, représenté par sa description, a des entrées et une sortie : c’est une fonction. D’après ce qui précède, on a donc :</p>

<blockquote class="note">
  <p>Un algorithme à $p$ entrées, dont $q$ entrées entières, $r$ entrées approximation des réels et $s$ chaînes de caractères est une fonction de :</p>

\[f: \mathbb{N}^{q} \times R^r \times C^s \rightarrow \mathbb{N} \cup R \cup C\]

  <p>où $\mathbb{N}$ est l’ensemble des entiers, $R$ l’ensemble des approximations de réels et $C$ l’ensemble des chaînes de caractères.</p>
</blockquote>

<p>On a pas trop dit grand chose pour l’instant. On a fait que re-écrire ce qu’on savait déjà sous la forme de fonctions. On va montrer qu’on peut faire bien mieux en montrant qu’un algorithme est une fonction de $\mathbb{N}$ (les entiers) dans $\mathbb{N}$.</p>

<p>Cela nous permettra de montrer qu’un algorithme ne peut pas <strong>tout</strong> calculer : il existe des fonctions de $\mathbb{N}$ dans $\mathbb{N}$ qu’aucun ordinateur ne pourra calculer (trouver des fonctions non calculables par un ordinateur n’est pas une tâche simple cependant. Il nous faudra un peut plus de connaissances pour en exhiber).</p>

<blockquote class="attention">
  <p>Dans la suite de cette partie on utilisera les <a href="https://fr.wikipedia.org/wiki/Bijection">bijections</a> entre ensembles. Si deux ensembles sont en bijections on peut passer de l’un à autre (et réciproquement) sans soucis, les deux ensembles sont équivalents : on peut utiliser l’un ou l’autre sans perte de généralité.</p>
</blockquote>

<h3 id="fonction-plusieurs-entier">fonctions à plusieurs paramètres entiers</h3>

<p>Les paramètres d’un algorithme peuvent tous être représentés par des entiers :</p>

<ul>
  <li>des entiers finis : c’est clair.</li>
  <li>des approximations finies de réels : on peut utiliser la norme <a href="https://fr.wikipedia.org/wiki/IEEE_754">IEEE 754</a>. Par exemple 3.1415 en codage IEEE 754 sur 32 bits correspond à l’entier binaire : <code class="language-plaintext highlighter-rouge">01000000010010010000111001010110</code> (j’ai utilisé <a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">un convertisseur</a>)</li>
  <li>des chaînes de caractères : que l’on peut représenter comme un entier. Par exemple la chaîne de caractères “Yop !” correspond au nombre binaire <code class="language-plaintext highlighter-rouge">111100101101111011100000010000000100001</code> en utilisant  (là aussi, j’ai utilisé <a href="http://hapax.qc.ca/conversion.fr.html">un convertisseur</a>).</li>
</ul>

<p>On peut donc reformuler notre assertion précédente en unifiant les paramètres (on les recode tous sous la forme d’entiers) :</p>

<blockquote class="note">
  <p>Un algorithme est une fonction de $p$ paramètres entiers et qui rend un entier.</p>

\[f: \mathbb{N}^p \rightarrow \mathbb{N}\]

</blockquote>

<p>C’est bien mieux mais on sépare encore les algorithmes par leur nombre de paramètres. Allons plus loin.</p>

<h3 id="fonction-un-entier">fonctions à un paramètre entier</h3>

<p>Démontrons que tout élément de $\mathbb{N}^p$ peut être représenté par un entier. Pour ce faire on montrera que $\mathbb{N}^p$ est en bijection avec $\mathbb{N}$ quelque soit $p$.</p>

<p>La figure ci-dessous montre comment faire pour $\mathbb{N}^2$. On commence par placer tout élément $(x, y)$ de $\mathbb{N}^2$ dans le plan. puis on passe de l’un à l’autre en suivant les diagonales.</p>

<p><img src="./assets/theorie_n2dansN.png" alt="compteur" style="margin: auto;
display: block; width: 200px"></p>

<p>On chemine alors comme ça :</p>

<ol>
  <li>$(0, 0)$</li>
  <li>$(1, 0)$</li>
  <li>$(0, 1)$</li>
  <li>$(2, 0)$</li>
  <li>$(1, 1)$</li>
  <li>$(0, 2)$</li>
  <li>$(3, 0)$</li>
  <li>$(2, 1)$</li>
  <li>$(1, 2)$</li>
  <li>$(0, 3)$</li>
  <li>$(4, 0)$</li>
  <li>…</li>
</ol>

<p>L’entier $O((x, y))$ associé à $(x, y)$ est alors l’ordre dans ce cheminement (par exemple $O((2, 1)) = 8$) : on peut associer un unique entier à tout couple d’entiers et réciproquement ($O^{-1}(6) = (0, 2)$ par exemple). On en conclut que :</p>

<blockquote class="note">
  <p>Il existe une bijection entre $\mathbb{N}^2$ et $\mathbb{N}$ : il y a autant de couples d’entiers que d’entiers.</p>
</blockquote>

<p>De façon générale :</p>

<blockquote class="note">
  <p>Il existe une bijection entre $\mathbb{N}^p$ et $\mathbb{N}$ : il y a autant de $p$-uplets d’entiers que d’entiers.</p>
</blockquote>

<details><summary>preuve</summary><div>
<p>On note $D_i$ (une diagonale) l’ensemble des $p$-uplets $(n_1, \dots, n_p)$ tels que $\sum_{i=1}^p n_i = p$.</p>

<p>Comme chaque diagonale a un nombre fini d’élément, on peut les ordonner, en suivant l’<a href="https://fr.wikipedia.org/wiki/Ordre_lexicographique#G%C3%A9n%C3%A9ralisation_aux_produits_cart%C3%A9siens_finis">ordre lexicographique</a> (le plus petit élément de $D_i$ est $(0, \dots, 0, i)$ et $(i, 0, \dots, 0)$ le plus grand par exemple).</p>

<p>De cet ordre dans une diagonale, on peut en déduire un ordre sur tous les $p$-uplets, en disant que $e &lt; f$ si :</p>

<ul>
  <li>$e \in D_k$ et $f \in D_{k’}$ avec $k’ &lt; k$</li>
  <li>ou si $e, f \in D_k$ et que $e$ est avant $f$ dans l’<a href="https://fr.wikipedia.org/wiki/Ordre_lexicographique#G%C3%A9n%C3%A9ralisation_aux_produits_cart%C3%A9siens_finis">ordre lexicographique</a> de $D_k$.</li>
</ul>

<p>La fonction $h$ suivante est alors une bijection de $\mathbb{N}^p$ dans $\mathbb{N}$ :</p>

\[h(e) = \vert \{ g \mid g &lt; e \}\vert\]

<p>En effet :</p>

<ul>
  <li>la fonction est bien définie pour tout $p$-uplet : si $f &lt; e$ alors $f$ est dans une diagonale plus petite ou égale à $e$, il y a donc un nombre fini d’éléments plus petit que $e$</li>
  <li>soit $f \neq e$ sont 2 $p$-uplets différents. On peut considérer sans perte de généralité que $f &lt; e$ et donc $\{ g \mid g &lt; f \} \cup \{f \} \subseteq \{ g \mid g &lt; e \}$. On en déduit que $h(f) &lt; h(e)$ et donc que pour tout entier $i$, il existe au plus 1 $p$-uplet $e$ tel que $h(e) = i$</li>
  <li>si on prend deux $p$-uplets successif pour otre ordre, disons $e &lt; e’$ (et il n’existe pas $e’’$ tel que $e &lt; e’’ &lt; e’$) on a $h(e) + 1 = h(e’)$ : pour tout entier $i$ il existe un $p$-uplet $e$ tel $h(e) = i$</li>
</ul>

</div></details>

<p>La bijection entre $\mathbb{N}^p$ et $\mathbb{N}$ nous permet de dire que l’on peut indifféremment utiliser $\mathbb{N}^p$  ou $\mathbb{N}$ sans perte de généralité (on utilise la bijection pour passer de l’un à l’autre). De là, on peut dire que :</p>

<blockquote class="note">
  <p>Un algorithme est une fonction de :</p>

\[f: \mathbb{N} \rightarrow \mathbb{N}\]

</blockquote>

<p>En remarquant que tout entier peut s’écrire sous sa <a href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_binaire">notation binaire</a>, il existe une bijection entre $\mathbb{N}$ et l’ensemble des mots que l’on peut former avec $0$ et $1$. En notant cet ensemble $\{0, 1\}^\star$, on en conclut que :</p>

<blockquote class="note">
  <p>Un algorithme est une fonction de :</p>

\[f: \{0, 1\}^\star \rightarrow \{0, 1\}^\star\]

</blockquote>

<p>C’est cette formulation que l’on utilisera le plus souvent.</p>

<h3 id="fonction-un-binaire">pour la bonne bouche</h3>

<p>Vous allez rire, on peut encore aller plus loin. Pour l’instant, on sait qu’un algorithme est une fonction $f: \mathbb{N} \rightarrow \mathbb{N}$. Elle associe donc un entier à un autre. Cette fonction est alors équivalente à la fonction $f’$ ci-dessous :</p>

\[f'(n, m) = \left\{
    \begin{array}{ll}
        1 &amp; \mbox{si } f(n) = m\\
        0 &amp; \mbox{sinon.}
    \end{array}
\right.\]

<p>D’après ce qui précède, en utilisant une bijection entre $\mathbb{N} \times \mathbb{N}$ et $\mathbb{N}$, il existe alors une fonction $f’’: \mathbb{N} \rightarrow \{0, 1\}$ équivalente à $f’$ et donc à $f$.</p>

<p>En utilisant les notations binaires on a alors :</p>

<blockquote class="note">
  <p>Un algorithme est une fonction de :</p>

\[f: \{0, 1\}^\star \rightarrow \{0, 1\}\]

</blockquote>

<h2 id="que-calcule-t-on-">que calcule-t-on ?</h2>

<p>On a démontré qu’un algorithme était une fonction de $\mathbb{N}$ dans $\mathbb{N}$ (ou, ce qui est identique, de $\{0, 1\}^\star$ dans $\{0, 1\}$). Mais c’est une fonction particulière puisque ce qu’elle procède selon un plan détaillé (des instructions) qu’elle exécute petit à petit (séquentiellement).</p>

<p>On ne donnera pas ici d’exemple concret de fonction qu’on ne peut pas décrire par un algorithme, on montre juste que contrairement à une idée répandue :</p>

<blockquote class="note">
  <p>Un algorithme <strong>ne peut pas</strong> tout calculer.</p>
</blockquote>

<p>Pour cela, on va montrer qu’il existe strictement plus de fonctions que d’algorithmes.</p>

<p>On va procéder par étapes :</p>

<ol>
  <li>on montre qu’il y a exactement autant de fonctions $f: \mathbb{N} \rightarrow \mathbb{N}$ que de sous ensembles de $\mathbb{N}$</li>
  <li>on montre qu’il y a strictement plus de sous-ensembles de $\mathbb{N}$ que d’éléments dans $\mathb{N}$</li>
  <li>on conclut puisqu’il ne peut y avoir plus d’algorithmes que de nombres entiers.</li>
</ol>

<p>On finira cette partie en montrant, pour la bonne bouche, qu’il y a autant de sous-ensembles de $\mathbb{N}$ que ne nombres réels.</p>

<h3 id="fonctions-et-sous-ensembles-de-mathbbn">fonctions et sous ensembles de $\mathbb{N}$</h3>

<p>On va montrer qu’il existe autant de fonctions $f: \mathbb{N} \rightarrow \mathbb{N}$ que de sous-ensembles de $\mathbb{N}$. Pour cela on commence par montrer qu’il y en a plus puis qu’il y en a moins pour en conclure finalement qu’il y en a donc autant.</p>

<p>Tout d’abord, il est clair que pour tout ensemble d’entiers $A$, on peut construire la fonction :</p>

\[f_A(x) = \left\{
    \begin{array}{ll}
        x + 1 &amp; \mbox{si } x \in A \\
        0 &amp; \mbox{sinon.}
    \end{array}
\right.\]

<p>On vérifie facilement que si $A \neq A’$ on a $f_A \neq f_{A’}$ (si $x \in A$ et $x \notin A’$ $f_A(x) = x + 1 &gt; 0 = f_{A’}$) et donc que tout sous-ensemble d’entiers peut être associé à une fonction $f: \mathbb{N} \rightarrow \mathbb{N}$ différente. On peut donc dire que :</p>

<blockquote class="note">
  <p>Il y a plus de fonction $f: \mathbb{N} \rightarrow \mathbb{N}$ que de sous-ensembles de $\mathbb{N}$.</p>
</blockquote>

<p>Réciproquement, on peut associer pour chaque fonction $f: \mathbb{N} \rightarrow \mathbb{N}$ le sous ensemble de $\mathbb{N}^2$ :</p>

\[I(f) = \{ (n, f(n)) \vert n \in \mathbb{N} \}\]

<p>Si $f$ et $f’$ sont deux fonctions de $\mathbb{N} \rightarrow \mathbb{N}$ différentes on a clairement que $I(f) \neq I(f’)$. Ceci nous permet de dire que :</p>

<blockquote class="note">
  <p>Il y a moins de fonctions $f: \mathbb{N} \rightarrow \mathbb{N}$ que de sous-ensembles de $\mathbb{N}^2$</p>
</blockquote>

<p>Comme on a vu qu’il y avait une bijection entre $\mathbb{N}^2$  et $\mathbb{N}$, il y a autant de sous-ensembles de $\mathbb{N}^2$ que de sous ensemble de $\mathbb{N}$, ce qui nous permet d’écrire :</p>

<blockquote class="note">
  <p>Il y a moins de fonctions $f: \mathbb{N} \rightarrow \mathbb{N}$ que de sous-ensembles de $\mathbb{N}$</p>
</blockquote>

<p>S’il y a à la fois plus et moins de fonction $f: \mathbb{N} \rightarrow \mathbb{N}$ que de sous-ensembles de $\mathbb{N}$, c’est que :</p>

<blockquote class="note">
  <p>Il y a autant de fonctions $f: \mathbb{N} \rightarrow \mathbb{N}$ que de sous-ensembles de $\mathbb{N}$</p>
</blockquote>

<h3 id="nb-ss-ensemble-N">nombre de sous-ensembles de $\mathbb{N}$</h3>

<p>Si on prend un ensemble $E$ fini, il est clair qu’il y a strictement plus de sous-ensembles de $E$ que d’éléments dans $E$.</p>

<p>Par exemple, si on prend l’ensemble $\{a, b, c\}$. Les différents sous-ensembles qu’on peut faire sont :</p>

<ul>
  <li>$\emptyset$</li>
  <li>$\{1\}$</li>
  <li>$\{2\}$</li>
  <li>$\{3\}$</li>
  <li>$\{1, 2\}$</li>
  <li>$\{1, 3\}$</li>
  <li>$\{2, 3\}$</li>
  <li>$\{1, 2, 3\}$</li>
</ul>

<p>Il y a 8 sous-ensemble d’un ensemble à 3 éléments. De façon plus générale, on montre facilement que :</p>

<blockquote class="note">
  <p>Si $E$ est un ensemble fini et contient $n$ éléments, il y a $2^n$ sous-ensembles possibles à un ensemble à $n$ éléments.</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Si l’ensemble $E$ est fini on peut ordonner ses éléments. On a alors $E = \{ e_1, \dots, e_n\}$.</p>

<p>Un sous ensemble $F$ de $E$ est alors égal à un $n$-uplet : $T(F) = (u_1, \dots, u_n)$ avec $u_i = 1$ si $e_i \in F$ et $u_i = 0$ sinon.</p>

<p>Comme il est clair que $T$ est une bijection entre l’ensemble des sous-ensembles de $F$ et l’ensemble des $n$-uplets de $\{0, 1\}^n$, il y a autant de sous-ensembles de $F$ que d’éléments dans $\{0, 1\}^n$, c’est à dire $2^n$ (chaque coordonnée à deux possibilités et il y a $n$ coordonnées).</p>

</div></details>

<p>Comme $2^n &gt; n$ pour tout $n$, il y a strictement plus de sous-ensembles de $E$ que d’éléments de $E$ si $E$ est fini. Etrangement, ceci est toujours vrai si $E$ est infini :</p>

<blockquote class="note">
  <p><a href="https://fr.wikipedia.org/wiki/Th%C3%A9or%C3%A8me_de_Cantor"><strong>Théorème de Cantor</strong></a> :</p>

  <p>Pour tout ensemble $E$ (même infini), il y a strictement plus de sous-ensembles de $E$ que d’éléments de $E$.</p>
</blockquote>

<details><summary>preuve du théorème de Cantor</summary><div>
<p>La preuve du Théorème de Cantor repose sur le fait que pour toute fonction $f$ qui associe à un élément de $E$ un sous-ensemble de $E$, il existe des éléments qui n’ont pas d’antécédent.</p>

<p>L’ensemble $D = \{x \in E \vert x \notin f(x)\}$ est un de ceux là. En effet, s’il en avait un, disons $y$, on aurait $f(y) = D$ et alors :</p>

<ul>
  <li>$y \notin D$ car s’il y était alors $y \notin f(y)$ ce qui est incohérent avec le fait que $f(y) = D$</li>
  <li>$y \in D$ car s’il n’y était pas alors $y \in f(y)$ ce qui est incohérent avec le fait que $f(y) = D$</li>
</ul>

<p>Bref, $y$ n’existe pas.</p>

<p>On en conclut qu’il existe des sous-ensembles de $E$ qui ne sont pas des images de $f$ : ce n’est pas une <a href="https://fr.wikipedia.org/wiki/Surjection">surjection</a>. Comme $f$ a été prise au hasard, ça signifie que pour toute fonction il existera des sous-ensembles de $E$ qui ne seront pas atteints : il y a strictement plus de sous ensembles de $E$ que d’éléments de $E$.</p>

</div></details>

<blockquote class="attention">
  <p>Ce théorème est vachement profond !</p>

  <p>Il stipule qu’il existe plusieurs infinis, de plus en plus gros. L’infini de $\mathbb{N}$ étant plus petit que celui de l’ensemble de ses sous-ensembles.</p>

  <p>Regardez ce lien <a href="https://www.arte.tv/fr/videos/097454-005-A/voyages-au-pays-des-maths/">https://www.arte.tv/fr/videos/097454-005-A/voyages-au-pays-des-maths/</a> par exemple qui illustre parfaitement cela.</p>
</blockquote>

<p>En utilisant le théorème de Cantor et le fait qu’il y ait autant de fonction $f: \mathbb{N} \rightarrow \mathbb{N}$ que de sous-ensembles de$\mathbb{N}$ on en déduit donc :</p>

<blockquote class="note">
  <p>Il y a strictement plus de fonctions $f: \mathbb{N} \rightarrow \mathbb{N}$ que d’entiers.</p>
</blockquote>

<h3 id="nombre-fonction">conclusion</h3>

<p><a href="#nombre-algos">On a vu</a> qu’il ne pouvait pas y avoir plus d’algorithmes que d’entiers puisque chaque algorithme a une description finie. En utilisant ce qui précède on a alors :</p>

<blockquote class="note">
  <p>Il existe des fonctions $f: \mathbb{N} \rightarrow \mathbb{N}$ qui ne peuvent pas être calculées par des algorithmes.</p>
</blockquote>

<p>On ne peut pas encore en exhiber une, mais <a href="/cours_informatique/cours/algorithme-code-theorie/theorie/calculabilite.html#fct-non-calculable">ça viendra</a></p>

<h4 id="r-et-n">pour la bonne bouche</h4>

<p>Je ne saurais vous laisser dans l’ignorance du nombre de sous-sembles de $\mathbb{N}$. Nous allons démontrer ensemble qu’i y en a autant que de nombres réels entre 0 et 1 (exclus).</p>

<p>On va commencer par montrer qu’il y en a moins puis qu’il y en a plus pour en conclure finalement qu’il y en a donc autant.</p>

<p>Prenons un sous-ensemble $A$ de $\mathbb{N}$. On peut ranger ses éléments par ordre croissant et concaténer leurs représentations décimales en une chaine de caractères (possiblement infini) contenant uniquement des chiffres. On concatène cette chaine à “0.1” pour obtenir la représentation décimale d’un réel.</p>

<p>Exemple : Si $A = \{0, 1, 4, 42\}$ on lui associe le réel $R(A) = 0.101442$</p>

<p>Il est clair que cette opération est une injection, c’est à dire que sir $A \neq A’$, on a bien $R(A) \neq R(A’)$ et donc que :</p>

<blockquote class="note">
  <p>Il y a plus d’éléments dans $]0, 1[$ que de sous-ensembles de $\mathbb{N}$</p>
</blockquote>

<p>Prenons maintenant un réel $r$ dans l’intervalle $]0, 1[$. Son écriture décimale s’écrit : $0.a_1a_2\dots a_i\dots$ de longueur infinie, avec possiblement des 0 à la fin. On peut lui associer le sous ensemble infini : $S(r) = \{a_i + 10 \cdot i \mid i &gt; 0 \}$.</p>

<p>Il est clair que cette opération est une injection, c’est à dire que sir $r \neq r’$, on a bien $S(r) \neq S(r’)$ et donc que :</p>

<blockquote class="note">
  <p>Il y a plus de sous-ensembles de $\mathbb{N}$ que d’éléments dans $]0, 1[$</p>
</blockquote>

<p>Il y a à la fois plus et moins d’éléments dans $]0, 1[$ que de sous ensembles de $\mathbb{N}$, donc :</p>

<blockquote class="note">
  <p>Il y a autant de sous-ensembles de $\mathbb{N}$ que d’éléments dans $]0, 1[$</p>
</blockquote>

<p>En remarquant que la fonction $f(x) = \tan(\frac{x-1}{2}\cdot \pi)$ est une bijection de $]0, 1[$ dans $]-\infty, +\infty[$, on en conlut qui’l y a autant de réels dans $]0, 1[$ que dans $]-\infty, +\infty[$ et donc :</p>

<blockquote class="note">
  <p>Il y a autant de sous-ensembles de $\mathbb{N}$ que de réels</p>
</blockquote>

<p>Le théorème de Cantor nous indique alors deux choses :</p>

<ul>
  <li>que le nombre d’entiers que l’on note $\aleph_0$ est strictement plus petit que le nombre de réels, noté $\aleph_1$.</li>
  <li>Il y a des infinis plus grand que d’autre et qu’il y en a autant qu’on veut. Il suffit de prendre l’ensemble des sous-ensemble de de $\mathbb{R}$ (il y en a $\aleph_2$) pour avoir un infini plus grand que le nombre de réels. Et ainsi de suite… Pour obtenir $\aleph_0 &lt; \aleph_1 &lt; \dots \aleph_i &lt; dots$</li>
</ul>

<blockquote>
  <p>Une question reste encore en suspend, mais on a pour l’instant toujours pas la réponse, c’est : y a-t-il un infini entre \aleph_0$ et \aleph_1$ ? On ne sais pas, mais on pense que non. C’est l’<a href="https://fr.wikipedia.org/wiki/Hypoth%C3%A8se_du_continu">hypothèse du continu</a>.</p>
</blockquote>

<p>Concluant en re-bouclant sur nos algorithmes :</p>

<blockquote class="note">
  <p>Un algorithme est une fonction $\mathbb{N} \rightarrow \mathbb{N}$.
Parmi les $\aleph_1$ fonctions de $\mathbb{N} \rightarrow \mathbb{N}$ possibles, seules au plus $\aleph_0$ peuvent être construites par des algorithmes.</p>
</blockquote>

<h3 id="mais-lorsquon-calcule-on-calcule-la-même-chose">mais lorsqu’on calcule, on calcule la même chose</h3>

<p>Les instructions qu’on s’est données pour écrire du pseudo-code vont être pratiques pour décrire un algorithme pour un humain. Le fait qu’une fois posées, les règles ne nécessitent pas d’intelligence pour être exécutées, les rendent même accessible à des étudiants !
Cependant les termes qu’on peut utiliser ne sont pas définis clairement, il y a de multiples façons d’interpréter les <a href="#regles-generales">4 règles générales</a>, ou de manipuler les <a href="#regles-pseudo-code">6 règles d’un pseudo-code</a>.</p>

<p>On peut déjà penser aux multiples langages de programmation, allant de <a href="https://fr.wikipedia.org/wiki/Assembleur">l’assembleur</a> compréhensible par les processeurs de nos ordinateurs au <a href="https://fr.wikipedia.org/wiki/Python_(langage)">python</a> que tout le monde connait, en passant par le <a href="https://fr.wikipedia.org/wiki/Haskell">haskell</a> ou encore le <a href="https://fr.wikipedia.org/wiki/C_(langage)">C</a>.</p>

<p>On trouve même des langages désignées pour être les plus simples possibles (appelés <a href="https://fr.wikipedia.org/wiki/Langage_de_programmation_exotique">turing tarpit</a>) tout en étant aussi expressif que le python. Le plus célèbre d’entre eux est le <a href="https://fr.wikipedia.org/wiki/Brainfuck">brainfuck</a>.</p>

<blockquote>
  <p><em>fun fact</em>, on peut utiliser aussi certains jeu comme langage de programmation comme <a href="https://www.factorio.com/">factorio</a> (l’algorithme de tri <a href="https://www.youtube.com/watch?v=ts5EKp9w4TU">quicksort</a>), ou encore <a href="https://www.minecraft.net/">minecraft</a> (<a href="https://www.youtube.com/watch?v=uGug-4xkw6M">une calculatrice</a>).</p>
</blockquote>

<p>Le représentant de toute ces variabilités est la <a href="/cours_informatique/cours/algorithme-code-theorie/theorie/machine-turing.html">machine de Turing</a>. C’est un outil simple qui capture merveilleusement les <a href="#regles-generales">4 règles générales</a> dans le sens où c’est <strong>et</strong> un outil puissant de démonstration <strong>et</strong> un un moyen de créer des algorithmes. C’est pourquoi la <a href="#equi-algo-pseudo-code">question sur l’équivalence entre algorithme et pseudo-code</a> est souvent écrite de cette façon  :</p>

<blockquote class="note">
  <p>On est convaincu que tout ce qu’un humain, une machine, ou encore un système physique peut calculer (c’est à dire en suivant les 4 règles générales de l’algorithme) est exactement égal à ce qu’une machine de Turing peut calculer. C’est ce qu’on appelle <a href="https://plato.stanford.edu/entries/turing-machine/#ThesDefiAxioTheo">la thèse de Church-Turing</a></p>
</blockquote>

<p>Pour répondre à notre question initiale, <em>que peut-on calculer ?</em>, on peut maintenant répondre : ce qu’une machine de Turing peut calculer (et ce n’est pas tout, mais c’est quand même pas mal de choses).</p>

<h2 id="algorithmes-et-démonstration-mathématiques">algorithmes et démonstration mathématiques</h2>

<p>On n’en parlera pas trop dans ce cours (à moins que vous me le demandiez très fort) mais, en gros, les mathématiques sont une partie de l’informatique.</p>

<p>De façon plus précise on a la suite d’équivalences :</p>

<ol>
  <li>faire une démonstration consiste — à partir d’une série finie d’axiomes — à effectuer une suite finie de déductions pour parvenir à un résultat. (<a href="https://fr.wikipedia.org/wiki/Aristote#Enqu%C3%AAte,_d%C3%A9monstration_et_syllogisme">Aristote</a>, en -350 environ)</li>
  <li>(1) est équivalent à démontrer à l’aide d’une suite finie de déductions qu’une proposition logique est vraie (<a href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_%C3%A0_la_Hilbert">Hilbert</a>, début XXe siècle)</li>
  <li>(en passant, <a href="https://fr.wikipedia.org/wiki/Th%C3%A9or%C3%A8mes_d%27incompl%C3%A9tude_de_G%C3%B6del">Gödel</a>, en 1931, démontre qu’il existe des propositions logiques qui sont vraies mais qu’il est impossible de démontrer)</li>
  <li>
<a href="https://fr.wikipedia.org/wiki/Correspondance_de_Curry-Howard">Curry puis Howard qui généralise</a>, en 1950 et 1980, montrent que (2) est équivalent à écrire en terme de <a href="https://fr.wikipedia.org/wiki/Lambda-calcul">$\lambda$-calcul</a>
</li>
  <li>
<a href="https://fr.wikipedia.org/wiki/Alan_Turing">Turing</a> démontre en 1937, que (4) est équivalent à écrire une machine de Turing.</li>
  <li>(en passant, Turing démontre qu’il existe des machines de Turing qui ne s’arrêtent jamais et que savoir si une machine de Turing va s’arrêter est <a href="https://fr.wikipedia.org/wiki/Probl%C3%A8me_de_l%27arr%C3%AAt">indécidable</a>, ce qui est équivalent à (3))</li>
</ol>

<h2 id="conclusion">Conclusion</h2>

<p>On a montré ici 3 choses fondamentales :</p>

<ul>
  <li>un algorithme ne peut pas tout faire</li>
  <li>les réels n’existent pas ! Vous ne manipulez que des approximations.</li>
</ul>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique de François Brucker.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
