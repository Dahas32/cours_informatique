<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Calculabilité | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="Calculabilité">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique de François Brucker.">
<meta property="og:description" content="Support de cours/td d’informatique de François Brucker.">
<link rel="canonical" href="/cours_informatique/cours/algorithme-code-theorie/theorie/calculabilite.html">
<meta property="og:url" content="/cours_informatique/cours/algorithme-code-theorie/theorie/calculabilite.html">
<meta property="og:site_name" content="cours d’informatique">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Calculabilité">
<script type="application/ld+json">
{"description":"Support de cours/td d’informatique de François Brucker.","@type":"WebPage","url":"/cours_informatique/cours/algorithme-code-theorie/theorie/calculabilite.html","headline":"Calculabilité","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Calculabilité</h1>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/algorithme-code-theorie/">Algorithme, code et théorie</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/theorie/">théorie</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/theorie/calculabilite.html">calculabilité</a></p>

  <p>prérequis :</p>

  <ul>
    <li><a href="/cours_informatique/cours/algorithme-code-theorie/theorie/decidabilite.html">décidabilité</a></li>
    <li><a href="/cours_informatique/cours/algorithme-code-theorie/theorie/machine-turing.html">machine de Turing</a></li>
  </ul>
</blockquote>

<p>On a vu dans la partie <a href="/cours_informatique/cours/algorithme-code-theorie/theorie/fonctions.html">fonctions</a> qu’un algorithme ne pouvait pas tout calculer, qu’il y a avait même bien plus de choses qu’on ne pouvait pas faire avec un algorithme que de chose qu’on pouvait faire avec.</p>

<p>Nous allons ici, enfin, exhiber de tels exemples.</p>

<blockquote>
  <p>Tout comme dans la partie <a href="/cours_informatique/cours/algorithme-code-theorie/theorie/decidabilite.html">décidabilité</a>, on utilisera indifféremment des pseudo-codes, code ou machine de Turing pour décrire nos algorithmes, puisque ces trois notions sont équivalentes (on fait nôtre <a href="/cours_informatique/cours/algorithme-code-theorie/theorie/algorithmes-fonctions-pseudo-code.html#church-turing">la thèse de Church-Turing</a>).</p>
</blockquote>

<h2 id="fonctions-calculables">fonctions calculables</h2>

<blockquote class="note">
  <p>Un fonction de $f: \mathcal{F} \rightarrow \{0, 1\}^\star$, avec $\mathcal{F} \in \{0, 1\}^\star$ ($f$ prend en entrée un mot d’un sous-ensemble de $\{0, 1\}^\star$ et redonne un mot en sortie) est <strong>calculable</strong> s’il existe un algorithme $A$ telle que :</p>

  <ul>
    <li>$A(\mu) = f(\mu)$ si $\mu \in \mathcal{F}$</li>
    <li>$\mathcal{L}(M) = \mathcal{F}$</li>
  </ul>

</blockquote>

<h3 id="exemples-de-fonctions-calculables">exemples de fonctions calculables</h3>

<p><a href="https://en.wikipedia.org/wiki/Computable_function#Examples">Quelques exemples</a> :</p>

<ul>
  <li>les fonctions constantes sont calculables</li>
  <li>si $f$ et $g$ sont deux fonctions calculables, alors $f+g$, $f \cdot g$ et $f \circ g$ sont calculables</li>
  <li>les fonctions dont le domaine de définition est fini, sont calculables</li>
  <li>…</li>
</ul>

<p>Beaucoup, beaucoup, beaucoup de fonctions sont calculables, il suffit d’exhiber un algorithme pour le prouver.</p>

<p>De façon plus bizarre, il existe aussi des fonctions, que l’on sait calculable, mais dont on ne connait pas l’algorithme pour les calculer. Par exemple :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def f(n):
    si il existe n "5" consécutifs dans les décimals de π:
        rend 1
    sinon:
        rend 0
</code></pre></div></div>

<p>La fonction ci-dessus est :</p>

<ul>
  <li>soit constante et $f(n) = 1$ pour tout $n$ (ce qui est calculable)</li>
  <li>soit il existe $n_0$ tel que pour tout $n \geq n_0$ ont ait $f(n) = 0$ et avant $f(n) = 1$ ($f$ revient à faire un test sur $n$, ce qui est aussi calculable).</li>
</ul>

<p>Elle est donc calculable, mais on ne sait pas quel algorithme c’est (cas on ne sais pas si π est <a href="https://fr.wikipedia.org/wiki/Nombre_univers">un nombre univers</a>).</p>

<h3 id="calculabilité-et-décidabilité">calculabilité et décidabilité</h3>

<p>Décidabilité et calculabilité sont les deux faces d’une même pièce :</p>

<blockquote class="note">
  <p>Si une fonction $f: \mathcal{F} \rightarrow \{0, 1\}^\star$ est <strong>calculable</strong> alors $\{ (a, f(a) \mid a \in \mathcal{F}\}$ est <strong>reconnaissable</strong>.</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Si $f: \mathcal{F} \rightarrow \{0, 1\}^\star$ est calculable, l’algorithme $M$ prenant en entrée deux mots $a$ et $b$ et qui rend <em>Vrai</em> si $f(a) = b$ et ne s’arrête pas sinon est bien tel que $\mathcal{L}(M) = \{ (a, f(a) \mid a \in \mathcal{F}\}$.</p>

</div></details>

<p>Et si $f$ est défini sur tout mot (ce qui est très souvent le cas) on a même :</p>

<blockquote class="note">
  <p>Une fonction $f: \{0, 1\}^\star \rightarrow \{0, 1\}^\star$ est <strong>calculable</strong> si et seulement si $\{ (a, f(a) \mid a \in \{0, 1\}^\star\}$ est <strong>décidable</strong>.</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Si $f: \mathcal{F} \rightarrow \{0, 1\}^\star$ est calculable, l’algoithme $M$ prenant en entrée deux mots $a$ et $b$ et qui rend <em>vrai</em> si $f(a) = b$ et <em>faux</em> sinon est bien un décideur sur $\{ (a, f(a) \mid a \in \{0, 1\}^\star\}$</p>

<p>Réciproquement, soit $M$ un décideur sur $\{ (a, f(a) \mid a \in \{0, 1\}^\star\}$, l’algorithme $M’$ qui prend itérativement tous les mots $b$ et qui rend $b$ lorsque $M(a, b)$ rend <em>vrai</em> est bien fini pour tout $a$ et calcule bien $f(a)$.</p>

</div></details>

<h3 id="fct-non-calculable">fonctions non calculables</h3>

<p>Comme il suffit d’exhiber un algorithme pour montrer qu’une fonction est calculable, presque toutes les fonctions auxquelles on peut penser le sont. Pour trouver des fonctions non calculables, il faut chercher des exemples tordus.</p>

<p>Nous en donnons une ici, la plus célèbre : <a href="https://fr.wikipedia.org/wiki/Castor_affair%C3%A9">les castors affairés</a> (<em>busy beavers</em> dans la verion originale):</p>

<blockquote class="note">
  <p>On définit le <strong>score</strong> $\rho(M)$ d’une machine de Turing $M$ acceptant le mot vide comme étant le nombre de $1$ de $M()$.</p>

  <p>La fonction du <strong>castor affairé</strong> $\Sigma : \mathbb{N} \rightarrow \mathbb{N}$ est définie telle que $\beta(n)$ vaut le score maximal pour toutes les machine de Turing à $n$ états acceptant le mot vide.</p>

</blockquote>

<p>La fonction est bien définie pour tout $n&gt;0$ puisqu’il n’y a qu’un nombre fini de machine de Turing à $n$ états : la valeur $\beta(n)$ est un maximum d’un ensemble fini, ce nombre existe.</p>

<blockquote class="note">
  <p>$\beta(n) \geq n - 1$ pour tout $n &gt;0$</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Considérons la machine $M_n$ à $n$ états $(q_0, \dots, q_{n-1}) telle que :</p>

<ul>
  <li>$q_0$ est l’état initial</li>
  <li>$q_{n-1}$ l’état d’acceptation</li>
  <li>la fonction de transition $\delta$ telle que $\delta(q_i, \sharp) = (q_{i+1}, 1, \rightarrow)$</li>
</ul>

<p>On a $M_n() = \underbrace{1\cdots 1}_{n-1}{}$.</p>
</div></details>

<blockquote class="note">
  <p>$\beta(n)$ est strictement croissante</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Soit $B_n$ une machine à $n$ états telle que $\rho(B_n) = \beta(n)$. La machine obtenue en enchaînant $B_n$ et $M_1$ (voir preuve précédente) en associant l’état final de $B_n$ à l’état initial de $M_1$ a $n+1$ états (les état de B_n$ plus l’état d’acceptation de $M_1$) et sa sorite produit un 1 de plus que $\beta_n$ : $\beta(n+1) \geq \beta(n) + 1$.</p>

</div></details>

<p>Ce qui nous permet de prouver que :</p>

<blockquote class="note">
  <p>La fonction $\beta$ est non calculable.</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Supposons que $\beta$ soit calculable. Il existe alors une machine $F$ de pseudo code :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def F(n):

efface l'entrée du ruban

i = 0
tant que i &lt; 2 * β(n):
    écrire 1 sur le ruban et décaler le curseur un cran à droite
    i = i + 1
</code></pre></div></div>

<p>On peut supposer, sans perte de généralité, que l’entrée de $F$ soit uniquement composée de $1$(donc $n$ signifie que l’entrée est composée de n $1$ consécutifs).</p>

<p>De là, on peut également construire la machine $M$ :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def M():
    M_n()
    déplace le curseur à gauche jusqu'à obtenir un blanc puis déplace le curseur d'un cran à droite
    F(n)
</code></pre></div></div>

<p>Cette machine enchaîne $M_n$ à $F$. Pour la sorite de $M_n()$ soit l’entrée de $F$, il faut décaler le ruban pour le placer jusqu’au premier 1 (ceci se fait avec une machine à 3 états). Cette machine à un nombre d’états égal au nombre d’état de $M_n$ plus le nombre d’état de la machine qui déplace le ruban (3) plus le nombre d’état de $F$ (disons $k$) moins les liants entre les machines (les états finaux des machines intermédiaires sont les états initiaux des machines suivantes), c’est à dire 2. Au final, la machine $M$ à : $n + 3 + k - 2 = n + k +1$ états et est telle que $\rho(M) = \beta(2n)$.</p>

<p>On en déduit l’inégalité : $\beta(n + k + 1) \geq \beta(2n)$ et comme $\beta$ est strictement croissante on a l’inégalité : $2n \leq n + k + 1$ pour tout $n &gt; 0$ ce qui est impossible.</p>

</div></details>

<blockquote>
  <p>L’<a href="https://www.gwern.net/docs/cs/1962-rado.pdf">article</a> de Tibor Radò où les busy beavers sont définis.</p>
</blockquote>

<h2 id="réels-calculables">réels calculables</h2>

<p>Tous les entiers sont calculables, il suffit de créer une machine qui écrit l’entier désiré sur le ruban. Comme les réels ont une notation décimale avec ne infinité de chiffre, on ne peut de toute façon  pas les écrire sur le ruban en temps fini. Certains d’entre eux sont cependant approchable d’aussi prêt que l’on veut à partir d’une machine de Turing :</p>

<blockquote class="note">
  <p>Un réel $x$ est calculable s’il existe une machine de Turing $X$ à un paramètre tel que :</p>

  <ul>
    <li>$X(0)$ rend la partie entière de $x$</li>
    <li>$X(i)$ rend la $i$-ème décimale de $x$, pour tout $i &gt; 0$</li>
  </ul>

</blockquote>

<p>Il existe d’autres définitions équivalentes, voir <a href="https://fr.wikipedia.org/wiki/Nombre_r%C3%A9el_calculable">cette page wikipédia</a>, des nombres calculable.</p>

<h3 id="exemples-de-réels-calculables">exemples de réels calculables</h3>

<p>Un cas particulier important est lorsque le nombre est la limite d’une suite $u_n$ :</p>

<blockquote class="note">
  <p>Si $x$ est la limite d’une suite $(u_n)_{n \geq 0}$ et qu’il existe une machine de Turing $M$ telle que $M(n) = u_n$ pour tout $n$, alors $x$ est calculable.</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Comme $u_n$ converge vers $x$, pour tout $i&gt; 0$, il existe $N_i$ tel que $\mid x - u_n\mid &lt; 10^{-i}$ pour tout $n &gt; N_i$. Si l’on veut calculer la $i$-ème décimale de $x$, Il suffit de calculer $u_{N_{i}}$ et de prendre sa $i$-ème décimale</p>

</div></details>

<p>Par exemple, $\pi$ est calculable en utilisant <a href="https://fr.wikipedia.org/wiki/Formule_de_Leibniz#S%C3%A9rie_altern%C3%A9e">la série de Leibniz de $\pi$</a>. De la même manière, on peut calculer $cos(x)$, $sin(x)$ ou encore $\sqrt{x}$ pour tout $x$ calculable grâce à leur <a href="https://fr.wikipedia.org/wiki/Formulaire_de_d%C3%A9veloppements_en_s%C3%A9ries">développement en séries entières</a>.</p>

<blockquote class="note">
  <p>Si l’on pense à un réel calculé à partir d’une fonction mathématique usuelle, il y a toute les chances qu’il soit calculable</p>
</blockquote>

<h3 id="exemples-de-réels-non-calculables">exemples de réels non calculables</h3>

<p>On l’<a href="/cours_informatique/cours/algorithme-code-theorie/theorie/fonctions.html#r-et-n">a démontré</a>, il y a beaucoup plus de réels que de nombres entiers et il y a au plus autant d’algorithmes différents que de nombres entiers. Il y a donc de très nombreux réels qu’on ne peut pas calculer, et beaucoup plus qu’on ne peux en calculer.</p>

<p>Il est cependant dur d’en trouver un car tout ceux auxquels on peut penser sont soit des limites de suites, soit combinaison de fonctions calculables… Les exemples de nombres non calculables sont donc tordus.</p>

<p>Nous allons en montrer un nombre non calculable, le <a href="https://fr.wikipedia.org/wiki/Om%C3%A9ga_de_Chaitin#Le_%C2%AB_nombre_de_Turing_%C2%BB">nombre de Turing</a>, dérivé du célèbre<a href="https://fr.wikipedia.org/wiki/Om%C3%A9ga_de_Chaitin">nombre oméga de Chaitin</a>, lui aussi non dénombrable.</p>

<p>Comme il n’existe qu’un nombre dénombrable de machine de Turing (moins ou égal aux nombres d’entiers), on peut les ranger selon un ordre : $M_1$ première machine de Turing, $M_2$ deuxième machine de Turing, etc.</p>

<p>Le nombre de Turing $T$ est un réel entre 0 et 1 tel que sa $i$-ème décimal soit :</p>

<ul>
  <li>égale à 1 si la machine $M_i$ s’arrête pour une entrée vide</li>
  <li>égale à 0 si la machine $M_i$ se s’arrête pas pour une entrée vide</li>
</ul>

<p>Ce nombre n’est évidemment pas calculable car si on pouvait le faire, le problème de l’<a href="#arret">arrêt</a> serait décidable.</p>

<h2 id="fonctions-calculable-rigolotes">fonctions calculable rigolotes</h2>

<p>On va montrer deux exemples de fonctions calculables. L’une qui grossi très très vite (la fonction d’ckermann) et l’autre (la fonction de Takeuchi) qui calcule des choses simples de façon compliquées.</p>

<p>Ces deux fonctions sont parfois utilisées pour des tests de performance d’ordinateurs car est sont très  gourmandes en temps de calcul.</p>

<h3 id="fonction-dackermann">fonction d’ackermann</h3>

<p>La <a href="https://fr.wikipedia.org/wiki/Fonction_d%27Ackermann">fonction d’Ackermann</a>, outre le fait qu’elle est rigolote car elle croît très très rapidemnt (plus que factoriel, c’est dire), est importante téoriquement car c’est la première fonction connue que l’on ne peut pas écrire avec des boucles <code class="language-plaintext highlighter-rouge">for</code>. On est obligé d’utiliser soit des boucles <code class="language-plaintext highlighter-rouge">while</code> pour écrire son pseudo-code de façon itérative, soit d’utiliser la récursivité (ce que l’on va faire).</p>

<blockquote>
  <p>Notez que tout algorithme récursif peut s’écrire de façon itérative. C’est ce quel’on appelle la décurryfication.</p>
</blockquote>

<p>Elle se définit de la manière suivante, pour tous entiers m et n positifs :</p>

\[A(m, n) = \left\{
    \begin{array}{ll}
        n + 1 &amp; \mbox{si } m = 0 \\
        A(m - 1, 1) &amp; \mbox{si } n = 0 \\
        A(m - 1, A(m, n - 1)) &amp; \mbox{sinon.}
    \end{array}
\right.\]

<blockquote class="note">
  <p>La fonction d’ackermann est bien définie pour tout $m$ et $n$ entiers.</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Pour chaque appel récursif de la fonction d’ackerman, soit m, soit $n$ est strictement plus petit dans la fonction appelée que dans la fonction appelante. On arrivera donc toujours à $m = 0$ qui stoppera la récursion ou $n = 0$ qui fera baisser la valeur de $m$.</p>
</div></details>

<p>Le nombre de récursion est très très important. Pour calculer $A(2, 3)$ par exemple, on a les récurrences suivantes :</p>

<ul>
  <li>$A(2, 3) = A(1, A(2, 2))$</li>
  <li>$A(2, 2) = A(1, A(2, 1))$</li>
  <li>$A(2, 1) = A(1, A(2, 0))$</li>
  <li>$A(2, 0) = A(1, 1)$</li>
  <li>$A(1, 1) = A(0, A(1, 0))$</li>
  <li>$A(1, 0) = A(0, 1) = 2$</li>
  <li>puis on remonte d’un cran et les récursions recommencent…</li>
</ul>

<p>Au final on trouve $A(2, 3) = 9$. La fonction croît très très vite. Par exemple $A(5, 0) = A (4, 1) = 65533$ et $A(4, 2) = $2^{65536} - 3$.</p>

<p>Sa complexité est de plus supérieure : il faut plus de $A(m, n)$ opérations pour calculer $A(m, n)$ puisque l’on ne fait qu’ajouter 1 à n comme calcul et les valeurs de n sont modifiées de +1 ou -1.</p>

<h3 id="fonction-de-takeuchi">fonction de Takeuchi</h3>

<p>La <a href="https://fr.wikipedia.org/wiki/Fonction_de_Takeuchi">fonction de Takeuchi</a> peut être vue comme une illustration du <a href="/cours_informatique/cours/algorithme-code-theorie/theorie/decidabilite.html#theoreme-rice">Théorème de Rice</a>, bien malin qui sait ce qu’elle fait juste ne la regardant.</p>

<p>Elle est définie pour tous entiers $x$, $y$ et $z$ telle que :</p>

\[\tau(x, y, z) = \left\{
    \begin{array}{ll}
         y &amp; \mbox{si } x \leq y\\
        \tau(\tau(x-1, y, z), \tau(y-1, z, x), \tau(z-1, x, y)) &amp; \mbox{sinon.}
    \end{array}
\right.\]

<p>Le nombre de récurrence est très élevé et pourtant, on peut montrer qu’elle calcule :</p>

<p>\(\tau(x, y, z) = \left\{
    \begin{array}{ll}
        y &amp; \mbox{si } x \leq y\\
        z &amp; \mbox{si } x &gt; y \mbox{ et } y \leq z\\
        x &amp; \mbox{si } x &gt; y \mbox{ et } y &gt; z\\
    \end{array}
\right.\)</p>
<details><summary>preuve</summary><div>
<p>Par récurrence sur $x+y+z= k$.</p>

<p>Si $x+y+z=0$, on a  $x=y=z=0$ et $\tau(0, 0, 0) = 0$, la récurrence est vérifiée. On suppose la récurrence vraie pour $x+y+z=k$.</p>

<p>Pour $x+y+z=k+1$, on analyse tous les cas possibles :</p>

<ul>
  <li>$x \leq y$ : Ok</li>
  <li>$x &gt; y$ et $y \leq z$ : On a $\tau(x, y, z) = \tau(\tau(x-1, y, z), \tau(y-1, z, x), \tau(z-1, x, y))$ :
    <ul>
      <li>on a $y-1 \leq z$ donc (par hypothèse de récurrence) $\tau(y-1, z, x) = z$</li>
      <li>soit $x-1 &gt; y$ et $y \leq z$ et alors (par hypothèse de récurrence) $\tau(x-1, y, z) = z$ : $\tau(x, y, z) = \tau(z, z, ?) = z$</li>
      <li>soit $x-1 \leq y$ et alors (par hypothèse de récurrence) $\tau(x-1, y, z) = y$ : $\tau(y, z, ?) = z$ (puisque $y \leq z$)</li>
    </ul>
  </li>
  <li>$x &gt; y &gt; z$ : On a $\tau(x, y, z) = \tau(\tau(x-1, y, z), \tau(y-1, z, x), \tau(z-1, x, y))$
    <ul>
      <li>on a $z-1 &lt; y&lt; x$ et donc $\tau(x, y, z) =  \tau(\tau(x-1, y, z), \tau(y-1, z, x), x)$</li>
      <li>on procède de même que précédemment en analysant tous les cas
        <ul>
          <li>$x-1 &gt; y$ et $y-1&gt;z$ : $\tau(x, y, z) = \tau(x-1, x, x) = x$</li>
          <li>$x-1 &gt; y$ et $y-1=z$ : $\tau(x, y, z) = \tau(x-1, z, x) = x$</li>
          <li>$x-1 = y$ et $y-1&gt;z$ : $\tau(x, y, z) = \tau(y, x, x) = x$</li>
          <li>$x-1 = y$ et $y-1=z$ : $\tau(x, y, z) = \tau(y, z, x) = x$</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
</div></details>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique de François Brucker.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
