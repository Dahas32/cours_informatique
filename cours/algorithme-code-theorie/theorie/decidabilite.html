<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Décidabilité | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="Décidabilité">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique de François Brucker.">
<meta property="og:description" content="Support de cours/td d’informatique de François Brucker.">
<link rel="canonical" href="/cours_informatique/cours/algorithme-code-theorie/theorie/decidabilite.html">
<meta property="og:url" content="/cours_informatique/cours/algorithme-code-theorie/theorie/decidabilite.html">
<meta property="og:site_name" content="cours d’informatique">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Décidabilité">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","description":"Support de cours/td d’informatique de François Brucker.","headline":"Décidabilité","url":"/cours_informatique/cours/algorithme-code-theorie/theorie/decidabilite.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Décidabilité</h1>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/algorithme-code-theorie/">Algorithme, code et théorie</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/theorie/">théorie</a> / <a href="/cours_informatique/cours/algorithme-code-theorie/theorie/decidabilite.html">décidabilité</a></p>

  <p>prérequis :</p>

  <ul>
    <li><a href="/cours_informatique/cours/algorithme-code-theorie/theorie/algorithmes-fonctions-pseudo-code.html">Algorithmes, fonctions et pseudo-code</a></li>
  </ul>
</blockquote>

<p>On a vu dans la partie <a href="/cours_informatique/cours/algorithme-code-theorie/theorie/fonctions.html">fonctions</a> qu’un algorithme ne pouvait pas tout calculer, qu’il y a avait même bien plus de choses qu’on ne pouvait pas faire avec un algorithme que de chose qu’on pouvait faire avec.</p>

<p>Nous allons étudier le problème sous l’angle de <em>décidabilité</em>, c’est à dire de savoir si un problème donné admet un algorithme pour le résoudre.</p>

<blockquote>
  <p>on peut aussi regarder le problème sous l’angle de la <a href="/cours_informatique/cours/algorithme-code-theorie/theorie/calculabilite.html">calculabilité</a>, c’est à dire de savoir si telle fonction ou tel nombre peut être calculé par un algorithme.</p>
</blockquote>

<p>Ce qui faut retenir de cette partie :</p>

<ul>
  <li>un décideur est un algorithme spécifique à un problème de décision donné. Il répond oui si l’entrée admet une réponse au problème et non sinon</li>
  <li>savoir si un algorithme va s’arrêter est un problème indécidable</li>
  <li>connaitre les algorithmes qui résolvent tel ou tel problème est indécidable</li>
</ul>

<h2 id="problèmes-de-décision">problèmes de décision</h2>

<p>Commençons par définir un <em>problème de décision</em> :</p>

<blockquote class="note">
  <p>Un <strong>problème de décision</strong>, est une question qui ne peut avoir que deux réponses <em>vrai</em> ou <em>fausse</em> selon l’entrée donnée.</p>
</blockquote>

<p>Par exemple le problème suivant est un problème de décision :</p>

<ul>
  <li>
<strong>nom</strong> : premier</li>
  <li>
<strong>entrée</strong> : un nombre $n$</li>
  <li>
<strong>question</strong> : $n$ est-il un nombre premier ?</li>
</ul>

<p>Un problème de décision est <strong>décidable</strong>,  si on peut lui associer un algorithme (on dit un <em>décideur</em>) qui répond comme lui :</p>

<blockquote class="note">
  <p>Un <strong>décideur</strong> est un algorithme qui pour toute entrée, répond <em>Vrai</em> ou <em>faux</em></p>
</blockquote>

<p>Le problème de décision <em>premier</em> admet un décideur (il suffit de tester tous les entiers plus petit que $n$ pour voir si le reste de la division entière vaut 0), mais ce n’est pas de tous les les problèmes.</p>

<p>Par exemple le problème suivant <a href="#arret">n’admet pas de décideur</a>, il est <strong>indécidable</strong> :</p>

<ul>
  <li>
<strong>nom</strong> : arrêt</li>
  <li>
<strong>entrées</strong> : un algorithme $A$, et une entrée $E$</li>
  <li>
<strong>question</strong> : L’algorithme $A$ s’arrête-t-il avec $E$ comme entrée ?</li>
</ul>

<p>La décidabilité est donc le fait de savoir si on peut reconnaitre l’ensemble $L$ des entrées qui satisfont une propriété donnée :</p>

<blockquote class="note">
  <p>Un ensemble de mots $L$ est décidable s’il existe un <strong>décideur</strong> qui répond <em>vrai</em> si l’entrée est dans $L$ et <em>faux</em> sinon.</p>
</blockquote>

<p>Il existe un cas plus faible que la décidabilité, c’est la <em>reconnaissabilité</em> :</p>

<blockquote class="note">
  <p>Un ensemble de mots $L$ est <strong>reconnaissable</strong> s’il existe un algorithme $M$ telle que $L = \mathcal{L}(M)$ (l’algorithme ne va s’arrêter que pour les entrées de $L$)</p>
</blockquote>

<p>Notez que tout problème décidable est reconnaissable (à la place de répondre <em>Faux</em> on boucle indéfiniment), mais ce n’est pas le cas de tous les problèmes (<a href="#poli-z">ce problème</a> par exemple).</p>

<h2 id="exemples">exemples</h2>

<p>Nous allons montrer ici trois exemples de problèmes décidable ou non qui sont fondamentaux.</p>

<h3 id="poli-z">racines de polynômes à coefficients dans $\mathbb{Z}$</h3>

<p>Soit le problème de décision suivant :</p>

<ul>
  <li>
<strong>nom</strong> : racine polynôme</li>
  <li>
<strong>entrées</strong> : $P(X)$ un <a href="https://fr.wikipedia.org/wiki/Polyn%C3%B4me">polynôme</a> à coefficients dans $\mathbb{Z}$</li>
  <li>
<strong>question</strong> : $P(X)$ Possède-t-il une <a href="https://fr.wikipedia.org/wiki/Racine_d%27un_polyn%C3%B4me">racine</a> dans $\mathbb{N}$ (un entier $a$ tel que $P(a) = 0$) ?</li>
</ul>

<details><summary>ce problème est reconnaissable</summary><div>
<p>On peut facilement créer un algorithme qui, à partir d’un polynôme $P(x)$ à coefficients dans $\mathbb{Z}$ et d’un entier $a$ calcule $P(a)$.</p>

<p>Il suffit ensuite d’essayer tous les entiers un à un. Si le polynôme en entrée admet une racine entière, on va bien tomber dessus à un moment donné.</p>

</div></details>

<details><summary>il est même décidable</summary><div>
<p>Soit $P(X) = \sum_{i=0}^na_iX^i$ (avec $a_n \neq 0$) un polynôme. On va montrer que pour tout $\mid X \mid &gt; \max( 1, \frac{\sum_{i=0}^{n-1}\mid a_i\mid}{\mid a_n\mid})$, on a $\mid P(X)\mid &gt; 0$.</p>

<p>Toutes les racine du polynôme seront donc plus petites que $\frac{\sum_{i=0}^{n-1}\mid a_i\mid}{\mid a_n\mid}$ et on pourra stopper l’algorithme d’énumération au bout d’un nombre fini d’itérations.</p>

<p>On a en effet la suite d’implications :</p>

\[\begin{array}{lcll}
    \mid X \mid &amp; &gt; &amp; \frac{\sum_{i=0}^{n-1}\mid a_i\mid}{\mid a_n\mid}&amp;\mbox{et } \mid X \mid &gt; 1\\
    \mid a_n X^n \mid &amp; &gt; &amp; \sum_{i=0}^{n-1}(\mid a_i X^{n-1} \mid)&amp;\\
    \mid a_n X^n \mid &amp; &gt; &amp; \mid a_{n-1}X^{n-1}\mid + \mid X \mid \cdot \sum_{i=0}^{n-2}(\mid a_i X^{n-2} \mid)&amp;\\
    \mid a_n X^n \mid &amp; &gt; &amp; \mid a_{n-1}X^{n-1}\mid + \sum_{i=0}^{n-2}(\mid a_i X^{n-2} \mid)&amp; \mbox{car } \mid X \mid &gt; 1\\
    \mid a_n X^n \mid &amp; &gt; &amp; \dots&amp;\\
    \mid a_n X^n \mid &amp; &gt; &amp; \sum_{i=0}^{n-1}\mid a_i X^{i} \mid&amp;\\
    \mid a_n X^n \mid &amp; &gt; &amp; \mid \sum_{i=0}^{n-1} a_i X^{i} \mid&amp;\\
\end{array}\]

<p>qui prouvent que $\mid P(X) \mid = \mid a_nX^n + \sum_{i=0}^{n-1} a_i X^{i}\mid$ sera toujours non nul et du signe de $a_n$ pour tout $\mid X \mid &gt; \max( 1, \frac{\sum_{i=0}^{n-1}\mid a_i\mid}{\mid a_n\mid})$</p>
</div></details>

<p>En revanche le problème suivant qui en est une généralisation n’est pas décidable, bien qu’il reste reconnaissable :</p>

<ul>
  <li>
<strong>nom</strong> : racine polynôme plusieurs variables</li>
  <li>
<strong>entrées</strong> : $P(X)$ un <a href="https://fr.wikipedia.org/wiki/Polyn%C3%B4me_en_plusieurs_ind%C3%A9termin%C3%A9es">polynôme à plusieurs variables</a> à coefficients dans $\mathbb{Z}$</li>
  <li>
<strong>question</strong> : $P(X)$ Possède-t-il une <a href="https://fr.wikipedia.org/wiki/Racine_d%27un_polyn%C3%B4me">racine</a> dans $\mathbb{N}$ (un entier $a$ tel que $P(a) = 0$) ?</li>
</ul>

<blockquote class="note">
  <p><em>“racine polynôme plusieurs variables”</em> est un problème <strong>reconnaissable</strong> mais <strong>indécidable</strong>.</p>
</blockquote>
<details><summary>élément de la preuve</summary><div>
<p>Cela a été <a href="https://fr.wikipedia.org/wiki/Th%C3%A9or%C3%A8me_de_Matiiassevitch">démontré en 1970 par Matiiassevitch</a> en prouvant que l’on ne pouvait pas borner les racines d’un polynôme à plusieurs variables.</p>

<p>Il n’existe donc pas d’algorithme qui s’arrête au bout d’un temps fini si un polynôme à plusieurs variables n’a pas de racine dans $\mathbb{N}$.</p>

</div></details>

<p><strong>Félicitations !</strong> Vous venez de rencontrer votre premier problème que ne pourra pas résoudre un ordinateur.</p>

<blockquote>
  <p>Ce cas est historiquement important car il correspond au <a href="https://fr.wikipedia.org/wiki/Dixi%C3%A8me_probl%C3%A8me_de_Hilbert">dixième problème de Hilbert</a>.</p>
</blockquote>

<h3 id="arret">arrêt d’un algorithme</h3>

<p>Savoir si un algorithme va s’arrêter, ou pas, sur une entrée est un problème compliqué. Prenez par exemple l’<a href="https://fr.wikipedia.org/wiki/Conjecture_de_Syracuse">algorithme suivant</a> :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">syracuse</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>

</code></pre></div></div>

<p>L’algorithme est très simple : à partir d’un entier $n$, il le divise par 2 s’il est pair ou le multiplie par 3 et ajoute 1 s’il est impair et recommence tant que ce nombre est strictement plus grand que 1.</p>

<blockquote class="a-faire">
  <p>Testez chez vous pour plusieurs nombres, c’est assez bluffant.</p>

  <p>Affichez également la suite de nombre ou la représenter graphiquement pour voir l’évolution de votre nombre d’entrée jusqu’à 1.</p>
</blockquote>

<p>Personne ne sait (à l’heure où je tape ces caractères) si cet algorithme s’arrête pour tout $n$.</p>

<p>De façon plus générale le problème de décision :</p>
<blockquote class="note">

  <ul>
    <li>
<strong>nom</strong> : <a href="https://fr.wikipedia.org/wiki/Probl%C3%A8me_de_l%27arr%C3%AAt">Arrêt</a>
</li>
    <li>
<strong>entrées</strong> :
      <ul>
        <li>un algorithme $A$</li>
        <li>une entrée $E$</li>
      </ul>
    </li>
    <li>
<strong>question</strong> : $A$ s’arrête-t-il avec $E$ comme entrée ?</li>
  </ul>

  <p>est <strong>indécidable</strong>.</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>On doit la preuve à Turing lui-même, qui l’a démontrée dans le cadre de ses machines. Et comme une machine de Turing est équivalente à un algorithme, on peut reprendre directement sa preuve.</p>

<p>Commençons par remarquer qu’un algorithme, tout comme une machine de Turing, peut s’<a href="/cours_informatique/cours/algorithme-code-theorie/theorie/machine-turing.html#mtu">encoder sous la forme d’une suite de 0 et de 1</a>, on peut donc bien passer un algorithme comme paramètre d’entrée d’un algorithme.</p>

<p>On va maintenant supposer qu’un tel décideur existe et notons le <code class="language-plaintext highlighter-rouge">halt(&lt;A&gt;, E)</code> avec <code class="language-plaintext highlighter-rouge">&lt;A&gt;</code> le mot encodant l’algorithme <code class="language-plaintext highlighter-rouge">A</code>. Cet encodeur rend <em>Vrai</em> si l’exécution de <code class="language-plaintext highlighter-rouge">A</code> avec <code class="language-plaintext highlighter-rouge">E</code> va s’arrêter et <em>Faux</em> sinon.</p>

<p>On peut alors créer un  autre algorithme dont le pseudo-code est :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def diag(x):
    if halt(x, x) == 1:
        boucle infinie
    else:
        return Vrai
</code></pre></div></div>

<p>Tout comme <a href="/cours_informatique/cours/algorithme-code-theorie/theorie/fonctions.html#nb-ss-ensemble-N">la preuve du théorème de Cantor</a> cette nouvelle machine va tout casser :</p>

<ol>
  <li>
<code class="language-plaintext highlighter-rouge">diag(x)</code> ne va s’arrêter que si <code class="language-plaintext highlighter-rouge">halt(x, x)</code> est faux</li>
  <li>
<code class="language-plaintext highlighter-rouge">halt(&lt;diag&gt;, x)</code> va répondre 1 que si <code class="language-plaintext highlighter-rouge">diag(x)</code> s’arrête</li>
  <li>
<code class="language-plaintext highlighter-rouge">halt(&lt;diag&gt;, &lt;diag&gt;)</code> va répondre 1 si <code class="language-plaintext highlighter-rouge">diag(&lt;diag&gt;)</code> s’arrête or <code class="language-plaintext highlighter-rouge">diag(&lt;diag&gt;)</code> ne peut s’arrêter que si <code class="language-plaintext highlighter-rouge">halt(&lt;diag&gt;, &lt;diag&gt;)</code> ne s’arrête pas</li>
  <li>contradiction</li>
</ol>

</div></details>

<blockquote>
  <p>Le problème de l’arrêt est souvent donné pour une machine de Turing : on cherche à savoir si une machine de Turing donnée s’arrête ou pas.</p>
</blockquote>

<p>On peut montrer que le cas particulier suivant est lui aussi indécidable :</p>

<blockquote class="note">
  <p>Le problème :</p>

  <ul>
    <li>
<strong>nom</strong> : Arrêt vide</li>
    <li>
<strong>entrée</strong> : un algorithme $A$</li>
    <li>
<strong>question</strong> : $A$ s’arrête-t-il avec une entrée vide ?</li>
  </ul>

  <p>est <strong>indécidable</strong>.</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Si $E$ est une entrée et $A$ un algorithme, il existe un algorithme $A_E$ qui commence par affecter l’entrée $E$ à une variable, puis exécute l’algorithme $A(E)$. On a donc que $A$ s’arête avec $E$ comme entrée si et seulement si $A_E$ s’arrête avec une entrée vide.</p>

<p>De là, un algorithme qui pourrait décider si $A_E$ s’arrête ou non avec une entrée vide déciderait également si $A$ s’arrête avec l’entrée $E$, ce qui est impossible puisque le problème de l’arrêt est indécidable.</p>

</div></details>

<blockquote class="attention">
  <p>Il faut bien comprendre l’énoncé ci-dessus.</p>
</blockquote>

<p>Il n’existe pas de décideur qui prend comme entrée <strong>et</strong> un algorithme <strong>et</strong> une entrée et qui rend <em>Vrai</em> si l’algorithme va s’arrêter : l’algorithme et le mot d’entrée sont les <strong>entrées</strong> du décideur.</p>

<p>Cela ne contredit pas le fait qu’on puisse créer un décideur spécifique à un algorithme qui réponde <em>vrai</em> ou <em>faux</em> selon l’entrée de celui-ci. C’est l’algorithme général, indépendant de l’algorithme à tester, qui n’existe pas.</p>

<blockquote class="note">
  <p>Lorsque l’on parle de décidabilité ou de problème <strong>il faut toujours bien faire attention à ce qui est un paramètre d’entrée et ce qui est donné</strong>.</p>
</blockquote>

<p>Le théorème d’indécidabilité de l’arrêt d’un algorithme est fondamental théoriquement. Il est à la base de nombreux contre-exemples et :</p>

<ul>
  <li>il exhibe le fait qu’il existe des choses que l’on ne peut pas calculer avec un ordinateur</li>
  <li>en creux, il montre qu’on peut tout de même faire beaucoup de choses avec des algorithmes puisqu’il faut chercher des exemples bien tordus pour que ça ne marche pas</li>
</ul>

<h2 id="theoreme-rice">théorème de Rice</h2>

<p>Le <a href="https://fr.wikipedia.org/wiki/Th%C3%A9or%C3%A8me_de_Rice">Théorème de Rice</a> est un exemple d’indécidabilité est fondamental car il montre que l’on ne peut pas <em>a priori</em> savoir ce que va faire un algorithme.</p>

<blockquote class="note">
  <p>Soit $\mathcal{A}$ un ensemble non vide d’algorithmes.</p>

  <p>Le problème :</p>

  <ul>
    <li>
<strong>nom</strong> : propriétés-$\mathcal{A}$</li>
    <li>
<strong>entrée</strong> : un algorithme $A$</li>
    <li>
<strong>question</strong> : Est-ce qu’il existe $A’$ dans $\mathcal{A}$ tel que $A(E) = A’(E)$ pour toute entrée $E$ ?</li>
  </ul>

  <p>est <strong>indécidable</strong>.</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Soit $A0 \in \mathcal{A}$ et $M$ un algorithme. On peut alors construire l’algorithme suivant :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def A-M(x):
    M()
    A0(x)
    return Vrai
</code></pre></div></div>

<p>L’algorithme <code class="language-plaintext highlighter-rouge">A-M</code> est dans $\mathcal{A}$ si et seulement si l’algorithme $M$ s’arrête pour une entrée vide.</p>

<p>On en conclut que si <em>propriétés-$\mathcal{A}$</em> était décidable, alors le problème <em>“Arrêt vide”</em> le serait également, ce qui est impossible.</p>

</div></details>

<p>Ce théorème a de profondes implications. Il montre en effet que l’on ne peut pas a priori savoir ce que va faire un algorithme et, réciproquement que quelque soit la tâche à effectuer on ne peut pas connaître les algorithmes qui l’effectueront.</p>

<p>Par exemple : il est indécidable de savoir si un algorithme calcule $n!$</p>

<blockquote class="attention">
  <p>en revanche il est parfois possible de démonter si un algorithme donné calcule $n!$ ou pas.</p>
</blockquote>

<p>Ceci rend impossible des méthodes automatisées de preuve d’algorithmes. Il est donc nécessaire :</p>

<ul>
  <li>de prouver individuellement tout algorithme que l’on conçoit</li>
  <li>de tester personnellement toute fonction que l’on code</li>
</ul>

<p>Il est <strong>impossible</strong> d’automatiser le processus.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique de François Brucker.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
