<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Hash et sécurité</title>

    <link href="/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet">
    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">

    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Hash et sécurité</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/système/">Système</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/système/sécurité/">Sécurité</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/système/sécurité/intégrité/">Intégrité</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/système/sécurité/intégrité/hash/">Hash et sécurité</a>

</div>
</div>


    
  

  <blockquote>
<p>def, sécurité sémantique, comment en faire à partir de PRP.</p>
</blockquote>
<p>Pour être utilisable en cryptographie, les <a href="/cours_informatique/cours/algorithme-code-th%C3%A9orie/th%C3%A9orie/fonctions-hash">fonctions de hash</a> doivent cependant avoir des propriétés spécifiques.</p>
<p>Deux types de fonctions sont utilisés en sécurité :</p>
<ol>
<li>fonction de hash avec une clé, appelé MAC</li>
<li>fonction de hash avec sans clé, appelé hash cryptographique</li>
</ol>
<h2>MAC</h2>
<h3>Définitions</h3>
<p>Un <em><strong>MAC, Message authentification code</strong></em> est constitué d'une paire :</p>
<ul>
<li>$S: \{0, 1\}^s \times \{0, 1\}^n \rightarrow \{0, 1\}^h$ qui <em><strong>signe</strong></em> en produisant un <em><strong>tag</strong></em> (en utilisant une clé $k$ un message $m$)</li>
<li>$V: \{0, 1\}^s \times \{0, 1\}^n \times \{0, 1\}^h \rightarrow \{0, 1\}$ qui <em><strong>vérifie</strong></em> (en utilisant une clé $k$, un message $m$ et son tag potentiel)</li>
<li>$V(k, m, S(k, m)) = 1$</li>
</ul>
<p>Un MAC est <em><strong>sécurisé</strong></em> si un adversaire efficace ne peut gagner le jeu suivant, nommé <em><strong>existential forgery against a chosen message attack</strong></em>, qu'avec un avantage négligeable :</p>
<ol>
<li>le testeur choisit uniformément une clé $k$</li>
<li>l'adversaire <strong>choisit</strong> q messages $m_1$ et $m_{q}$ à donner au testeur</li>
<li>le testeur renvoie à l'adversaire les $q$ messages signés $S(k, m_1), \dots S(k, m_q)$</li>
<li>l'adversaire répond un couple $(m, t)$ où $m \notin \{m_1, \dots, m_q\}$</li>
<li>l'adversaire gagne si $V(k, m, t) = 1$</li>
</ol>
<pre><code>    
     testeur                            adversaire
    ---------        m1, ..., mq       ------------
    |   k   | &lt;----------------------- |          |  
    |       |  S(k,m1), ..., S(k,mq)   |          |
    |       | -----------------------&gt; |          |
    |       |           (m, t)         |          |
    |       | &lt;----------------------- |          |
    ---------                          ------------

</code></pre>
<p>Ce jeu simule le fait qu'un attaquant peut influencer la teneurs de messages envoyés (en comptant sur un reply lors d'un envoie de mail par exemple) et ne peut forger à son tout un MAC valide.</p>
<h3>Attaque</h3>
<h4>Taille du MAC</h4>
<p>Remarquez qu'un MAC peut toujours être attaqué avec une probabilité au moins négligeable. Pour cela, il suffit de générer tous les tag possibles, il y en a $2^h$, pour obtenir une probabilité de succès de $1/2^h$. Ceci impose que la taille du tag doit être supérieure à $\mathcal{O}(\log_2(n))$ pour que l'adversaire ne puisse avoir une attaque brute force avec un gain non négligeable.</p>
<h4>Replay attack</h4>
<p>Même s'il est impossible de forger un MAC valide, rien n'empêche un attaquant de ré-envoyer un message valide ! Ceci peut avoir son importance si ce message vous envoie de l'argent...</p>
<p>Le MAC ne prévient pas ce genre de soucis directement mais on peut, à la place de signer uniquement $m$, signer $ m || T$ où $T$ est :</p>
<ul>
<li>un numéro de transaction</li>
<li>un code temporel</li>
</ul>
<p>C'est ensuite à l'application réceptrice du message de vérifier que le message est bien valide et n'a pas été ré-envoyé.</p>
<h3>Comment créer des MAC</h3>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>MAC à taille fixe</strong></p>
</div><div class="pl-8 mr-8">
<p>Si $F: \{0, 1\}^s \times \{0, 1\}^n \rightarrow \{0, 1\}^n$ est une PRF, alors :</p>
<ul>
<li>$S(k, m) = F(k, m)$</li>
<li>$V(k, m, t) = (F(k, m) == t)$</li>
</ul>
<p>Est un MAC sécurisé pour tout message de taille $n$.</p>
</div>
</div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Soit $F$ une PRF, $(S, V)$, le MAC qui lui est associé et $A$ un algorithme efficace permettant de gagner au jeu <em>existential forgery against a chosen message attack</em> contre $(S, V)$ avec une probabilité $\epsilon(n)$.</p>
<p>Soit $H$ une fonction réellement aléatoire et $(S^\star, V^\star)$, le MAC qui lui est associé. L'algorithme $A$ ne peut gagner au jeu qu'avec une probabilité inférieure à $1/2^n$ puisque $H$ est uniformément répartie.</p>
<p>On peut maintenant créer un algorithme efficace jouant au jeu de la distinguabilité pour la PRF F :</p>
<pre><code>    testeur ND                                     adversaire
    -----------                             -------------------------
 b  |         |             m               |              ------   |
---&gt;|  k, H   |&lt;----------------------------|--------------|    |   |
    |         |  F(k, m) si b=1 sinon H(m)  |              |    |   |
    |         |-----------------------------|-------------&gt;|    |   |
    |         |                             | m'   (m', t) | A  |   |
    |         |&lt;----------------------------|---  &lt;--------|    |   |
    |         | F(k, m') si b=1 sinon H(m') | r            ------   |    
    |         |-----------------------------|---&gt;                   | rép(b) = (r == t)
    |         |                             |                       |-------------------&gt;   
    -----------                             -------------------------
</code></pre>
<p>Cet adversaire est efficace puisque A l'est et comme A gagne avec un avantage :</p>
<ul>
<li>$\epsilon(n)$ si la sortie est la PRF : $D(F(k,\cdot)) = \epsilon(n)$</li>
<li>inférieur à $1/2^n$ si la sortie est la fonction aléatoire : $D(f) \leq 1/2^n$</li>
</ul>
<p>L'avantage de l'adversaire pour le jeu de la non distinguabilité est supérieur à $\epsilon(n) - 1/2^n$. Comme $F$ est une PRF cet avantage ne peut être que négligeable et donc $\epsilon(n)$ est négligeable.</p>
</div>
</details>     
</div>
<p>Taille non fixée :</p>
<ol>
<li>concaténation avec compteur</li>
<li>xor</li>
</ol>
<blockquote>
<p>TBD : gaffe si pas de compteur on peut forger un message.<br>
TBD : gaffe au padding si cte pas ok. '10000' utilisé ou 'nnnnnn' avec n taille du message.</p>
</blockquote>
<h2>Hash cryptographique</h2>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://fr.wikipedia.org/wiki/Fonction_de_hachage_cryptographique">Hash cryptographique</a></p>
</div>
</div>
<blockquote>
<p>pas de clé. donc la sécurité doit venir d'autre part.</p>
<p>résistant à la collision</p>
</blockquote>
<blockquote>
<p>TBD reprendre la déf ci-dessous et la remettre avec non collision</p>
</blockquote>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Une fonction de hachage $f$ doit avoir les pro propriétés suivantes pour être  <em><strong>cryptographique</strong></em>:</p>
<ol>
<li>elles doivent être utiles (déterministe, facilement calculable et uniforme)</li>
<li>une petite modification de l'entrée doit produire une grosse modification du hash</li>
<li>en connaissant une valeur de hash $h$ il est très difficile de retrouver un $a$ tel que $f(a) = h$</li>
<li>en connaissant $a$ il est très difficile de trouver $b \neq a$ tel que $f(b) = f(a)$</li>
</ol>
</div>
</div>
<h3>Usage</h3>
<p>La non collision permet de stocker les sha plutôt que les valeurs exactes :</p>
<ul>
<li>mots de passe</li>
<li>git</li>
</ul>
<p>Les mots de passe d'un système son normalement stockés sous la forme d'un hash, auquel on ajoute un <em>sel</em> aléatoire. Voir par exemple <a href="https://patouche.github.io/2015/03/21/stocker-des-mots-de-passe/">ce post de blog</a> qui vous explique un peu comment tout ça fonctionne.</p>
<p>ajout de salt : taille du sel ?</p>
<h3>Comment créer des hash cryptographiques</h3>
<h4>taille fixée</h4>
<h4>taille non fixée</h4>
<p><a href="https://fr.wikipedia.org/wiki/Construction_de_Merkle-Damg%C3%A5rd">Merkel Damgard</a> : MD4, MD5, SHA-1 et SHA-2.</p>
<p><a href="https://www.youtube.com/watch?v=s7arHByjSOw">Merkel Damgard preuve</a><br>
sponge paradigme : SHA-3</p>
<h3>Attaque</h3>
<blockquote>
<p>TBD attaque <a href="https://en.wikipedia.org/wiki/Differential_cryptanalysis">differential analysis</a><br>
TBD attaque brute force par anniversaire</p>
</blockquote>
<blockquote></blockquote>
<p>Ici l'utilité réside dans le fait qu'en pratique :</p>
<ul>
<li>la fonction de hash est une injection</li>
<li>il est impossible de trouver un objet ayant un hash donné.</li>
</ul>
<p>La fonction de hash ($f$) peut alors être utilisée comme une serrure ($x$) qui ne s'ouvre que si l'on a la bonne clé (un $a$ tel que $f(a) = x$).</p>
<p>Craquer une fonction hash cryptographique revient soit :</p>
<ul>
<li>à pouvoir trouver 2 éléments $a$ et $a'$ tels que $f(a) = f(a')$ : trouver des collision montrerait que la fonction n'est pas injective et donc $a$ n'est pas une clé unique</li>
<li>pouvoir trouver $a$ tel que $f(a) = x$ en ne connaissant que $x$ : revient à forger une clé en ne connaissant que la serrure.</li>
</ul>
<blockquote>
<p>TBD : attaque par date d'anniversaire en modifiant 2 documents de façon aléatoire (ajouter des espaces/entrée, backspace, ...).<br>
by the way : toujours modifier un document que l'on signe, du coup on est dan le trouver un identique.</p>
</blockquote>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>