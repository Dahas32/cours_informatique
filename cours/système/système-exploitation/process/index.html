<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Process</title>

    <link href="/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet">
    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">

    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Process</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/système/">Système</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/système/système-exploitation/">Système d&#39;exploitation</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/système/système-exploitation/process/">Process</a>

</div>
</div>


    
  

  <p>Un process est l'unité de base d'un programme. Un process contient des données et des instructions pour être exécuté, le tout étant stocké en mémoire.</p>
<h2>Exécution d'un process</h2>
<p>Nous n'allons pas rentrer dans les détails sur ce qu'est une instruction. On y reviendra lorsque l'on parlera précisément des cores.</p>
<p>On va uniquement considérer ici qu'à chaque instruction est associé un byte et que le code d'un process, c'est à dire la suite d'instructions que devra effectuer le processeur, est un tableau $C$ de byte.</p>
<p>L'exécution du process est alors déterminée par un entier $I$ tel que :</p>
<ol>
<li><code>IP</code> vaut initialement 0</li>
<li>on lit l'instruction <code>C[IP]</code> qui est exécutée par le processeur</li>
<li>le processeur exécute l'instruction <code>C[IP]</code></li>
<li>si <code>C[IP]</code> est :
<ul>
<li>l'instruction de fin on stope l'exécution du process</li>
<li>une instruction de saut on affecte à I la valeur du saut</li>
<li>sinon on incrémente $I$</li>
</ul>
</li>
<li>retour en 2.</li>
</ol>
<h2>Organisation en mémoire</h2>
<h3>Instructions simples</h3>
<p>Si la seule instruction est d'afficher un retour à la ligne à l'écran, le code serait quelque chose du genre :</p>
<pre><code>6 : .
5 : .
4 : .
3 : .
2 : .
1 : exit
0 : print
</code></pre>
<h3>Instructions avec paramètre</h3>
<p>Si l'on veut afficher &quot;Hello World&quot; à l'écran, il faut pouvoir stocker la chaîne de caractère &quot;Hello World&quot; dans la mémoire et demander à notre programme de l'afficher. Il ne peut en effet pas y avoir d'instruction différente pour chaque chaîne de caractère à afficher.</p>
<pre><code>15  : .
14  : .
13  : 0
12  : 'd'
11  : 'l'
10  : 'r'
 9  : 'o' 
 8  : 'W'
 7  : ' ' 
 6  : 'o'
 5  : 'l'
 4  : 'l'
 3  : 'e'
 2  : 'H'
 1  : exit
 0  : print 2
</code></pre>
<p>L'instruction print est maintenant différente. Elle indique que le paramètre commence à l'adresse 2.</p>
<p>Ce paramètre est nécessairement séparé du code pour éviter qu'il puisse être exécuté (c'est à dire convertir la chaîne de caractère en instruction).</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>On a fait terminer la chaîne à afficher par le caractère 0, qui est une convention (en C) pour dire que c'est la fin de la chaîne de caractères.</p>
</div>
</div>
<p>Le process doit donc avoir au moins 2 parties distinctes :</p>
<pre><code>paramètres
code
</code></pre>
<p>Chaque constante est adressée par son indice. Il faut donc que le code connaissent exactement la position de la constante en mémoire. Ceci n'est pas toujours possible car peut-être que le code n'est pas exécuté à partir de 0, ce qui casserait tout :</p>
<pre><code>20     : .
19     : .
18     : .
17     : .
 5-16  : 'Hello World\0'
 4     : exit
 3     : print 2
 2     : .
 1     : .
 0     : .
</code></pre>
<p>En revanche, le code connaît la position relative de la constante par rapport à son exécution, ici 3 + 2. Comme le pointeur IP pointe sur la <strong>prochaine instruction</strong>, le code suivant fonctionne donc toujours, le paramètre se trouve 2 cases plus loin que l'instruction courante donc 1 de plus que la prochaine instruction :</p>
<pre><code>20     : .
19     : .
18     : .
17     : .
 5-16  : 'Hello World\0'
 4     : exit
 3     : print IP+1
 2     : .
 1     : .
 0     : .
</code></pre>
<p>Vous pourrez m'objecter, qu'il n'est pas possible d'avoir une commande différente pour chaque saut de paramètre. Cela ferait trop de commande.</p>
<p>Effectivement, ce n'est pas comme ça que c'est géré. On utilise des commandes de taille variables où :</p>
<ul>
<li>le premier byte détermine toujours l'instruction</li>
<li>le second contient le premier paramètre</li>
<li>le troisième le deuxième paramètre s'il y en a</li>
<li>ainsi de suite</li>
</ul>
<p>Comme le processeur les connaît, il incrémentera automatiquement le compteur d'instruction de la taille de l'instruction plus le nombre de ses paramètres. Notre code devient :</p>
<pre><code>21     : .
20     : .
19     : .
18     : .
 6-17  : 'Hello World\0'
 5     : exit
 4     : 3                             // +3 car l'instruction courante est en 3
 3     : print avec un paramètre
 2     : .
 1     : .
 0     : .
</code></pre>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Notez que le paramètre doit être de taille fixe (ici 1 byte) pour que tout fonctionne. Il n'est pas possible pour cette commande de faire des sauts de plus de 255 byte (il faudrait une autre commande qui prend un word à la place d'un byte comme paramètre)</p>
</div>
</div>
<p>Pour des raisons de lisibilité, nous n'allons pas recopier directement le code dans ce qui suit. On va utiliser des règles qui vont faciliter la lecture des programme et qui sont immédiatement transposable :</p>
<ul>
<li>nous n'allons plus numéroter les cases de la mémoire et écrire le programme dans l'ordre de lecture, de haut en bas</li>
<li>nous allons continuer à placer les paramètres dans le corps des commandes</li>
<li>nous allons marquer des labels dans le code pour nous rappeler de l'endroit où aller</li>
<li>on sépare clairement la partie code (nommée .text) de la partie donnée (nommée .data)</li>
<li>nous allons oublier l'instruction exit, lorsque l'on arrive à la fin du code, programme s'arrête</li>
</ul>
<pre><code>section .data

Hello DB &quot;Hello World&quot;, 0

section .text

main:
    print chaîne
</code></pre>
<p>Le code précédent devient alors plus lisible sans perdre de sa généralité :</p>
<ul>
<li>les données sont listées les unes à la suite des autres et ont des noms (qui seront transcrit en décalage dans l'exécution) et des types : DB signifie un tableau de bytes.</li>
<li>le label <code>main:</code> est le label vers le début du code.</li>
</ul>
<h2>Du fichier au programme</h2>
<p>A priori tout programme peut fonctionner uniquement avec des instructions et des valeurs initiales, le étant déterminé pendant l'exécution.</p>
<p>Le fichier stockant le programme est donc uniquement composé des constantes et des instructions. S'il suit exactement ce principe :</p>
<pre><code>code
données
</code></pre>
<p>et que les appels aux constantes sont des déplacements relatifs, le code exécuté peut être stocké directement dans un fichier pour être réutilisé plus tard sans aucun changement.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Le code en mémoire et le code fichier est identique identique</p>
</div>
</div>
<h2>Instructions avec variables</h2>
<p>Regardons le code python suivant :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
</code></pre>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-yellow-500 bg-yellow-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-yellow-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
  <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Écrivez le code comme précédemment. En ajoutant des instructions</p>
<p>Rappelez-vous que le code :</p>
<ul>
<li>ne peut pas posséder de constantes.</li>
<li>les paramètres sont placés après l'appel à l'instruction</li>
</ul>
</div>
</div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>solution</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<pre><code>section .data

i B 0

section .text

main:
    place 0 dans i
    print i
    incrémente i
    si i &lt; 10 saute en main
</code></pre>
</div>
</details>     
</div>
<p>Outre le fait d'inventer des commandes plausibles, on a utilisé une case consacrée à nos données pour stocker une variable (la variable <code class="language-">i</code> du code python)</p>
<p>On remarque que la position de la variable dans la pile ne bouge pas</p>
<p>Ce nest pas très optimisé puisqu'on devra sauvegarder cette variable dans le fichier du code et alourdira inutilement notre fichier. de plus, <code class="language-">i</code> est une variable, elle ne devrait pas être présente dans le code &quot;en dur&quot; mais créée à la volé par le programme.</p>
<h3>Utilisation d'une pile</h3>
<p>La gestion des variable est faite par une <a href="https://fr.wikipedia.org/wiki/Pile_(informatique)">pile</a></p>
<p>Commençons par voir comment tout ceci est fait avant de voir comment l'implémenter en mémoire.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Une <em><strong>pile</strong></em> est une structure de donnée qui comprend deux fonctions :</p>
<ul>
<li>empilage(d) : ajoute l'élément d à la pile et rend son indice de stockage</li>
<li>dépilage() : supprime un élément à la pile</li>
<li>accès(i) : accède au i+1 ème élément de la pile en lecture ou en écriture</li>
</ul>
</div>
</div>
<p>Exemple :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">empile<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
empile<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>accès<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># rendra 2</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>accès<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># rendra 1</span>
dépile<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>accès<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># rendra 1</span>
</code></pre>
<p>Cette structure permet deux choses fondamentale :</p>
<ul>
<li>stocker et supprimer des choses</li>
<li>utiliser les éléments stockés car les accès ne vont pas bouger</li>
</ul>
<p>C'est exactement ce qu'il faut pour gérer des variables.</p>
<p>De plus, une pile se gère comme un tableau ! Soit SP un indice de la mémoire qui contient le dernier élément de la pile.</p>
<ul>
<li>Empiler le byte $x$ dans la pile revient à :
<ul>
<li>décrémenter l'indice SP</li>
<li>placer la valeur $x$ à l'endroit de la mémoire adressée par SP</li>
</ul>
</li>
<li>Accéder au $i+1$ élément de la pile revient à accéder à l'élément placé à SP + i dans la mémoire</li>
<li>Dépiler un élément de la pile revient à incrémenter SP</li>
</ul>
<p>Après les deux premières lignes du programme précédent on a :</p>
<pre><code>SP-1 :         1
SP   :         2
SP+1 :
</code></pre>
<p>De là le code complet est :</p>
<pre><code>section .text

main:
    empile 0
    empile 2
    print [SP]
    print [SP-1]
    dépile
    print [SP]
</code></pre>
<p>Pour continuer nos <a href="https://fr.wikipedia.org/wiki/Sucre_syntaxique">sucres syntaxiques</a> on utilise :</p>
<ul>
<li>SP pour donner la valeur de SP (c'est à dire un indice d'une case mémoire)</li>
<li>[SP] pour donner la valeur de la case mémoire d'indice SP (M[SP] si M est le tableau de mémoire)</li>
</ul>
<p>Ce concept est fondamental. Si vous avez compris, félicitations vous avez compris les pointeurs :</p>
<ul>
<li>SP est un pointeur (une adresse)</li>
<li>[SP] est la valeur pointée</li>
</ul>
<h2>Process en mémoire avec pile</h2>
<pre><code>pile
données
code
</code></pre>
<p>La pile se remplit en diminuant de valeur.</p>
<p>Sa taille est de l'ordre de 10MiB et est déterminée par le système d'exploitation.</p>
<p>La pile est nécessaire à l'exécution du programme mais pas pour sa conception. Le fichier contenant le programme ne contient pas la pile.</p>
<h3>Gestion des variables avec la pile</h3>
<p>Reprenons notre petite boucle python :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
</code></pre>
<p>Et utilisons la pile pour gérer i :</p>
<pre><code>section .text

main:
    empile 0
    print [SP]
    incrémente [SP] 
    si [SP] &lt; 10 saute en main
    dépile
</code></pre>
<p>Où <code>incrémente [SP]</code> signifie $M[SP] += 1$</p>
<ul>
<li>la variable i est créée par empilage et supprimée par dépilage.</li>
<li>c'est toujours le même accès au 1er élément de la pile</li>
</ul>
<p>Cette façon de faire se généralise pour toutes les variables. A chaque bloc de code :</p>
<ul>
<li>au début du bloc on crée toutes les variables du bloc par empilement</li>
<li>pendant le bloc : on accède aux variables toujours avec le même indice</li>
<li>à la fin du bloc : on supprime toutes les variables par dépilage</li>
</ul>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-yellow-500 bg-yellow-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-yellow-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path>
  <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Écrivez le code suivant avec la pile et en utilisant les règles de création et de suppression des variables :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span>
</code></pre>
</div>
</div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>solution</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>On crée une variable pour chaque bloc :</p>
<pre><code>section .text

main:
    empile 0
boucle:
    empile 0
    print [SP+1] + [SP]
    incrémente [SP] 
    si [SP] &lt; 10 saute en boucle
    dépile
    incrémente [SP]
    si [SP] &lt; 20 saute en main
    dépile
</code></pre>
<p>On aurait aussi pu créer les deux variables en une fois :</p>
<pre><code>section .text

main:
    empile 0
    empile 0
boucle:
    print [SP+1] + [SP]
    incrémente [SP] 
    si [SP] &lt; 10 saute en boucle
    place dans [SP] la valeur 0
    incrémente [SP+1]
    si [SP+1] &lt; 20 saute en main
    dépile
</code></pre>
<p>Cette dernière implémentation est cependant moins élégante.</p>
</div>
</details>     
</div>
<p>Toutes les variables sont</p>
<h3>Appels de fonctions</h3>
<p>La pile, si pratique pour gérer toutes nos variables est également d'une efficacité redoutable pour gérer les appels de fonctions.</p>
<p>Prenons le code python :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">ma_fct</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token operator">+</span>i<span class="token punctuation">)</span>

<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  ma_boucle<span class="token punctuation">(</span>i<span class="token punctuation">)</span>
</code></pre>
<p>Et écrivons ce programme avec la pile :</p>
<pre><code>section .text

main:
    empile 0
boucle:
    empile retour
    empile [SP]
    saut ma_fct
retour:
    dépile 
    dépile
    incrémente [SP]
    si [SP] &lt; 10 saute en main
    dépile
    saute en fin
ma_fct:
fct_boucle:
    empile 0
    print [SP+1] + [SP]
    incrémente [SP] 
    si [SP] &lt; 20 saute en fct_boucle
    dépile
    saute en [SP + 2]
fin:
</code></pre>
<p>La pile nous a permis de stocker les paramètres et le saut de retour de la fonction. En appliquant le même principe pour toutes les fonctions :</p>
<ul>
<li>empilage du saut de retour</li>
<li>empilage des paramètres</li>
<li>saut vers la fonction</li>
<li>dépilage des paramètres</li>
<li>dépilage de la valeur de saut de retour</li>
</ul>
<p>On a crée un moyen simple et efficace de gérer des fonctions (c'est même récursif !) C'est ce qu'o appelle une <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#x86-64_calling_conventions">ABI</a>.</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Les appelles et retour de fonctions ont souvent leurs propres instructions qui gèrent le saut, l'empilage et le dépilage de la valeur de retour.</p>
</div>
</div>
<h3>Limitation de la pile</h3>
<p>La pile est un moyen efficace de gérer les variables et les appels de fonctions. Elle possède cependant un inconvénient :</p>
<ul>
<li>on ne peut y placer que des élément dont on connaît la taille</li>
<li>une fois la variable dans la pile, sa taille ne peut plus changer.</li>
</ul>
<p>On ne peut mettre que des choses pas trop grosse, la taille globale de la pile est relativement petite (10MiB), et dont on connaît la taille. De plus une fois que la donnée est dans la pile on ne peut plus modifier sa taille.</p>
<h4>Chaîne de caractères</h4>
<p>Si l'on demande à un utilisateur de taper un texte, ou</p>
<blockquote>
<p>TBD faire exemple</p>
</blockquote>
<h4>Taille changeante</h4>
<p>for i<br>
for j</p>
<p>et i passe au dessus de 255</p>
<h2>Tas</h2>
<p>Allocation dynamique de mémoire</p>
<blockquote>
<p>le tas</p>
</blockquote>
<p>+1 toute les milliseconde. Taille va augmenter. On ne peut pas connaître la taille amx avant de l'exécuter</p>
<h2>bibliothèque partagée</h2>
<h2>forme finale d'un process</h2>
<h3>sur le disque dur</h3>
<p>relocation des bibliothèques partagées</p>
<ul>
<li>mémoire</li>
<li>fichier</li>
</ul>
<h3>en mémoire</h3>
<p>relocation des la bibliothèque partagée</p>
<h2>thread</h2>
<p>ce qui exécute le code unique, mais ce n'est pas toujours le cas.</p>
<p>Exemple calcul matriciel.</p>
<p>Il peut y en avoir plusieurs exécution par process.</p>
<p>process = organisation<br>
thread = exécution</p>
<h2>a dispatcher</h2>
<p>Un process est un ensemble d'instruction exécutées par le système d'exploitation. Tout process est la propriété le l'utilisateur du système qui l'a exécuté. Un process ne peut de plus a priori pas sortir de sa zone d'influence qui est :</p>
<ul>
<li>l'exécution d'une instruction de son code</li>
<li>son espace mémoire réservé</li>
</ul>
<blockquote>
<p>dire que le fichier est le programme qui sera mis en mémoire : code + variables initialisées. La pile va contenir les variables et le tas des valeurs de variables dynamiques (créeés pendant l'exécution du programme) les bibliothèques partagées sont des fonctions utiles au programmes le noyau</p>
<p>TBD image de la segmentation.</p>
<p>process = code + données le tout en mémoire.<br>
On associe à chaque process une unité d'exécution qui exécute les instruction du code une à une. On appelle ça u thread.<br>
Un process peut avoir plusieurs thread.</p>
<p>On lit les instructions une à une.</p>
<p>TBD montrer la séparation mémoire/code<br>
TBD process et thread. Un contexte d'exécution par thread et la mémoire pour le process.<br>
TBD chaque process ne partage pas sa mémoire avec les autres.<br>
La seule chose partagée est les bibliothèques partagée (.dylib ou .so ou .dll) : <a href="https://en.wikipedia.org/wiki/Shared_library">https://en.wikipedia.org/wiki/Shared_library</a><br>
TBD comment se lance un process. Avec les bibliothèques partages (exemple)<br>
noyau | mémoire | data initialisée | code<br>
gestion de la mémoire<br>
plein de process<br>
<a href="https://en.wikipedia.org/wiki/Data_segment">https://en.wikipedia.org/wiki/Data_segment</a></p>
</blockquote>
<p>en vrai :</p>
<pre><code>noyau
pile
bibliothèques partagées : read only
heap
données
code : lecture seule
</code></pre>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>