<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Système d&#39;exploitation</title>

    <link href="/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet">
    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">

    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Système d&#39;exploitation</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/système/">Système</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/système/système-exploitation/">Système d&#39;exploitation</a>

</div>
</div>


    
  

  <p>Le but d'un <a href="https://fr.wikipedia.org/wiki/Ordinateur">ordinateur</a> est d'exécuter des <a href="https://fr.wikipedia.org/wiki/Processus_(informatique)">processus</a>. Pour que chaque processus n'ait pas à tout gérer (accès au processeur, à la mémoire, au disque dur, au réseau, ...) comme on le ferait avec un circuit imprimé par exemple, on utilise un <a href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_d%27exploitation">système d'exploitation</a> (ou <em><strong>OS</strong></em> pour <em>operating system</em>).</p>
<p>Son but est de faire le lien entre le <a href="https://fr.wikipedia.org/wiki/Mat%C3%A9riel_informatique">matériel</a> (<em>hardware</em>) et le <a href="https://fr.wikipedia.org/wiki/Logiciel">logiciel</a> (<em>software</em>).</p>
<p><img src="os.png" alt="os"></p>
<p>Le matériel comporte tous les éléments physique d'une machine :</p>
<ul>
<li>processeur</li>
<li>mémoire</li>
<li>disques dur</li>
<li>clavier, souris, écran</li>
<li>carte réseau</li>
<li>...</li>
</ul>
<p>Que l'on peut regrouper en trois grandes catégories :</p>
<ul>
<li>processeur</li>
<li>mémoire</li>
<li>les <a href="https://en.wikipedia.org/wiki/Peripheral">périphériques</a> ou <em>devices</em> qui regroupent tout le reste. C'est ce qui se branche sur la <a href="https://fr.wikipedia.org/wiki/Carte_m%C3%A8re">carte mère</a>.</li>
</ul>
<p>Les logiciels, que d'un point de vue système on appellera <a href="https://fr.wikipedia.org/wiki/Processus_(informatique)">process</a> ou processus auront besoin pour fonctionner d'accéder :</p>
<ul>
<li>au processeur pour effectuer les différentes opérations de leur code,</li>
<li>à la mémoire pour stocker leurs variables</li>
<li>souvent à des devices comme un disque dur (pour lire un fichiers), à la carte réseau (pour aller lire le contenu du site <a href="https://news.ycombinator.com/">hacker news</a>), en encore au clavier</li>
</ul>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Le but d'un système d'exploitation est double :</p>
<ul>
<li>il doit permettre d'utiliser les devices de l'ordinateur grâce à des <a href="https://fr.wikipedia.org/wiki/Pilote_informatique">drivers</a></li>
<li>il permet l'exécution de process :
<ul>
<li>de façon <a href="https://fr.wikipedia.org/wiki/Programmation_concurrente">concurrente</a> (on peut écrire dans un gdoc tout en écoutant de la musique)</li>
<li>de façon sécurisée : le gdoc ne peut accéder aux variables de l'application jouant de la musique</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://www.youtube.com/watch?v=r2__Rw8vu1M">Parallèle vs concurrent</a></p>
</div>
</div>
<h2>Couches Systèmes</h2>
<p>Un système d’exploitation n'est pas monolithique, il est constitué de multiple partie qui forment un tout cohérent.</p>
<p>L'organisation logicielle d'un ordinateur (ou plus généralement tout système logiciel assez important) est constitué de <em>couches</em>, comme le stipule le</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong><a href="https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering">théorème fondamental de l’ingénierie logicielle</a></strong></p>
</div><div class="pl-8 mr-8">
<p>On peut régler tous les problèmes en ajoutant une couche d'indirection</p>
</div>
</div>
<p>Un autre exemple célèbre de couches en ingénierie système est le découpage en <a href="https://fr.wikipedia.org/wiki/Suite_des_protocoles_Internet">couches d'un réseau</a>. Ce principe universel est une instanciation de la <a href="https://fr.wikipedia.org/wiki/Discours_de_la_m%C3%A9thode#Deuxi%C3%A8me_partie">deuxième partie du discours de la méthode</a> : il faut diviser chaque difficulté en autant de parties facile à résoudre séparément.<br>
D'un point de vue ingénierie, ceci permet en plus de  clairement les responsabilités de chaque couche, une maintenance plus aisée.</p>
<p>Un ordinateur et son utilisation peut être séparé quatre couches :</p>
<ol>
<li>Matériel
<ul>
<li>mémoire RAM</li>
<li>devices</li>
</ul>
</li>
<li>Noyau
<ul>
<li>drivers matériels</li>
<li>gestion de la mémoire</li>
<li>ordonnancement des processus</li>
</ul>
</li>
<li>process
<ul>
<li>interface graphique</li>
<li>terminal</li>
<li>...</li>
</ul>
</li>
<li>utilisateurs
<ul>
<li>qui à le droit de faire quoi</li>
</ul>
</li>
</ol>
<p>Les utilisateurs lancent les process. Ceux-ci s'exécutent de façon parallèle grâce au noyau et utilisent les ressources matériels via des <a href="https://fr.wikipedia.org/wiki/Appel_syst%C3%A8me">appels systèmes</a>.</p>
<h2>Mémoire</h2>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-lime-500 bg-lime-100">
  <svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-lime-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"></path>
  </svg>
<div class="pl-8 mr-8">
<p><a href="m%C3%A9moire" class="interne">Mémoire</a></p>
</div>
</div>
<h2>Système d'exploitation</h2>
<p>Seul le noyau a accès au matériel et a un contrôle total de la machine. Il doit donc être le plus petit possible car le moindre bug fait planter la machine. C'est pourquoi on distingue deux états d'une machine :</p>
<ul>
<li>le <em>kernel mode</em> : le noyau travail</li>
<li>le <em>user mode</em> : un process travaille</li>
</ul>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://learn.microsoft.com/fr-fr/windows-hardware/drivers/gettingstarted/user-mode-and-kernel-mode">User et Kernel mode sous windows 11</a></p>
</div>
</div>
<p>Un système d'exploitation ne peut donc être uniquement composé d'un noyau, ce serait inefficace (rien ne pourrait être exécuté en parallèle) et dangereux (le moindre bug logiciel ou matériel ferait tout planter). On sépare habituellement un système d'exploitation en 3 parties :</p>
<ul>
<li><strong>le</strong> <a href="https://fr.wikipedia.org/wiki/Noyau_de_syst%C3%A8me_d%27exploitation">noyau</a> (<em>kernel</em>) dont le but est de gérer :
<ul>
<li>les appels systèmes</li>
<li>l'ordonnancement des process</li>
<li>communications entre les 3 entités d'un ordinateur (process, matériel, noyau)</li>
</ul>
</li>
<li><strong>des</strong> <a href="https://en.wikipedia.org/wiki/Interface_(computing)#Software_interfaces">interfaces logicielles</a> qui permettent d'accéder aux devices (comme accéder à une clé usb)</li>
<li><strong>des</strong> <a href="https://fr.wikipedia.org/wiki/Daemon_(informatique)">démons</a> qui gèrent l'environnement (le fait de réagir à l'insertion d'une clé usb dans l'ordinateur par exemple)</li>
</ul>
<p>Les démons et les interfaces sont des process comme les autres. Ils sont cependant exécutés par un utilisateur spécial, souvent nommé <a href="https://fr.wikipedia.org/wiki/Utilisateur_root"><code>root</code></a>, qui est le [super-utilisateur] qui est le représentant utilisateur du système.</p>
<p><img src="os-2.png" alt="os 2"></p>
<h2>Utilisateurs</h2>
<p>On peut séparer les utilisateurs d'un système en trois grandes catégorie.</p>
<h3><code>root</code></h3>
<p>L'utilisateur <code>root</code> est l'utilisateur lié au système d'exploitation. Il est le propriétaire des process (démons) et interfaces du système d'exploitation. Cet utilisateur a ainsi tous les droits (peut aller partout, réserver autant de mémoire qu'il veut, etc).</p>
<p>Comme <strong>Tout</strong> processus a un propriétaire, l'existence de cet utilisateur est garantie.</p>
<h3>Administrateurs systèmes</h3>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://fr.wikipedia.org/wiki/Administrateur_syst%C3%A8me">administrateur système</a></p>
</div>
</div>
<p>Ces utilisateurs ont des droits particulier, ils peuvent modifier des paramètres systèmes et exécuter ou stopper des démons. Ces utilisateur ne sont pas forcément root, en effet,  souvent l'utilisateur principal d'une machine est administrateur.</p>
<p>Cela permet, si nécessaire, d'installer ou de configurer son système sans être connecté en tant que root.</p>
<h3>Simple utilisateur</h3>
<p>Enfin, il existe la foule des autres utilisateurs (vous sur les ordinateurs de l'école ou la fac par exemple) qui ne peuvent pas administer la machine, ni lancer de démons. Vous avez en revanche le droit d'exécuter la plupart des process et d'installer vos propres programme dans l'espace disque qui vous est réservé.</p>
<h2>Process</h2>
<p>Un process est l'unité de base d'un programme. Un process est un ensemble d'instruction exécutées par le système d'exploitation. Tout process est la propriété le l'utilisateur du système qui l'a exécuté.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-lime-500 bg-lime-100">
  <svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-lime-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"></path>
  </svg>
<div class="pl-8 mr-8">
<p><a href="process" class="interne">Process</a></p>
</div>
</div>
<h2>Communication avec le Noyau</h2>
<p>Le noyau est partie intégrante de tout process. Il est toujours là et s'exécute de temps en temps pour effectuer ses tâches.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-lime-500 bg-lime-100">
  <svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-lime-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"></path>
  </svg>
<div class="pl-8 mr-8">
<p><a href="noyau" class="interne">Noyau</a></p>
</div>
</div>
<h2>Multi Process</h2>
<p>Les systèmes d'exploitation permettent tous d'exécuter plusieurs threads de façon concurrente :</p>
<ul>
<li>plusieurs thread d'un même process : ils partagent la même organisation en mémoire</li>
<li>plusieurs thread de process différents : chaque process à sa propre organisation en mémoire</li>
</ul>
<p>Ceci peut se passer même si l'ordinateur ne possède qu'un seul core. La quasi totalité des ordinateurs actuellement sont <a href="https://fr.wikipedia.org/wiki/Symmetric_multiprocessing">multi-core</a>, ce qui permet même d'exécuter des threads de façon parallèle.</p>
<p>Chaque thread sur une machine peut–ê†re dans 3 états distincts :</p>
<ul>
<li>bloqué : en attente d'une instruction d'entrée/sortie par exemple</li>
<li>actif : en cours d'exécution</li>
<li>activable : pas en cours d'exécution mais prêt à l'être.</li>
</ul>
<p>Le principe est simple. Prenons l'exemple de 2 threads (A et B) à exécuter sur un unique core. Lorsque le noyau lance l'exécution du premier thread, il va demander au processeur de se faire réveiller au bout de 10ms par une interruption. Le thread A s'exécute donc pendant 10ms avant qu'une interruption ne rappelle le noyau qui va pouvoir stopper le thread A (qu'il va placer en mode activable) et réactiver le thread B (il passe de activable à activé). Une fois ceci fait, le noyau se rendort pour 10ms (via une interruption) et le cycle continue.</p>
<p>Si l'ordinateur possède plusieurs core, le noyau choisi sur quel lancer le thread mais le principe est le même : il se réveille à intervalles déterminés pour gérer l'activation et la désactivation des threads.</p>
<p>Cette activation/ désactivation s'appelle le context switching et n'est pas immédiate, il faut en effet s'assurer que le thread B n'endommage pas l'exécution du thread A.</p>
<h3>Context switching</h3>
<p>L'exécution d'un thread dépend :</p>
<ul>
<li>
<p>de sa mémoire</p>
</li>
<li>
<p>des registres du processeur (IP, SP, et tous les autres)</p>
</li>
<li>
<p>deux thread d'un même process partagent toute la mémoire sauf la pile,</p>
</li>
<li>
<p>deux process différents ne partagent pas la même mémoire sauf le noyau,</p>
</li>
</ul>
<p>Passer d'un thread à l'autre revient donc à :</p>
<ul>
<li>sauver les registres de l'un et restaurer ceux de l'autre</li>
<li>sauver la mémoire de l'un et restaurer la mémoire de l'autre</li>
</ul>
<p>S'il est facile de sauver/restaurer des registres, ce n'est pas la même chose de la mémoire. Il est illusoire de vouloir sauver toute la mémoire d'un process pour restaurer la mémoire de l'autre process, cela prendrait bien trop de temps.</p>
<p>L'idée est de faire croire au thread qu'il est tout seul en mémoire alors qu'en vrai il la partage avec d'autres.</p>
<p>Pour cela, on commence par découper toute la mémoire en <a href="https://en.wikipedia.org/wiki/Page_table">pages</a> (habituellement de 4KiB) et d'avoir une correspondance entre une mémoire logique, celle que voit le thread et la mémoire physique, en RAM.</p>
<p>Comme habituellement un thread n'utilise pas toute la mémoire (loin de là même), la mémoire de plusieurs threads peut tenir dans la mémoire physique sans se gêner :</p>
<pre><code>mémoire physique  thread A    thread B      segments
      a              a           a           noyau
      b              f           b           pile
      c                          
      d
      e
      f              c           c           bibliothèque partagée
      g          
      h              h           g           data
      i              i           j           code
      j
</code></pre>
<p>Passer de la mémoire d'un thread à un autre se fait juste en changeant l'adressage, pas physiquement la mémoire.</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Lorsque la mémoire RAM physique ne suffit plus pour stocker toutes les données de tous les process, le système d’exploitation possède une partie spécifique du disque dur appelée <a href="https://fr.wikipedia.org/wiki/Espace_d%27%C3%A9change">swap</a> qui permet de transférer de la RAM au disque dur et réciproquement si nécessaire.</p>
</div>
</div>
<p>Changer de contexte, et donc d'exécution d'un thread est quelque chose qui va très vite.</p>
<h3>Ordonnancement</h3>
<p>Si changer de contexte d'exécution est quelque chose qui va vite, et donc exécuter plusieurs thread sur un ou plusieurs core quelque chose de facile, si on a plus de thread que de core, savoir quel thread exécuter et quel thread arrêter où peut être difficile.</p>
<blockquote>
<p>TBD ici.</p>
</blockquote>
<p>problème NP-dur sur 2 core : (somme moitié).<br>
sur un core : selon ce qu'on cherche :</p>
<ul>
<li>tous doivent y avoir accès : FIFO (round robin)</li>
<li>priorité et dernière fois qu'ils ont eu accès (celui actuel dans Linux)</li>
<li>finir au plus tôt : le nouveau</li>
</ul>
<p><a href="https://fr.wikipedia.org/wiki/Ordonnancement_dans_les_syst%C3%A8mes_d%27exploitation">ordonnancement des processus</a></p>
<p>Ca va vite. Un switch toutes les 100ms/(nombre thread).</p>
<blockquote>
<p>scheduling :  <a href="https://en.wikipedia.org/wiki/Round-robin_scheduling">https://en.wikipedia.org/wiki/Round-robin_scheduling</a> vers <a href="https://opensource.com/article/19/2/fair-scheduling-linux">https://opensource.com/article/19/2/fair-scheduling-linux</a> <a href="https://en.wikipedia.org/wiki/Completely_Fair_Scheduler">https://en.wikipedia.org/wiki/Completely_Fair_Scheduler</a> (exemple avec 4 process là : <a href="https://www.geeksforgeeks.org/completely-fair-scheduler-cfs-and-brain-fuck-scheduler-bfs/">https://www.geeksforgeeks.org/completely-fair-scheduler-cfs-and-brain-fuck-scheduler-bfs/</a>)<br>
changé là par <a href="https://lwn.net/Articles/925371/">https://lwn.net/Articles/925371/</a><br>
<a href="https://en.wikipedia.org/wiki/Earliest_eligible_virtual_deadline_first_scheduling">https://en.wikipedia.org/wiki/Earliest_eligible_virtual_deadline_first_scheduling</a><br>
<a href="https://en.wikipedia.org/wiki/Earliest_deadline_first_scheduling">https://en.wikipedia.org/wiki/Earliest_deadline_first_scheduling</a></p>
</blockquote>
<h3>Création de process</h3>
<blockquote>
<p>clone puis enfant<br>
process 1 est root : systemd ce qui lance le reste de l'OS puis le login</p>
</blockquote>
<h2>Démarrage de l'ordinateur</h2>
<p>Les différentes étapes du chargement d'un système d'exploitation</p>
<ol>
<li>boot de l'ordinateur</li>
<li>exécution d'un <a href="https://fr.wikipedia.org/wiki/Chargeur_d%27amor%C3%A7age">chargeur d'amorçage (<em>bootloader</em>)</a></li>
<li>charge le noyau
<ol>
<li>vérification du matériel</li>
<li>vérification des sous-systèmes : réseau, ...</li>
</ol>
</li>
<li>passage en user mode puis charge les démons et les interfaces</li>
<li>login</li>
</ol>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>