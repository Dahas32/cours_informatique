<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>preuve d’algorithme | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="preuve d’algorithme">
<meta name="author" content="François Brucker">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<meta property="og:description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<link rel="canonical" href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/preuve-algorithme.html">
<meta property="og:url" content="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/preuve-algorithme.html">
<meta property="og:site_name" content="cours d’informatique">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="preuve d’algorithme">
<script type="application/ld+json">
{"description":"Support de cours/td d’informatique à l’école centrale marseille.","@type":"WebPage","url":"/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/preuve-algorithme.html","headline":"preuve d’algorithme","author":{"@type":"Person","name":"François Brucker"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">preuve d'algorithme</h1>Auteur : <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">François Brucker</span></span>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/">Théorie et pratiques algorithmique</a> / <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/">algorithmie</a> / <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/preuve-algorithme.html">preuve d’algorithme</a></p>

  <p>prérequis :</p>

  <ul>
    <li><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/pseudo-code.html">algorithmie/pseudo-code</a></li>
  </ul>
</blockquote>

<p>Un algorithme a <strong>toujours</strong> un but, quelque chose pour quoi il est fait. Dans notre cas, un algorithme calculera la solution d’un problème.</p>

<p>Pour chaque algorithme que vous créerez ou que l’on demandera d’étudier il faudra :</p>

<ol>
  <li>caractériser le problème que l’algorithme est sensé résoudre</li>
  <li>démontrer que l’algorithme fonctionne, c’est à dire qu’il le résout le problème en temps fini.</li>
</ol>

<p>Prouver qu’un algorithme s’arrête fait partie des problèmes théoriques difficiles en informatique. En algorithmie, les algorithmes résolvent des problèmes et donc ils sont sensés s’arrêter et il sera (normalement) facile de le voir. En revanche, la preuve de l’algorithme est parfois plus délicate. Le problème étant souvent (toujours ?) concentré dans les boucles ou les récursions de l’algorithme, on cherchera à trouver des propriétés qui sont conservées avant et après une itération ou une récursion :</p>

<blockquote class="note">
  <p>Pour prouver un algorithme on cherchera à établir :</p>

  <ul>
    <li>une équation de récurrence plus une condition d’arrêt pour prouver un algorithme récursif.</li>
    <li>
<a href="https://fr.wikipedia.org/wiki/Invariant_de_boucle">un invariant de boucle</a> pour des algorithme itératifs. Ces invariants vont alors être conservés jusqu’à la fin de l’algorithme et nous permettre de prouver son résultat.</li>
  </ul>

</blockquote>

<p>Notez que bien souvent prouver un algorithme et le créer est la même chose. Comprendre comment on peut résoudre un problème donné nous donnera l’algorithme et réciproquement.</p>

<p>A part la recommandation ci-dessus, il n’existe pas vraiment de règles à appliquer pour prouver un algorithme. Seule l’expérience et l’étude des algorithmes classiques vous permettra de trouver facilement comment prouver un algorithme.</p>

<blockquote>
  <p>dans la suite, les algorithmes seront tous donnés en python</p>
</blockquote>

<h2 id="factorielle">factorielle</h2>

<h3 id="facto-rec">algorihtme récursif</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">factorielle</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorielle</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>finitude : Si $n$ est un réel, l’algorithme va s’arrêter : $n$ décroît strictement à chaque appelle récursif et on stoppe si $n \leq 1$.</li>
  <li>preuve : par récurrence sur $n$, avec $n$ entier positif.
    <ul>
      <li>entrée : des entiers positifs</li>
      <li>fonction de récurrence. Si $n=0$ ça marche. Si ça marche pour l’entrée n-1, ça marche pour $n$ car la fonction rend $n \cdot \mbox{factorielle}(n-1)$ qui vaut $n \cdot (n-1)!$ par hypothèse de récurrence.</li>
    </ul>
  </li>
</ul>

<h3 id="facto-iter">algorithme itératif</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">factorielle</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">*=</span> <span class="n">n</span>
        <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">r</span>
</code></pre></div></div>

<blockquote>
  <p>On utilise la possibilité que donne python d’écrire <code class="language-plaintext highlighter-rouge">x += y</code> (<em>resp.</em> <code class="language-plaintext highlighter-rouge">x -= y</code>, <code class="language-plaintext highlighter-rouge">x *= y</code> ou encore <code class="language-plaintext highlighter-rouge">x /= y</code>) à la place de <code class="language-plaintext highlighter-rouge">x = x + y</code> (<em>resp.</em> <code class="language-plaintext highlighter-rouge">x = x - y</code>, <code class="language-plaintext highlighter-rouge">x = x * y</code>, <code class="language-plaintext highlighter-rouge">x = x / y</code>).</p>
</blockquote>

<ul>
  <li>finitude : Si $n$ est un entier, l’algorithme va s’arrêter car $n$ décroît strictement à chaque itération de la boucle <code class="language-plaintext highlighter-rouge">while</code>.</li>
  <li>preuve : par invariant de boucle</li>
</ul>

<blockquote class="note">
  <p>Pour les preuves par invariant de boucle, le schéma de preuve est le suivant :</p>

  <ol>
    <li>on vérifie que l’invariant est vrai à la fin de la première itération de la boucle</li>
    <li>on suppose l’invariant à la fin de l’itération $i$ de la boucle et on vérifie qu’il est toujours vérifié à la fin de l’itération $i + 1$.</li>
  </ol>

  <p>Pour simplifier l’écriture, on note avec un <code class="language-plaintext highlighter-rouge">'</code> (prim) les variables à la fin de la boucle d’itération $i+1$ pour les différentier des variables de la fin de l’itération $i$.</p>
</blockquote>

<p>Ici notre invariant est : <em>“A la fin d’une itération de la boucle while : $r = (n+1) \cdot \dots \cdot n_0$ avec $n_0$ la valeur de $n$ passé en argument de la fonction”</em>.</p>

<ol>
  <li>à la fin de la première itération $n = n_0 - 1$ et r = $n_0$ : la propriété est vraie.</li>
  <li>on suppose la propriété vraie à la fin de la $i$ème itération. A la fin de l’itération suivante on a :
    <ul>
      <li>$n’ = n - 1$</li>
      <li>$r’ = r \cdot n$</li>
    </ul>
  </li>
  <li>comme $r = (n+1) \cdot n_0$ on a $\frac{r’}{n} = (n+1) \cdot \dots \cdot n_0$ et donc $r’ = n \cdot (n+1) \cdot \dots \cdot n_0$. On a bien $r’ = (n’+1) \cdot \dots \cdot n_0$</li>
  <li>on en conclut que notre invariant reste vérifié.</li>
</ol>

<p>L’invariant étant vérifié à la fin de chaque itération, il est donc aussi vrai à la fin de la dernière itération. A ce moment là, on a $n=1$ et donc $r = 1 \cdot 2 \cdot \dots \cdot n_0 = n_0!$</p>

<blockquote>
  <p>Il existe des variantes dans les preuve par invariants selon que l’on vérifie juste à la fin de la boucle ou au début et à la fin de l’itération. Les deux formes sont équivalentes, mais il est parfois plus aisée d’utiliser une forme que l’autre.</p>
</blockquote>

<h2 id="maximum-dun-tableau">maximum d’un tableau</h2>

<p>On va voir 2 algorithmes pour calculer la valeur maximum d’un tableau de réels.</p>

<h3 id="max-rec">algorithme récursif</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">maximum</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="n">debut</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">debut</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tableau</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tab</span><span class="p">[</span><span class="n">debut</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">maximum</span><span class="p">(</span><span class="n">tab</span><span class="p">,</span> <span class="n">debut</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tab</span><span class="p">[</span><span class="n">debut</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">tab</span><span class="p">[</span><span class="n">debut</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
</code></pre></div></div>

<blockquote>
  <p>On a utilisé la possibilité d’avoir des <a href="https://docs.python.org/fr/3.9/tutorial/controlflow.html#default-argument-values">arguments par défaut</a> en python. Ceci nous permet d’exécuter la fonction maximum comme si elle n’avait qu’un seul paramètre.</p>
</blockquote>

<ul>
  <li>finitude : début augmente strictement et s’arrête lorsqu’il vaut <code class="language-plaintext highlighter-rouge">len(tableau) - 1</code>
</li>
  <li>preuve : par récurrence sur la longueur d’un tableau. On vérifie que l’algorithme fonctionne pour une longueur de tableau valant 1, puis on effectue preuve par récurrence sur la longueur du tableau.</li>
</ul>

<h3 id="max-iter">algorithme itératif</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">maximum</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">return</span> <span class="n">m</span>
</code></pre></div></div>

<ul>
  <li>finitude : clair car une unique boucle for.</li>
  <li>preuve : par invariant de boucle.</li>
</ul>

<p>Ici notre invariant est : <em>“A la fin de l’itération $i$ de la boucle, $m$ vaut le maximum des $i$ premiers élément du tableau.”</em></p>

<p>Après la première itération de la boucle, comme $m$ vaut initialement le premier élément du tableau, on a que $m=t[0]$ qui est bien le maximum des 1 premier éléments du tableau. L’invariant est vérifié à la fin  de l’itération $1$.</p>

<p>On suppose l’invariant vrai à la fin de l’itération $i$. A la fin de l’itération $i+1$, $m’$ (la valeur de $m$ à l’issue de la boucle d’itération $i + 1$) vaut soit $m$ (la valeur de $m$ au début de la boucle d’itération $i +1 $) soit $x’$ (la variable $x$ affectée lors de) qui vaut la $i + 1$ème valeur du tableau.</p>

<p>Comme l’invariant est vrai à la fin la boucle d’itération $i$, $m$ vaut le maximum du tableau sur les $i$ premiers éléments. Or $m’ = \max(m, x)$, donc $m’$ vaut bien le maximum du tableau sur les $i + 1$ premiers éléments.</p>

<p>Notre invariant est vérifié.</p>

<p>Il est donc aussi vrai à la fin des itérations : $m$ vaut le maximum du tableau à la fin de la boucle for.</p>

<h2 id="division-euclidienne">division euclidienne</h2>

<p>Prouvons l’algorithme de la division euclidienne ci-après :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">euclide</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">q</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">-=</span> <span class="n">b</span>
        <span class="n">q</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</code></pre></div></div>

<p>Notez que le retour de la fonction est un <a href="https://docs.python.org/fr/3/tutorial/datastructures.html#tuples-and-sequences">tuple</a> à 2 éléments (c’est à dire un tableau à 2 éléments que l’on ne peut pas modifer)</p>

<h3 id="finitude">finitude</h3>

<p>le programme s’arrête ? : Oui si a et b sont des entiers positifs. Car</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">r</code> est un entier</li>
  <li>
<code class="language-plaintext highlighter-rouge">r</code> après une itération est <strong>strictement plus petit</strong> que le <code class="language-plaintext highlighter-rouge">r</code> avant itération</li>
  <li>on s’arrête si <code class="language-plaintext highlighter-rouge">r</code> est strictement plus petit que <code class="language-plaintext highlighter-rouge">b</code>.</li>
</ul>

<h3 id="preuve">preuve</h3>

<p>On veut montrer que l’on obtient bien une division euclidienne de $a$ par $b$. C’est à dire que $a = bq + r$ avec $r &lt; b$. Pour cela on va s’aider de l’invariant de boucle : <code class="language-plaintext highlighter-rouge">a = r + q * b</code></p>

<p>Prouvons l’invariant :</p>

<ol>
  <li>l’invariant est bien vrai à la fin de la première boucle puisque $q=1$ et $r=a-b$ à ce moment là.</li>
  <li>on doit prouver que <code class="language-plaintext highlighter-rouge">a' = r' + q' * b'</code> à la fin de la $i+1$ème itération.</li>
  <li>si l’on est passé dans la boucle on a <code class="language-plaintext highlighter-rouge">a'=a</code>, <code class="language-plaintext highlighter-rouge">r' = r - b</code>, <code class="language-plaintext highlighter-rouge">b' = b</code> et <code class="language-plaintext highlighter-rouge">q' = q + 1</code>
</li>
  <li>donc <code class="language-plaintext highlighter-rouge">r' + q' * b' = r-b + (q+1) * b = r + q * b = a = a'</code> puisque l’invariant est vrai à la fin de la $i$ème itération. On a bien <code class="language-plaintext highlighter-rouge">a' = r' + q' * b'</code>, l’invariant est démontré.</li>
</ol>

<p>L’invariant étant juste tout le temps, il l’est en particulier à l’issue de la dernière boucle. A ce moment là on a <code class="language-plaintext highlighter-rouge">a = r + qb</code> avec <code class="language-plaintext highlighter-rouge">r &lt; b</code> ce qui est bien ce qu’il fallait démontrer.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique à l'école centrale marseille.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
