<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>étude / mélanger un tableau | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="étude / mélanger un tableau">
<meta name="author" content="François Brucker">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<meta property="og:description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<link rel="canonical" href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/etude-melange.html">
<meta property="og:url" content="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/etude-melange.html">
<meta property="og:site_name" content="cours d’informatique">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="étude / mélanger un tableau">
<script type="application/ld+json">
{"description":"Support de cours/td d’informatique à l’école centrale marseille.","@type":"WebPage","url":"/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/etude-melange.html","headline":"étude / mélanger un tableau","author":{"@type":"Person","name":"François Brucker"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">étude / mélanger un tableau</h1>Auteur : <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">François Brucker</span></span>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/">Théorie et pratiques algorithmique</a> / <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/">algorithmie</a> / <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/etude-melange.html">étude : mélanger un tableau</a></p>

  <p>prérequis :</p>

  <ul>
    <li><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/etude-exponentiation.html">étude : l’exponentiation</a></li>
  </ul>

</blockquote>

<p>Nous allons étudier ici deux algorithmes permettant de mélanger un tableau. Commençons par identifier le problème. Nous allons utiliser le problème suivant, qui consiste à rendre une permutation des $n$ premiers entiers :</p>

<ul>
  <li>
<strong>nom</strong> : permutation</li>
  <li>
<strong>entrée</strong> : un tableau d’entiers</li>
  <li>
<strong>sortie</strong> : une permutation aléatoire du tableau en entrée</li>
</ul>

<blockquote>
  <p>une permutation d’un tableau $T$ de taille $n$ est un tableau $T’$ de taille $n$ où $T’[i] = T[\sigma(i)]$ avec $\sigma$ une bijection de $[0 .. n-1]$.</p>
</blockquote>

<p>L’algorithme que nous allons montrer ici nécessite que l’on puisse obtenir un entier aléatoire plus petit qu’un nombre donné $n$. On va donc considérer que l’on a une fonction <code class="language-plaintext highlighter-rouge">randint</code> de complexité $\mathcal{O}(1)$ qui résout le problème “randint” suivant :</p>

<ul>
  <li>
<strong>nom</strong> : randint</li>
  <li>
<strong>entrées</strong> : deux entiers $a$ et $b$</li>
  <li>
<strong>sortie</strong> : un entier aléatoire $c$ tel que $a \leq c \leq b$.</li>
</ul>

<p>On ne va pas définir plus que ça la notion d’aléatoire en informatique. On va ici prendre la définition mathématique : rend un nombre entre $a$ et $b$ de façon équiprobable, et considérer que c’est ok.</p>

<blockquote>
  <p>Il n’existe pas d’aléatoire au sens mathématique en informatique. On ne peut atteindre que des nombre <a href="https://fr.wikipedia.org/wiki/Pseudo-al%C3%A9atoire">pseudo-aléatoires</a>, mais c’est une autre histoire.</p>
</blockquote>

<h2 id="remarques-préliminaires">remarques préliminaires</h2>

<p>Attention, l’algorithme suivant :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>soit T un tableau à n cases
de i = 0 à n-1:
    T[i] = randint(0, n-1)
rendre T
</code></pre></div></div>

<p>Ne résout pas le problème “permutation” puisqu’il peut y avoir des répétitions.</p>

<h2 id="borne-min-du-problème">borne min du problème</h2>

<p>Comme il faut rendre un tableau de longueur $n$, une borne minimum du problème “permutation” est de $\mathcal{O}(n)$. Mais rien ne dit qu’un tel algorithme existe.</p>

<h2 id="existence-dun-algorithme">existence d’un algorithme</h2>

<p>Avant de chercher plus loin commençons par montrer qu’il existe un algorithme pour résoudre le problème. Si l’on possède une liste de toutes les permutations possible, l’algorithme suivant fonctionne :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>soit P un tableau contenant une fois chaque permutation de T
i = randint(0, n! - 1)
rendre P[i]
</code></pre></div></div>

<p>Il nous reste à créer toutes les permutations possibles d’un tableau. C’est ce que fait l’algorithme suivant, récursif et en python.</p>

<h2 id="algo-toutes-permutations">toutes les permutations</h2>

<style>
    table, td, tr, th, pre {
        padding:0;
        margin:0;
        border:none
    }
</style>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">permutations</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[[]]</span>

    <span class="n">les_permutations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)):</span>
        <span class="n">premier</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">elements_sans_premier</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">permutations_sans_premier</span> <span class="o">=</span> <span class="n">permutations</span><span class="p">(</span><span class="n">elements_sans_premier</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">une_fin_de_permutation</span> <span class="ow">in</span> <span class="n">permutations_sans_premier</span><span class="p">:</span>
            <span class="n">permutation</span> <span class="o">=</span> <span class="p">[</span><span class="n">premier</span><span class="p">]</span> <span class="o">+</span> <span class="n">une_fin_de_permutation</span>
            <span class="n">les_permutations</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">les_permutations</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Pour placer dans la liste de listes <code class="language-plaintext highlighter-rouge">P</code> toutes les permutations de <code class="language-plaintext highlighter-rouge">[0, 1, 2, 3, 4, 5]</code>, on lance l’algorithme comme ça : <code class="language-plaintext highlighter-rouge">P = permutations([0, 1, 2, 3, 4, 5])</code>.</p>

<blockquote class="a-faire">
  <p>Testez cet algorithme.</p>
</blockquote>

<p>Analysons cet algorithme pour vérifier qu’il fait bien ce qu’on pense qu’il fait (bien).</p>

<h3 id="finitude-permutations">finitude</h3>

<p>A chaque récursion, le tableau <code class="language-plaintext highlighter-rouge">elements</code> est strictement plus petit. En effet le tableau <code class="language-plaintext highlighter-rouge">elements_sans_premier</code> sur lequel porte la récursion est la restriction du tableau <code class="language-plaintext highlighter-rouge">elements</code> en supprimant l’élément d’indice <code class="language-plaintext highlighter-rouge">i</code> (<code class="language-plaintext highlighter-rouge">elements_sans_premier = elements[:i] + elements[i+1:]</code>).</p>

<p>Il arrivera donc une récursion où <code class="language-plaintext highlighter-rouge">elements</code> sera vide : le test de la ligne 2 stoppera la récursion.</p>

<h3 id="preuve-permutations">preuve</h3>

<p>on prouve par récurrence sur la taille du tableau <code class="language-plaintext highlighter-rouge">elements</code> que <code class="language-plaintext highlighter-rouge">permutations_rec(elements)</code> donne un tableau contenant toutes les permutations de <code class="language-plaintext highlighter-rouge">elements</code>.</p>

<ol>
  <li>pour <code class="language-plaintext highlighter-rouge">len(elements) == 0</code> c’est clair.</li>
  <li>on suppose la propriété vrai pour <code class="language-plaintext highlighter-rouge">len(elements) == p</code>. Pour <code class="language-plaintext highlighter-rouge">len(elements) == p + 1</code>, par hypothèse de récurrence, le retour de la récursion <code class="language-plaintext highlighter-rouge">permutations_rec(elements_sans_premier)</code> sera l’ensemble des permutations de <code class="language-plaintext highlighter-rouge">elements[:i] + elements[i+1:]</code> pour une position <code class="language-plaintext highlighter-rouge">i</code> de <code class="language-plaintext highlighter-rouge">elements</code>. Pour un <code class="language-plaintext highlighter-rouge">i</code>  donné on obtient alors  toutes les permutations de <code class="language-plaintext highlighter-rouge">elements</code> ayant <code class="language-plaintext highlighter-rouge">elements[i]</code> en première position (on ajoute <code class="language-plaintext highlighter-rouge">elements[i]</code> à toutes les permutations de <code class="language-plaintext highlighter-rouge">elements[:i] + elements[i+1:]</code>). Comme <code class="language-plaintext highlighter-rouge">i</code> prend tous les indice de <code class="language-plaintext highlighter-rouge">elements</code>, on on obtient aufinal toutes les permutations du tableau <code class="language-plaintext highlighter-rouge">elements</code>.</li>
</ol>

<h3 id="complexite-permutations">complexité</h3>

<p>La complexité de l’algorithme va dépendre de la taille $n$ du tableau <code class="language-plaintext highlighter-rouge">elements</code>. : on note sa complexité $C(n)$. Comme il est récursif, on va chercher une équation de récurrence que satisfait $C(n)$ à résoudre.</p>

<p>Complexité de chaque ligne :</p>

<ol>
  <li>$\mathcal{O}(1)$ définition de la fonction</li>
  <li>$\mathcal{O}(1)$ un test</li>
  <li>$\mathcal{O}(1)$ retour d’une constante
4.</li>
  <li>$\mathcal{O}(1)$ affectation d’une constante</li>
  <li>une boucle de $n$ itérations</li>
  <li>$\mathcal{O}(1)$ une affectation d’un élément d’un tableau</li>
  <li>$\mathcal{O}(n)$ car on crée un <strong>nouveau</strong> tableau de taille $n-1$</li>
  <li>$C(n-1)$, c’est notre récursion.</li>
  <li>une boucle de $\mathcal{O}((n-1)!)$ itérations (toutes les permutations d’un tableau à n-1 éléments)</li>
  <li>$\mathcal{O}(n)$ car on crée un <strong>nouveau</strong> tableau de taille $n$</li>
  <li>$\mathcal{O}(1)$, on ajoute un élément à la fin d’une liste (les tableau en pthon sont des listes, l’ajout d’un élément à la fin d’une liste est en temps constant)</li>
  <li>$\mathcal{O}(1)$ retour d’une fonction</li>
</ol>

<p>Ce qui donne :</p>

\[\begin{array}{lcl}
    C(n) = &amp; &amp; \mathcal{O}(1)\\
    &amp; + &amp; \mathcal{O}(1)\\
    &amp; + &amp; \mathcal{O}(1)\\
    &amp; + &amp; \mathcal{O}(1)\\
    &amp; + &amp; n \cdot (\\
    &amp;  &amp; \mathcal{O}(1)\\
    &amp; + &amp; \mathcal{O}(n)\\
    &amp; + &amp; C(n-1)\\
    &amp; + &amp; (n-1)! \cdot (\\
    &amp; &amp; \mathcal{O}(n)\\
    &amp; + &amp; \mathcal{O}(1)\\
    &amp; &amp; ))\\
    &amp; + &amp; \mathcal{O}(1)\\
\end{array}\]

<p>En simplifiant les $\mathcal{O}(1)$, on obtient l’équation de récurrence suivante :</p>

\[\begin{array}{lcl}
C(n) &amp; = &amp; \mathcal{O}(1) + n \cdot (\mathcal{O}(n) + C(n-1) + (n-1)! \cdot (\mathcal{O}(n)))\\
     &amp; = &amp; \mathcal{O}(1) + \mathcal{O}(n^2) + n \cdot C(n-1) + n! \cdot \mathcal{O}(n)\\
     &amp; = &amp; \mathcal{O}(n^2) + n \cdot C(n-1) + \mathcal{O}(n\cdot n!)\\
     &amp; = &amp; n \cdot C(n-1) + \mathcal{O}(n\cdot n!)\\
\end{array}\]

<p>On peut maintenant étendre la récurrence</p>

\[\begin{array}{lcl}
C(n) &amp; = &amp; n \cdot C(n-1) + \mathcal{O}(n\cdot n!)\\
     &amp; = &amp; n \cdot (n-1) \cdot C(n-2) + n \mathcal{O}(n-1)\cdot (n-1)!)) + \mathcal{O}(n\cdot n!)\\
     &amp; = &amp; n \cdot (n-1) \cdot C(n-2) + \mathcal{O}(n-1)\cdot (n)!)) + \mathcal{O}(n\cdot n!)\\
     &amp; = &amp; n \cdot (n-1) \cdot C(n-2) + \mathcal{O}((n + (n-1))n!)\\
     &amp; = &amp; ...\\
     &amp; = &amp; \Pi_{i=0}^p (n -i)\cdot C(n-i-1) + \mathcal{O}(\sum_{i=0}^p (n -i))n!)\\
     &amp; = &amp; n! \cdot C(0) + \mathcal{O}(\sum_{i=0}^{n-1} (n - i))n!)\\
\end{array}\]

<p>Comme $C(0) = \mathcal{O}(1)$ et que $\sum_{i=0}^{n-1}(n-i) = \mathcal{O}(n^2)$ On en déduit que :</p>

\[C(n) = \mathcal{O}(n^2n!) = \mathcal{O}((n+2)!)\]

<h3 id="utilisation">utilisation</h3>

<p>L’algorithme <code class="language-plaintext highlighter-rouge">permutations</code> rend un tableau contenant toutes les permutations du tableau passé en entrée. La taille de la sortie est donc très grande.</p>

<p>Par exemple pour <code class="language-plaintext highlighter-rouge">permutations([1, 2, 3, 4])</code> va rendre :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[1, 2, 3, 4], [1, 2, 4, 3], [1, 3, 2, 4], [1, 3, 4, 2], [1, 4, 2, 3], [1, 4, 3, 2], [2, 1, 3, 4], [2, 1, 4, 3], [2, 3, 1, 4], [2, 3, 4, 1], [2, 4, 1, 3], [2, 4, 3, 1], [3, 1, 2, 4], [3, 1, 4, 2], [3, 2, 1, 4], [3, 2, 4, 1], [3, 4, 1, 2], [3, 4, 2, 1], [4, 1, 2, 3], [4, 1, 3, 2], [4, 2, 1, 3], [4, 2, 3, 1], [4, 3, 1, 2], [4, 3, 2, 1]]
</code></pre></div></div>

<p>On remarque que :</p>

<ul>
  <li>le premier élément du tableau de sortie est le tableau initial</li>
  <li>le dernier élément du tableau de sortie est l’inverse du tableau initial</li>
  <li>que sont placés en premier les permutations ne changeant pas le 1er élément, puis celle où le 2nd élément est le premier, et ainsi de suite jusqu’à placer toutes les permutations où le dernier élément est le premier.</li>
</ul>

<h2 id="un-algorithme-inefficace">un algorithme inefficace</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>

<span class="k">def</span> <span class="nf">melange</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">permutations</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">P</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

</code></pre></div></div>

<p>Comme la fonction <a href="https://docs.python.org/fr/3/library/random.html#random.randint">randint</a> du module <a href="https://docs.python.org/fr/3/library/random.html">random</a> de python rend un nombre aléatoire, <code class="language-plaintext highlighter-rouge">melange</code> est bien une solution au problème puisque chaque permutation sera équiprobable.</p>

<p>Sa complexité est cependant prohibitive. Comme on a considéré que la complexité de <code class="language-plaintext highlighter-rouge">randint</code> est de $\mathcal{O}(1)$, la complexité de <code class="language-plaintext highlighter-rouge">melange</code> est de l’ordre de la complexité de <code class="language-plaintext highlighter-rouge">permutations</code> donc : $\mathcal{O}((n+2)!)$ avec $n$ la taille du tableau <code class="language-plaintext highlighter-rouge">element</code>. L’algorithme <code class="language-plaintext highlighter-rouge">melange</code> n’est pas utilisable en pratique car <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/complexite-max-min.html#n_factoriel">n! est trop gros</a></p>

<blockquote class="note">
  <p>L’intérêt de <code class="language-plaintext highlighter-rouge">mélange</code> est théorique. Il montre qu’il existe un algorithme pour résoudre le problème (et en donne par là également une borne max).</p>
</blockquote>

<h2 id="algorithme-de-fisher-yates-ou-de-knuth">algorithme de fisher-yates ou de Knuth</h2>

<p>L’algorithme que l’on va montrer maintenant, dit de <a href="https://fr.wikipedia.org/wiki/M%C3%A9lange_de_Fisher-Yates">fisher-yates ou encore de Knuth</a>, va également résoudre le problème “permutation”, mais de façon bien plus élégante.</p>

<blockquote>
  <p>Comme Fisher et Yates étaient des mathématiciens et Knuth un (grand) informaticien, les informaticiens préfèrent appeler cet algorithme <em>algorithme de Knuth</em> plutôt qu’<em>algorithme de Fisher-Yates</em>. Cependant comme Knuth a créé de très nombreux algorithmes, googler “algorithme de fisher-yates” donne directement le résultat attendu alors que googler “algorithme de knuth” donne plein de résultats différents (mais tous sont de superbes algorithmes !).</p>
</blockquote>

<style>
    table, td, tr, th, pre {
        padding:0;
        margin:0;
        border:none
    }
</style>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td>
<td class="code"><pre><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>

<span class="k">def</span> <span class="nf">melange_knuth</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
    <span class="n">copie_elements</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">copie_elements</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">copie_elements</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">copie_elements</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">copie_elements</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">copie_elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">copie_elements</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<blockquote class="a-faire">
  <p>Testez cet algorithme pour voir s’il rend bien des permutation du tableau en entrée.</p>
</blockquote>

<blockquote>
  <p>Notez que la boucle for pourrait aussi s’écrire <code class="language-plaintext highlighter-rouge">for i in range(len(copie_elements) - 1, 0, -1):</code> sans perte de généralité.</p>
</blockquote>

<h3 id="finitude-knuth">finitude</h3>

<p>Une unique boucle for sur la longueur du tableau : l’algorithme fini toujours.</p>

<h3 id="complexité-knuth">complexité</h3>

<p>Comme <code class="language-plaintext highlighter-rouge">randint</code> est considérée en $\mathcal{O}(1)$, la complexité totale de l’algorithme est (ligne à ligne) :</p>

<ol>
  <li>$\mathcal{O}(n)$ puisque l’on copie un tableau</li>
  <li>une boucle for de $\mathcal{O}(n)$ itérations</li>
  <li>utilisation de <code class="language-plaintext highlighter-rouge">randint</code> en $\mathcal{O}(1)$</li>
  <li>2 affectations et 2 recherches dans un tableau : $\mathcal{O}(1)$</li>
  <li>retour de fonction : $\mathcal{O}(1)$</li>
</ol>

<p>Ce qui donne une complexité de :</p>

\[\begin{array}{lcl}
C(n) &amp; = &amp; \mathcal{O}(n) + \mathcal{O}(n) \cdot (\mathcal{O}(1) + \mathcal{O}(1)) + \mathcal{O}(1)\\
&amp; = &amp; \mathcal{O}(n) + \mathcal{O}(n) + \mathcal{O}(1)\\
&amp; = &amp; \mathcal{O}(n) \\
\end{array}\]

<h3 id="verif-expe">vérification expérimentale</h3>

<p>Si, en exécutant l’algorithme on se rend bien compte qu’il <em>mélange</em> le tableau en entrée, ce n’est pas très clair à première vue que toutes les permutations sont équiprobables.</p>

<p>On va le vérifier expérimentalement en regardant les permutations du tableau <code class="language-plaintext highlighter-rouge">[1, 2, 3, 4, 5, 6]</code>. On va compter combien de fois apparait chaque permutation (il y en a $6! = 720$) pour un grand nombre de tirage. Pour cela :</p>

<ol>
  <li>on utilise l’algorithme <code class="language-plaintext highlighter-rouge">permutations</code> pour calculer toutes les permutations. On les stocke dans un tableau <code class="language-plaintext highlighter-rouge">PERMUTATIONS</code>. Elles sont rendues dans un tableau de longueur $6!$</li>
  <li>on initialise un tableau de longueur $6!$, que l’on nomme <code class="language-plaintext highlighter-rouge">compte</code>, avec des 0.</li>
  <li>on exécute un grand nombre de fois l’algorithme <code class="language-plaintext highlighter-rouge">melange_knuth</code> (100000 fois) et à chaque résultat on ajoute 1 à <code class="language-plaintext highlighter-rouge">compte[i]</code> où $i$ est l’indice de la permutation rendue par l’algorithme dans le tableau <code class="language-plaintext highlighter-rouge">PERMUTATIONS</code>.</li>
  <li>on affiche le résultat en le comparant au résultat théorique (s’il y a équiprobabilité, on devrait retrouver $100000 / 720 \simeq 139$ fois chaque permutation)</li>
</ol>

<blockquote class="a-faire">
  <p>Codez cette expérience.</p>
</blockquote>

<details><summary>une solution possible</summary><div>
<p>Il faut que <a href="https://matplotlib.org/">matplotlib</a> soit installé pour que le code fonctionne.</p>

<ul>
  <li>On a utilisé quelques trucs de matplotlib pour que la figue soit jolie :
    <ul>
      <li>
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.legend.html">des legendes</a>, que l’on a placé en dehors de la figure</li>
      <li><a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.axhline.html">un axe horizontal</a></li>
    </ul>
  </li>
  <li>on a mis un <a href="https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops">break</a> dans la recherche de la permutation, pour éviter de faire des recherches inutiles.</li>
</ul>

<p>On a également a mis les constantes en majuscule, <a href="https://www.python.org/dev/peps/pep-0008/#constants">conformément au style</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="k">def</span> <span class="nf">permutations</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[[]]</span>
    
    <span class="n">les_permutations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)):</span>
        <span class="n">premier</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">elements_sans_premier</span> <span class="o">=</span> <span class="n">elements</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">permutations_sans_premier</span> <span class="o">=</span> <span class="n">permutations</span><span class="p">(</span><span class="n">elements_sans_premier</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">une_fin_de_permutation</span> <span class="ow">in</span> <span class="n">permutations_sans_premier</span><span class="p">:</span>
            <span class="n">permutation</span> <span class="o">=</span> <span class="p">[</span><span class="n">premier</span><span class="p">]</span> <span class="o">+</span> <span class="n">une_fin_de_permutation</span>
            <span class="n">les_permutations</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">permutation</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">les_permutations</span>
    

<span class="k">def</span> <span class="nf">melange_knuth</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
    <span class="n">copie_elements</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">copie_elements</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">copie_elements</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">copie_elements</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">copie_elements</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">copie_elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">copie_elements</span>


<span class="n">NOMBRE_ITERATION</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="n">TABLEAU</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">PERMUTATIONS</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">permutations</span><span class="p">(</span><span class="n">TABLEAU</span><span class="p">)]</span>

<span class="n">compte</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">PERMUTATIONS</span><span class="p">)</span>

<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NOMBRE_ITERATION</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">melange_knuth</span><span class="p">(</span><span class="n">TABLEAU</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">PERMUTATIONS</span><span class="p">)):</span>
        <span class="k">if</span>  <span class="n">PERMUTATIONS</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">res</span><span class="p">:</span>
            <span class="n">compte</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">break</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="n">ax</span><span class="p">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">PERMUTATIONS</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">compte</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">"knuth"</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">NOMBRE_ITERATION</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">PERMUTATIONS</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s">"red"</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s">"théorique"</span><span class="p">)</span>

<span class="n">ax</span><span class="p">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s">'upper left'</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_title</span><span class="p">(</span><span class="s">"nombre de permutations"</span><span class="p">)</span>

<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>

</code></pre></div></div>

<blockquote>
  <p>Une version avancée du code précédent aurait utilisé un <a href="https://docs.python.org/fr/3/library/collections.html#counter-objects">compteur</a> du module <a href="https://docs.python.org/fr/3/library/collections.html">collections</a> pour accélérer le comptage, mais cela aurait nécessiter de changer nos listes en tuples.</p>
</blockquote>

</div></details>

<p>J’obtiens le résultat suivant :</p>

<p><img src="/cours_informatique/assets/cours/algorithmie/melange_knuth.png" alt="mélange de Knuth" style="margin: auto;display: block"></p>

<p>Le nombre de permutations trouvé oscille bien autour de la valeur théorique.</p>

<blockquote>
  <p>Pour vérifier que notre résultat est bien conforme à un tirage aléatoire, on devrait <a href="https://fr.wikipedia.org/wiki/Test_du_%CF%87%C2%B2#Test_du_%CF%872_d'ind%C3%A9pendance">fair un test du chi2 d’indépendance</a>, mais cela nous éloignerait de trop d’un cours d’algorithmie.</p>
</blockquote>

<h3 id="preuve-de-programme">preuve de programme</h3>

<p>On suppose que le tableau d’entrée possède $n$ éléments.</p>

<p>On va montrer que les probabilités de sortie de chaque permutation sont bien équiprobables de trois façons différentes. Toutes les démonstrations reposent sur le fait :</p>

<ul>
  <li>qu’une fois un élément choisi, il n’est plus jamais déplacé</li>
  <li>tous les éléments seront choisis une fois dans l’algorithme (il y a $n$ itérations et on choisi un élément à chaque itération)</li>
</ul>

<h4 id="preuve-par-probabilités">preuve par probabilités</h4>

<p>On va calculer la probabilité que l’élément originellement en position $i$ se retrouve en position $n-j$ à la fin de l’algorithme. Si notre tirage est équiprobable, cette probabilité doit être égal à $\frac{1}{n}$ quelquesoient $i$ et $j$.</p>

<p>Pour que cela arrive, il faut que :</p>

<ul>
  <li>l’élément n’ait pas été pris pendants la première itération : il y a $\frac{n-1}{n}$ chances que ça arrive (on ne choisit pas notre élément parmi $n$ possibles : $1-\frac{1}{n} = \frac{n-1}{n}$)</li>
  <li>l’élément n’ait pas été pris pendants la deuxième itération : il y a $\frac{n-2}{n-1}$ chances que ça arrive (on ne choisit pas notre élément parmi $n - 1$ possibles : $1-\frac{1}{n-1} = \frac{n-2}{n-1}$)</li>
  <li>…</li>
  <li>l’élément n’ait pas été pris pendants la $j-1$ ème itération : il y a $\frac{n-j+1}{n-j+2}$ chances que ça arrive (on ne choisit pas notre élément parmi $n-(j-1) +1$ possibles : $1-\frac{1}{n-j+2} = \frac{n-j+1}{n-j+2}$)</li>
  <li>l’élément ait été pris pendants la $j$ ème itération : il y a $\frac{1}{n-j+1}$ chances que ça arrive</li>
</ul>

<p>De là, la probabilité que l’élément originellement en position $i$ se retrouve en position $n-j$ à la fin de l’algorithme est :</p>

\[\frac{n-1}{n} \cdot \frac{n-2}{n-1} \cdot \ ...\  \cdot \frac{n-j+1}{n-j+2} \cdot \frac{1}{n-j+1} = \frac{1}{n}\]

<p>C’est bien équiprobable !</p>

<h4 id="preuve-par-dénombrement">preuve par dénombrement</h4>

<p>A la $i$ème itération on choisit un élément parmi $n-i+1$, et comme $i$ croit de $1$ à $n-1$, on a $n!$ parcours différents de l’algorithme.</p>

<p>L’algorithme choisit donc bien 1 permutation parmi $n!$, toutes différentes : il y a bien équiprobabilité des choix.</p>

<h4 id="preuve-par-récurrence">preuve par récurrence</h4>

<ol>
  <li>lors de la première itération, on choisit un entier $k$ entre $0$ et $n-1$ et on échange l’élément d’indice $k$ avec celui d’indice $n-1$. Cet élément ne sera <strong>plus jamais changé</strong> dans la suite de l’algorithme. On en conclut que chaque élément du tableau d’entrée à la même chance d’être en dernière place de la permutation de sortie.</li>
  <li>une fois la première itération terminée, tout se passe comme si on exécutait l’algorithme avec un tableau de taille $n-1$ contenant tous les éléments du tableau de départ sauf celui placé lors de la 1ère itération.</li>
  <li>donc si l’algorithme fonctionne pour des tableau de longueur $n-1$, il fonctionne aussi pour des tableau de longueur $n$.</li>
  <li>on peut terminer la preuve en remarquant que si le tableau a une longueur de 1, on a bien en sorite l’unique permutation du tableau en entrée.</li>
</ol>

<blockquote>
  <p>Cette preuve permet aussi de montrer que l’algorithme ne peux pas boucler et retrouver deux fois la même permutation avec 2 exécutions différentes.</p>
</blockquote>

<h2 id="méthodes-de-python">méthodes de python</h2>

<p>Python utilise la méthode <a href="https://docs.python.org/fr/3/library/random.html#random.shuffle">shuffle</a> du module random pour mélanger une liste.</p>

<p><strong>Attention</strong>, La méthode shuffle ne rend pas une nouvelle liste, elle mélange la liste en entrée. Si l’on veut créer une nouvelle liste il faut utiliser la méthode <a href="https://docs.python.org/fr/3/library/random.html#random.sample">sample</a> avec les paramètres suivants : <code class="language-plaintext highlighter-rouge">sample(x, k=len(x))</code></p>

<blockquote>
  <p>La méthode utilisée par shuffle est l’algorithme de Knuth / Fisher-Yates.</p>
</blockquote>

<blockquote class="a-faire">
  <p>Regardez les 4 différentes méthodes pour mélanger en python de cet article : <a href="https://www.geeksforgeeks.org/python-ways-to-shuffle-a-list/">https://www.geeksforgeeks.org/python-ways-to-shuffle-a-list/</a>. La 4ème méthode n’est pas optimale en complexité. Pourquoi ?</p>
</blockquote>

<details><summary>solution</summary><div>
<p>La ligne <code class="language-plaintext highlighter-rouge">element=arr.pop(j)</code> supprime l’élément $j$ de la liste <code class="language-plaintext highlighter-rouge">arr</code>. Sa complexité est $\mathcal{O}(n)$ avec $n$ la taille de la liste <code class="language-plaintext highlighter-rouge">arr</code> car ce n’est pas formément le dernier élément qui est supprimé. La complexité totale de leur mélangeage est alors $\mathcal{O}(n^2)$ et pas $\mathcal{O}(n)$.</p>

</div></details>

<h2 id="attention">attention</h2>

<h3 id="à-trop-mélanger-on-ne-mélange-pas-bien">à trop mélanger on ne mélange pas bien</h3>

<p>Si vous implémentez un algorithme de mélange mais qu’il peut obtenir plusieurs fois la même permutation avec des opérations différentes, alors vous risquez fort de ne pas être équiprobable. Illustrons ceci par un exemple.</p>

<p>On sait que toute permutation d’un tableau peut être atteinte en échangeant itérativement une paire d’éléments (on appelle ça une <a href="https://fr.wikipedia.org/wiki/Permutation#D%C3%A9composition_en_produit_de_transpositions">décomposition en produit de transpositions</a>). On peut même montrer qu’il suffit d’en faire au plus la taille du tableau moins 1.</p>

<p>On en déduit l’algorithme de mélange suivant :</p>

<style>
    table, td, tr, th, pre {
        padding:0;
        margin:0;
        border:none
    }
</style>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">melange_transposition</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
    <span class="n">copie_elements</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">copie_elements</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">copie_elements</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">copie_elements</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="n">copie_elements</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">copie_elements</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">copie_elements</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">copie_elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">copie_elements</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<blockquote class="a-faire">
  <p>Refaites l’expérience de la <a href="#verif-expe">vérification expérimentale</a> pour cet algorithme.</p>
</blockquote>

<p>J’obtiens quelque chose du type :</p>

<p><img src="/cours_informatique/assets/cours/algorithmie/melange_transposition.png" alt="mélange de transpositions" style="margin: auto;display: block"></p>

<p>On remarque que les premières permutations sont surreprésentées par rapport à ce qu’on devrait avoir. On remarque aussi qui’l y a des piques réguliers que l’on observe pas avec le mélange de Knuth. Ceci est du au fait que l’on peut produire une même permutation de plusieurs manière avec cet algorithme : on produit plus facilement certaines permutations que d’autres, ce qui rend l’algorithme non équiprobable.</p>

<blockquote class="a-faire">
  <p>lisez et comprenez l’article : <a href="https://datagenetics.com/blog/november42014/index.html">https://datagenetics.com/blog/november42014/index.html</a>. Il explique pourquoi cette méthode n’est pas efficace.</p>
</blockquote>

<p>Nous allons ici juste montrer que les permutations ne sorties ne sont pas équiprobables. La probabilité que l’élément d’indice $l$ ne soit jamais choisi pendant l’algorithme est :</p>

\[P_n = (\frac{n-1}{n} \cdot \frac{n-1}{n})^n\]

<p>Puisque l’algorithme a choisi pour chacune des $n$ étapes de la boucle for un élément différent de $l$ pour les lignes 4 et 5.</p>

<p>Or :</p>

\[P_n = ((1 - \frac{1}{n})^n)^2 \xrightarrow[n\to\infty]{} (\frac{1}{e})^2 &gt; 0\]

<blockquote>
  <p>$(1 - \frac{1}{n})^n = e^{n \ln (1-\frac{1}{n})} \sim e^{n \cdot (-\frac{1}{n})}$ lorsque $n$ tend vers l’infini puisque $\ln(1+u) \sim u$ lorsque $u$ tend vers $0$.</p>
</blockquote>

<p>Ceci est incompatible avec l’équiprobabilité puisque :</p>

<ul>
  <li>$P_n$ est plus petit que la probabilité que l’élément d’indice $l$ soit en position $l$ à la fin de l’algorithme (c’est même strictement plus petit puisqu’il peut n’avoir jamais bougé ou être revenu à sa place)</li>
  <li>s’il y a équiprobabilité, la probabilité que l’élément d’indice $l$ soit en position $l$ à la fin de l’algorithme doit être de $\frac{1}{n}$</li>
  <li>il existe $N_0$ tel que pour tout $n \geq N_0$, on a  $\frac{1}{n} &lt; (\frac{1}{e})^2$</li>
</ul>

<blockquote class="note">
  <p>Les remarques ci-dessus montrent que pour $n$ assez grand, la probabilité que l’élément $l$ soit en position $l$ à la fin de l’algorithme est strictement plus grande que l’équiprobabilité.</p>
</blockquote>

<p>C’est bien ce qu’on remarque sur la figure avec la surreprésentation de la première permutation qui est la permutation où rien n’a bougé.</p>

<h3 id="randint-doit-être-puissant">randint doit être puissant</h3>

<p>En informatique, il est impossible de tirer un nombre au hasard. On est obliger d’utiliser des suite périodique qui se comportent comme des nombre aléatoires. On appelle ces suites <a href="https://fr.wikipedia.org/wiki/G%C3%A9n%C3%A9rateur_de_nombres_pseudo-al%C3%A9atoires">pseudo-aléatoires</a>.</p>

<p>La période de cette suite doit être très grande pour pouvoir générer toutes les permutations : la période doit être plus grande que $n!$. Sinon, certaines permutations seront sur-représentées.</p>

<p>Par exemple, pour pouvoir mélanger un paquet de 52 cartes de façon équiprobable en utilisant une suite pseudo-aléatoire, il faut que sa période soit plus que grande que $52! = 80658175170943878571660636856403766975289505440883277824000000000000 \sim 2^{226}$</p>

<blockquote>
  <p>Une suite pseudo-aléatoire simple a souvent une période de $2^{64}$, ce uiq n’est vraiment pas assez grand pour pouvoir mélanger équiprobablement un jeu de carte.</p>
</blockquote>

<blockquote class="a-faire">
  <p>Regardez la partie <em>A Shortage Of Random Numbers!</em> du lien suivant <a href="https://www.i-programmer.info/programming/theory/2744-how-not-to-shuffle-the-kunth-fisher-yates-algorithm.html">https://www.i-programmer.info/programming/theory/2744-how-not-to-shuffle-the-kunth-fisher-yates-algorithm.html</a> qui explique celà.</p>
</blockquote>

<h3 id="attention-aux-humains">attention aux humains</h3>

<p>La perception de ce qu’est l’aléatoire n’est pas aisée. Lorsque l’on joue à un jeu de carte par exemple, le <a href="https://fr.wikipedia.org/wiki/Biais_de_confirmation">biasi de confirmation</a> tend à se réppeler les évènement très défavorables au détriment de ceux juste <em>normaux</em>. De plus, lorsque l’on demande à des humains de tirer des nombres aléatoires, souvent ils ne le sont pas :</p>

<ul>
  <li>Lorsque l’ondemande à des humains de choisir un nombre aléatoirement entre 1 et 10, ils répondent le plus souvent 7 : <a href="https://www.reddit.com/r/dataisbeautiful/comments/acow6y/asking_over_8500_students_to_pick_a_random_number/">https://www.reddit.com/r/dataisbeautiful/comments/acow6y/asking_over_8500_students_to_pick_a_random_number/</a>.</li>
  <li>lorsque l’on demande à des humains d’écrire une suite aléatoire de 200 nombres valant 0 ou 1, il y aura une sous-représentation des longues séquences avec le même nombre : celà ne <em>fait pas aléatoire</em> d’voir plein de fois le même nombre à la suite (alors que statistiquement, il faut bien que ces séquences equistent).</li>
</ul>

<blockquote class="a-faire">
  <p>lisez l’article de <a href="https://draftsim.com/mtg-arena-shuffler/">https://draftsim.com/mtg-arena-shuffler/</a> qui montre cela avec le mélangeur de <a href="https://magic.wizards.com/fr/mtgarena">MTGA</a>.</p>
</blockquote>

<h2 id="autres-références">autres références</h2>

<p>Quelques autres articles sur le sujet :</p>

<ul>
  <li><a href="https://possiblywrong.wordpress.com/2014/12/01/card-shuffling-algorithms-good-and-bad/">https://possiblywrong.wordpress.com/2014/12/01/card-shuffling-algorithms-good-and-bad/</a></li>
  <li><a href="https://blog.codinghorror.com/the-danger-of-naivete/">https://blog.codinghorror.com/the-danger-of-naivete/</a></li>
  <li><a href="https://www.stashofcode.fr/tri-aleatoire-des-elements-dun-tableau/">https://www.stashofcode.fr/tri-aleatoire-des-elements-dun-tableau/</a></li>
</ul>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique à l'école centrale marseille.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
