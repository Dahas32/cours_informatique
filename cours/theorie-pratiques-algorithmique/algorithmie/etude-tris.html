<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>étude / algorithmes de tris | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="étude / algorithmes de tris">
<meta name="author" content="François Brucker">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<meta property="og:description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<link rel="canonical" href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/etude-tris.html">
<meta property="og:url" content="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/etude-tris.html">
<meta property="og:site_name" content="cours d’informatique">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="étude / algorithmes de tris">
<script type="application/ld+json">
{"description":"Support de cours/td d’informatique à l’école centrale marseille.","@type":"WebPage","url":"/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/etude-tris.html","headline":"étude / algorithmes de tris","author":{"@type":"Person","name":"François Brucker"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">étude / algorithmes de tris</h1>Auteur : <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">François Brucker</span></span>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/">Théorie et pratiques algorithmique</a> / <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/">algorithmie</a> / <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/etude-tris.html">étude : trier un tableau</a></p>

  <p>prérequis :</p>

  <ul>
    <li><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/complexite-moyenne.html">complexité moyenne</a></li>
    <li><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/complexite-probleme.html">complexité d’un problème</a></li>
    <li><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/etude-melange.html">étude : mélanger un tableau</a></li>
  </ul>

</blockquote>

<p>Les informaticiens adorent les <a href="https://fr.wikipedia.org/wiki/">algorithmes de tris</a>. Pas parce qu’ils aiment l’ordre — loin de là — mais parce qu’il existe des millions de façons différentes de trier. Commençons par définir le problème :</p>

<blockquote class="note">

  <ul>
    <li>nom : tri</li>
    <li>données : un tableau d’entiers</li>
    <li>réponse : un tableau contenant les valeurs du tableau en entrée triées selon l’ordre croissant</li>
  </ul>

</blockquote>

<h2 id="problème-de-reconnaissance">problème de reconnaissance</h2>

<p>Commençons par travailler sur un problème connexe au problème du tri, celui de la reconnaissance :</p>

<blockquote class="note">

  <ul>
    <li>nom : est trié ?</li>
    <li>données : un tableau $T$ d’entiers</li>
    <li>question : $T$ est-il trié de façon croissante ?</li>
    <li>réponse : OUI ou NON.</li>
  </ul>

</blockquote>

<h3 id="algo-est-trie">algorithme</h3>

<style>
    table, td, tr, th, pre {
        padding:0;
        margin:0;
        border:none
    }
</style>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">est_trie</span><span class="p">(</span><span class="n">tableau</span><span class="p">):</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tableau</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">tableau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tableau</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<h4 id="fonctionnement">fonctionnement</h4>

<p>L’algorithme rend bien :</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">True</code> pour <code class="language-plaintext highlighter-rouge">est_trie([42])</code>
</li>
  <li>
<code class="language-plaintext highlighter-rouge">False</code> pour <code class="language-plaintext highlighter-rouge">est_trie([4, 2])</code>
</li>
  <li>
<code class="language-plaintext highlighter-rouge">True</code> pour <code class="language-plaintext highlighter-rouge">est_trie([2, 4])</code>
</li>
</ul>

<h4 id="preuve">preuve</h4>

<p>La finitude de l’algorithme est claire puisqu’il n’y a qu’une boucle for avec autant d’itérations que la taille du tableau passé en entrée.</p>

<p>Le preuve en démontrant l’invariant de boucle : à la fin d’un itération, les $i + 1$ premiers éléments du tableau sont triés.</p>

<ol>
  <li>à la fin de la première itération, si l’on est pas sorti de la boucle c’est que $\mbox{tableau}[i] \geq \mbox{tableau}[i-1]$ pour $i=1$ : les 2 premiers éléments du tableau sont bien triés.</li>
  <li>Si l’invariant est vrai à la fin de l’itération $i-1$, à la fin de l’itération $i$ on à $\mbox{tableau}[i] \geq \mbox{tableau}[i-1]$ et comme les $i + 1$ premiers éléments du tableau sont triés : les $i + 1$ premiers éléments du tableau sont triés.</li>
</ol>

<p>Au final :</p>

<ul>
  <li>L’invariant prouve que : si on arrive à la ligne 6 de l’algorithme c’est que les $n$ premiers éléments du tableau sont triés.</li>
  <li>si on utilise le retour de la ligne 5 c’est qu’il existe $i$ avec $\mbox{tableau}[i] &lt; \mbox{tableau}[i-1]$, donc $\mbox{tableau}$ ne peut être trié.</li>
</ul>

<blockquote class="note">
  <p>L’algorithme <code class="language-plaintext highlighter-rouge">est_trie</code> est une solution au problème <em>“est trié ?”</em></p>
</blockquote>

<h4 id="complexité-de-lalgorithme">complexité de l’algorithme</h4>

<p>Ligne à ligne :</p>

<ol>
  <li>définition de la fonction $\mathcal{O}(1)$</li>
  <li>
  </li>
<li>une boucle for de $k$ itérations</li>
  <li>un tests de deux valeurs dans un tableau : $\mathcal{O}(1)$</li>
  <li>un retour de fonction $\mathcal{O}(1)$</li>
  <li>un retour de fonction $\mathcal{O}(1)$</li>
</ol>

<p>Que l’on sorte par le retour de la ligne 5 ou 6, le complexité est : $\mathcal{O}(k)$. Dans le cas le pire, on parcourt tout le tableau, donc :</p>

<blockquote class="note">
  <p>La complexité de l’algorithme <code class="language-plaintext highlighter-rouge">est_trie</code> est $\mathcal{O}(n)$ avec $n$ la taille du tableau en entrée.</p>
</blockquote>

<h3 id="complexité-du-problème">complexité du problème</h3>

<p>Comme toute case du tableau peut rendre le tableau non trié, on utilise l’argument de <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/complexite-probleme.html#complexite-recherche">complexité du problème de la <em>“recherche”</em></a>, un algorithme résolvant ce problème doit considérer toutes les cases du tableau et donc une borne min du problème <em>“est trié ?”</em> est $\mathcal{O}(n)$ où $n$ est la taille du talbeau en entrée. Comme la complexité de <code class="language-plaintext highlighter-rouge">est_trie</code>  est égalemnt de $\mathcal{O}(n)$.On en conclut :</p>

<blockquote class="note">
  <p>La complexité du problème <em>“est trié ?”</em> est de $\mathcal{O}(n)$ où $n$ est la taille du tableau en entrée</p>
</blockquote>

<h2 id="bornes-du-problème">bornes du problème</h2>

<h3 id="borne-maximum">borne maximum</h3>

<p>La l’algorithme <code class="language-plaintext highlighter-rouge">permutations</code> de l’<a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/etude-melange.html#algo-toutes-permutations">étude sur les mélanges d’un tableau</a> permet de calculer en $\mathcal{O}((n+2)!)$ toutes les permutations d’un tableau à $n$ éléments. Comme l’algorithme <code class="language-plaintext highlighter-rouge">est_trie</code> permet de savoir si un tableau est trié en $\mathcal{O}(n)$ opérations, on peut résoudre le problème <em>“trie”</em> en énumérant toutes les permutations du tableau passé en paramètre et en vérifiant pour chacune d’entre elle s’il est trié ou non.</p>

<p>La complexité de cet algorithme est alors le produit de la complexité de <code class="language-plaintext highlighter-rouge">permutations</code> et de <code class="language-plaintext highlighter-rouge">est_trie</code> : $\mathcal{O}(n \cdot (n+2)!)$. On en conclut :</p>

<blockquote class="note">
  <p>Une borne maximum du problème <em>“tri”</em> est $\mathcal{O}(n \cdot (n+2)!)$ où $n$ est la taille du tableau passé en entrée</p>
</blockquote>

<p>Comme <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/complexite-max-min.html#n_factoriel">n! est trop gros</a>, ce n’est vraiment pas un algorithme à utiliser si on peut faire mieux… Mais il nous permet d’énoncer la propriété :</p>

<blockquote class="note">
  <p>Pour tout problème algorithmique, s’il existe :</p>

  <ul>
    <li>un algorithme énumérant tous les cas possibles</li>
    <li>un algorithme permettant de vérifier si un cas donné est une solution</li>
  </ul>

  <p>Alors la combinaison des deux algorithmes, de complexité le produit des deux algorithmes la constituant, est une solution au problème initial.</p>
</blockquote>

<p>Souvent les algorithmes produits par la remarque précédente ne sont pas optimaux car on explore bien trop de cas.</p>

<h3 id="borne-minimum">borne minimum</h3>

<p>Si les éléments du tableau à trier sont tous différents, les permutations de celui-ci sont toutes différentes et une seule est la solution au problème “tri”.</p>

<p>Par exemple, pour un tableau à trois éléments :</p>

<ol>
  <li>$[1, 2, 3]$</li>
  <li>$[1, 3, 2]$</li>
  <li>$[2, 1, 3]$</li>
  <li>$[2, 3, 1]$</li>
  <li>$[3, 1, 2]$</li>
  <li>$[3, 2, 1]$</li>
</ol>

<p>Quelque soit la forme de l’entrée (de 1 à 6), l’algorithme de tri doit rendre la forme 1 : un algorithme de tri doit pouvoir distinguer parmi toutes les permutations du tableau. Comme il y a $n!$  permutations différentes pour un tableau de taille $n$ dont les éléments sont deux à deux différents, tout algorithme de tri doit pouvoir distinguer parmi $n!$ choix, en utilisant la propriété de nombre de cas à distinguer vue <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/complexite-probleme.html#complexite-recherche-ordonnee">dans la complexité du problème de la <em>“recherche ordonnée”</em></a>, on en déduit que :</p>

<p>Tout algorithme de tri d’un tableau à $n$ élément doit distinguer parmi $n!$ cas, il est donc au minimum de complexité $\mathcal{O}(\ln(n!))$. On rend cette borne min un peu plus jolie en utilisant le fait que ;</p>

<blockquote class="note">
  <p>Toute fonction en $\mathcal{O}(\ln(n!))$ est également une fonction en $\mathcal{O}(n\ln(n))$ et réciproquement.</p>
</blockquote>
<details><summary>démonstration</summary><div>
<p>On a :</p>

\[(\frac{n}{2})^{\frac{n}{2}} \leq n \cdot (n-1) \cdot \ ...\ \cdot \frac{n}{2} \leq n! = n \cdot (n-1) \ ... \ \cdot 1 \leq n \cdot \ ...\  \cdot n = n ^n\]

<p>Donc, en passant au $\ln$ :</p>

\[\ln((\frac{n}{2})^{\frac{n}{2}}) \leq \ln(n!) \leq \ln(n^n)\]

<p>Et donc, pour $n \geq 4$, on a l’encadrement suivant :</p>

\[\frac{n}{2}\ln(\frac{n}{2}) \leq \ln(n!) \leq n\ln(n)\]

<p>Poursuivons en triturant $\ln(\frac{n}{2})$ :</p>

\[\begin{array}{lclr}
\ln(\frac{n}{2}) &amp;= &amp;\frac{1}{2}\ln(\frac{n}{2}) + \frac{1}{2}\ln(\frac{n}{2})&amp;\\
\ln(\frac{n}{2}) &amp;\geq&amp; \frac{1}{2}\ln(\frac{4}{2}) + \frac{1}{2}\ln(\frac{n}{2}) &amp; (\mbox{pour } n \geq 4)\\
\ln(\frac{n}{2}) &amp;\geq&amp; \frac{1}{2}(\ln(2) + \ln(\frac{n}{2})) &amp; (\mbox{pour } n \geq 4)\\
\ln(\frac{n}{2}) &amp;\geq&amp; \frac{1}{2}(\ln(2\cdot \frac{n}{2})) &amp; (\mbox{pour } n \geq 4)\\
\ln(\frac{n}{2}) &amp;\geq&amp; \frac{1}{2}(\ln(n)) &amp; (\mbox{pour } n \geq 4)\\
\end{array}\]

<p>On combine cette inégalité à notre encadrement précédent pour trouver :</p>

\[\frac{n}{2}(\frac{1}{2}(\ln(n))) \leq \ln(n!) \leq n\ln(n)\]

<p>Ce qui se dérive directement, pour $n \geq 4$, en :</p>

\[\frac{1}{4} \leq \frac{\ln(n!)}{n\ln(n)} \leq 1\]

<p>Enfin, on peut montrer les équivalences de $\mathcal{O}$ :</p>

<ul>
  <li>si $g(n)$ est en $\mathcal{O}(\ln(n!))$ il existe $N_0$ et $C$ tel que : $g(n) &lt; C \cdot \ln(n!)$ pour n &gt; $N_0$. Pour $N_1 = \max(N_0, 4)$ on a donc $g(n) &lt; C \cdot \ln(n!) &lt; C \cdot n\ln(n)$ : $g(n)$ est en $\mathcal{O}(n\ln(n))$.</li>
  <li>si $g(n)$ est en $\mathcal{O}(n\ln(n))$ il existe $N_0$ et $C$ tel que : $g(n) &lt; C \cdot n\ln(n)$ pour n &gt; $N_0$. Pour $N_1 = \max(N_0, 4)$ on a donc $g(n) &lt; C \cdot \ln_2(n!) &lt; C \cdot 4 \cdot \ln(n!)$ : $g(n)$ est en $\mathcal{O}(\ln(n!))$.</li>
</ul>

</div></details>

<blockquote class="note">
  <p>Tout algorithme de tri d’une liste à $n$ éléments a au moins une complexité de $\mathcal{O}(n\ln(n))$ opérations.</p>
</blockquote>

<p>Une borne min du problème du <em>“tri”</em> est donc $\mathcal{O}(n\ln(n))$ où $n$ est la taille du tableau en entrée, mais on ne sait pas si un tel algorithme existe.</p>

<details><summary>spoil</summary><div>
<p>oui, de tels algorithmes exitent.</p>
</div></details>

<h2 id="tris-simples">tris <em>simples</em>
</h2>

<p>Notre algorithme pour trier un tableau est un monstre de complexité. Il en existe de très simples et de complexité bien plus faible. Nous en montrons 2, classiques.</p>

<h3 id="tri-selection">tri par sélection</h3>

<p>Le principe du tri par sélection est l’inverse de l’algorithme de <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/etude-melange.html#algorithme-fisher-yates">Fisher-Yates</a>, plutôt que de placer un élément au hasard à l’indice $i$ du tableau, on choisi de placer le $i$-ème plus petit élément à l’indice $i$.</p>

<p>L’algorithme procède alors ainsi : à chaque itération de l’algorithme, on place à l’indice $i$ du tableau son $i$-ème plus petit élément.</p>

<blockquote class="a-faire">
  <p>Ecrivez un algorithme qui met en œuvre ce principe</p>
</blockquote>
<details><summary>une solution</summary><div>
<style>
    table, td, tr, th, pre {
        padding:0;
        margin:0;
        border:none
    }
</style>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">selection</span><span class="p">(</span><span class="n">tableau</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tableau</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">min_index</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tableau</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">tableau</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tableau</span><span class="p">[</span><span class="n">min_index</span><span class="p">]:</span>
                <span class="n">min_index</span> <span class="o">=</span> <span class="n">j</span>
        <span class="n">tableau</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">tableau</span><span class="p">[</span><span class="n">min_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">tableau</span><span class="p">[</span><span class="n">min_index</span><span class="p">],</span> <span class="n">tableau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>L’algorithme <code class="language-plaintext highlighter-rouge">selection</code> <strong>modifie</strong> le tableau passé en paramètre. On appelle ces algorithmes <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in place</a> car ils ne rendent rien, mais modifient les données en entrées.</p>

</div></details>

<h4 id="fonctionnement-selection">fonctionnement</h4>

<p>On vérifie que l’algorithme fonctionne pour :</p>

<ul>
  <li>un petit tableau trié : <code class="language-plaintext highlighter-rouge">[1, 2, 3]</code>
</li>
  <li>un petit tableau non trié où le plus petit est en dernière place : <code class="language-plaintext highlighter-rouge">[3, 2, 1]</code>
</li>
</ul>

<h4 id="preuve-selection">preuve</h4>

<p>Le principe de fonctionnement est clair. Il reste à prouver que c’est bien ce que l’algorithme <code class="language-plaintext highlighter-rouge">selection</code> fait.</p>

<ol>
  <li>la boucle <code class="language-plaintext highlighter-rouge">for</code> de la ligne 4 trouve l’indice du plus petit élément du tableau <code class="language-plaintext highlighter-rouge">tableau[i:]</code>.</li>
  <li>la ligne 7 échange le minium du tableau <code class="language-plaintext highlighter-rouge">tableau[i:]</code> avec <code class="language-plaintext highlighter-rouge">tableau[i]</code>
</li>
  <li>comme la boucle <code class="language-plaintext highlighter-rouge">for</code> de la ligne 2 incrémente $i$, on a l’invariant de boucle : <em>“à la fin de chaque étape $i$ de l’algorithme les $i$ plus petites valeurs du tableau sont triées aux $i$ premiers indices du tableau”</em>
</li>
</ol>

<h4 id="complexites-selection">complexités</h4>

<p>On suppose que la taille du tableau est $n$.</p>

<p>Ligne à ligne :</p>

<ol>
  <li>début de fonction : $\mathcal{O}(1)$</li>
  <li>une boucle de $n-1$ itérations</li>
  <li>une affectation $\mathcal{O}(1)$</li>
  <li>une boucle de $n-i-1$ itérations ($i$ est la variable définie ligne 2)</li>
  <li>un test et deux valeurs d’un tableau : $\mathcal{O}(1)$</li>
  <li>une affectation : $\mathcal{O}(1)$</li>
  <li>deux affectation et quatre valeurs d’un tableau : $\mathcal{O}(1)$</li>
</ol>

<p>Le nombre d’itérations de la boucle for de la ligne 4 n’est pas constant, mais il décroit puisque $i$ augmente à chaque itération de la boucle <code class="language-plaintext highlighter-rouge">for</code>de la ligne 2. On peut alors utiliser la <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/complexite-max-min.html#regle-croissance">règle de croissance</a> pour utiliser le maximum, $n-1$, pour le calcul de la complexité.</p>

<p>Ce qui donne une complexité de :</p>

\[\begin{array}{lcl}
C &amp; = &amp; \mathcal{O}(1) + \\
&amp;&amp; (n-1) \cdot (\\
&amp;&amp; \mathcal{O}(1) + \\
&amp;&amp; (n-1) \cdot ( \\
&amp;&amp; \mathcal{O}(1) + \\
&amp;&amp; \mathcal{O}(1)) + \\
&amp;&amp; \mathcal{O}(1)) \\
&amp; = &amp; \mathcal{O}(1) + (n-1) \cdot (\mathcal{O}(1) + (n-1) \cdot (\mathcal{O}(1))\\
&amp; = &amp; \mathcal{O}(n^2) \\
\end{array}\]

<p>Le nombre d’itérations est constant quelque soit le tableau, on a donc :</p>

<blockquote class="note">
  <p>La complexité de l’algorithme <code class="language-plaintext highlighter-rouge">selection</code> est ($n$ est la taille du tableau passé en entrée) :</p>

  <ul>
    <li>la <strong>complexité min</strong> vaut $\mathcal{O}(n^2)$</li>
    <li>la <strong>complexité (max)</strong> vaut $\mathcal{O}(n^2)$</li>
  </ul>

</blockquote>

<p>Puisque la complexité min et max sont égales, on en déduit que la <strong>complexité en moyenne</strong> vaut également s$\mathcal{O}(n^2)$.</p>

<h3 id="tri-insertion">tri par insertion</h3>

<p>Le tri par insertion est une extension de l’<a href="#algorithme-algo-est-trie">algorithme <code class="language-plaintext highlighter-rouge">est_trie</code></a>. Plutôt que de rendre <code class="language-plaintext highlighter-rouge">False</code> il répare. L’algorithme <code class="language-plaintext highlighter-rouge">est_trie</code> répond <code class="language-plaintext highlighter-rouge">False</code> au plus petit <code class="language-plaintext highlighter-rouge">i</code> tel que <code class="language-plaintext highlighter-rouge">tableau[i] &lt; tableau[i-1]</code>. On est alors dans le cas où :</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">tableau[:i]</code> est trié</li>
  <li><code class="language-plaintext highlighter-rouge">tableau[i] &lt; tableau[i-1]</code></li>
</ul>

<p>Pour que l’on puisse continuer, il faut s’arranger pour que <code class="language-plaintext highlighter-rouge">tableau[:i+1]</code> soit trié. Pour cela, on peut utiliser le fait que <code class="language-plaintext highlighter-rouge">tableau[:i+1]</code> est trié si et seulement si :</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">tableau[1] &gt;= tableau[0]</code></li>
  <li><code class="language-plaintext highlighter-rouge">tableau[2] &gt;= tableau[1]</code></li>
  <li>…</li>
  <li><code class="language-plaintext highlighter-rouge">tableau[i] &gt;= tableau[i-1]</code></li>
</ul>

<p>Dans notre cas, toutes les conditions sont vérifiées sauf la dernière. Si l’on échange <code class="language-plaintext highlighter-rouge">tableau[i]</code> et <code class="language-plaintext highlighter-rouge">tableau[i-1]</code> toutes les conditions seront vérifiées sauf peut-être l’avant-dernière. Si elle n’est pas vérifiée on peut échanger <code class="language-plaintext highlighter-rouge">tableau[i-1]</code> et <code class="language-plaintext highlighter-rouge">tableau[i-1]</code> et alors toutes les conditions seront vérifiées sauf peut-être l’avant-avant-dernière, que l’on peut à nouveau échanger, et ainsi de suite jusqu’à ce que toutes les conditions soient vérifiées.</p>

<p>Cette analyse (ce n’est pas encore une preuve formelle) nous permet de dégager le principe suivant :</p>

<p>On vérifie itérativement que <code class="language-plaintext highlighter-rouge">tableau[i] &gt;= tableau[i-1]</code> et si ce n’est pas le cas on fait <em>remonter</em> <code class="language-plaintext highlighter-rouge">tableau[i]</code> par échanges successifs à la première place où il sera plus grand que le précédent.</p>

<blockquote class="a-faire">
  <p>Ecrivez un algorithme qui met en œuvre ce principe</p>
</blockquote>
<details><summary>une solution</summary><div>
<style>
    table, td, tr, th, pre {
        padding:0;
        margin:0;
        border:none
    }
</style>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">insertion</span><span class="p">(</span><span class="n">tableau</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tableau</span><span class="p">)):</span>
        <span class="n">courant</span> <span class="o">=</span> <span class="n">tableau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">courant</span> <span class="o">&lt;</span> <span class="n">tableau</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]):</span>
            <span class="n">tableau</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tableau</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">tableau</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">courant</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>L’algorithme <code class="language-plaintext highlighter-rouge">insertion</code>, comme l’algorithme <code class="language-plaintext highlighter-rouge">selection</code>, <strong>modifie</strong> le tableau passé en paramètre.</p>

<p>Pour garantir que <code class="language-plaintext highlighter-rouge">tableau[j - 1]</code> soit toujours valide (il faut que $j-1 \geq 0$), on place en tête de la condition <code class="language-plaintext highlighter-rouge">(courant &lt; tableau[j - 1])</code> de la ligne 5 la <a href="https://en.wikipedia.org/wiki/Sentinel_value">sentinelle</a> <code class="language-plaintext highlighter-rouge">(j &gt; 0)</code>. Les deux conditions étant liées par un <code class="language-plaintext highlighter-rouge">and</code>, python (et tout autre langage de programmation) n’évaluera la seconde condition <strong>que si la première est vérifiée</strong> (un <code class="language-plaintext highlighter-rouge">and</code> ne peut être vrai que si les deux conditions sont vraies. Si la première condition est fausse, il est impossible que le <code class="language-plaintext highlighter-rouge">and</code> soit vrai il est donc inutile de vérifier la seconde condition). Cette technique est très utile, ça vaut le coup de la connaître.</p>

</div></details>

<h4 id="fonctionnement-insertion">fonctionnement</h4>

<p>Tout comme pour l’algorithme de tri par sélection, on vérifie que l’algorithme fonctionne pour :</p>

<ul>
  <li>un petit tableau trié : <code class="language-plaintext highlighter-rouge">[1, 2, 3]</code>
</li>
  <li>un petit tableau non trié où le plus petit est en dernière place : <code class="language-plaintext highlighter-rouge">[3, 2, 1]</code>
</li>
</ul>

<h4 id="preuve-insertion">preuve</h4>

<p>Le principe de programmation du tri par insertion est correct puisque <code class="language-plaintext highlighter-rouge">est_tre</code> est prouvé. Mais il faut vérifier qu’il est bien mis en œuvre dans l’algorithme. On utilise ici celui donné en solution.</p>

<p>Tout d’abord, comme la condition de la boucle <code class="language-plaintext highlighter-rouge">while</code> de la ligne 5 contient <code class="language-plaintext highlighter-rouge">(j &gt; 0)</code> et que <code class="language-plaintext highlighter-rouge">j</code> décroit strictement à chaque itération (ligne 7), notre algorithme va bien s’arrêter.</p>

<p>A chaque itération $i$ de la boucle <code class="language-plaintext highlighter-rouge">for</code> (ligne 2), l’algorithme fonctionne ainsi :</p>

<ul>
  <li>ligne 3 : on a : <code class="language-plaintext highlighter-rouge">tableau[:i+1] = tableau[:i] + [courant]</code>
</li>
  <li>à la sortie de la boucle <code class="language-plaintext highlighter-rouge">while</code>, juste avant la ligne 8. En notant <code class="language-plaintext highlighter-rouge">tableau</code> le tableau avant la boucle <code class="language-plaintext highlighter-rouge">while</code> et <code class="language-plaintext highlighter-rouge">tableau'</code> le tableau en fin de <code class="language-plaintext highlighter-rouge">while</code>, on a :
    <ul>
      <li><code class="language-plaintext highlighter-rouge">tableau'[:i+1] = tableau[:j] + [tableau[j]] + tableau[j:i]</code></li>
      <li>
<code class="language-plaintext highlighter-rouge">tableau[:j]</code> trié et <code class="language-plaintext highlighter-rouge">courant &gt;= tableau[j-1]</code>
</li>
      <li>
<code class="language-plaintext highlighter-rouge">tableau[j:i]</code> trié <code class="language-plaintext highlighter-rouge">courant &lt; tableau[j]</code>
</li>
    </ul>
  </li>
  <li>après la ligne 8, juste avant de faire une nouvelle itération de la boucle <code class="language-plaintext highlighter-rouge">for</code>. En notant <code class="language-plaintext highlighter-rouge">tableau</code> le tableau avant le début de l’itération et <code class="language-plaintext highlighter-rouge">tableau</code> le tableau en fin d’itération’, on a : <code class="language-plaintext highlighter-rouge">tableau'[:i+1] = tableau[:j] + [tableau[i]] + tableau[j:i]</code>
</li>
</ul>

<p>Notre invariant de boucle est donc : <em>“à la fin de l’itération i, les i premiers éléments du tableau sont triés”</em></p>

<h4 id="complexites-insertion">complexités</h4>

<p>Ligne à ligne :</p>

<ol>
  <li>appel de fonction : $\mathcal{O}(1)$</li>
  <li>$n-1$ itérations, avec $n$ la taille du tableau</li>
  <li>affectation d’une variable et récupération d’un élément d’un tableau : $\mathcal{O}(1)$</li>
  <li>affectation d’une variable : $\mathcal{O}(1)$</li>
  <li>$k$ itérations et deux tests en $\mathcal{O}(1)$ pour chaque itération</li>
  <li>affectation d’une variable et récupération d’un élément d’un tableau : $\mathcal{O}(1)$</li>
  <li>une soustraction et une affectation : $\mathcal{O}(1)$</li>
  <li>affectation d’une variable et récupération d’un élément d’un tableau : $\mathcal{O}(1)$</li>
</ol>

<p>Comme $k$ n’est pas constant pour chaque itération de la boucle <code class="language-plaintext highlighter-rouge">for</code> il faut regarder les valeurs extrêmes que peut prendre $k$ :</p>

<ul>
  <li>si le tableau est déjà trié : on ne rentre jamais dans la boucle <code class="language-plaintext highlighter-rouge">while</code> : $k = 0$ pour chaque itération.</li>
  <li>si le tableau est trié à l’envers : pour la $i$-ème itération de la boucle <code class="language-plaintext highlighter-rouge">for</code>, on aura $k=i$. C’est de plus le maximum théorique possible ($j=i$ initialement et j décroit de 1 à chaque itération de la boucle <code class="language-plaintext highlighter-rouge">while</code>).</li>
</ul>

<p>On a donc 2 cas extrêmes pour le calcul :</p>

<ol>
  <li>$k = 0$ à chaque itération</li>
  <li>$k$ croit de $1$ à $n-1$ à chaque itération : la <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/complexite-max-min.html#regle-croissance">règle de croissance</a> nous indique qu’on peut considérer que $k=n-1$ pour le calcul de la complexité</li>
</ol>

<p>Ce qui donne une complexité de :</p>

\[\begin{array}{lcl}
C &amp; = &amp; \mathcal{O}(1) + \\
&amp;&amp; (n-1) \cdot (\\
&amp;&amp; \mathcal{O}(1) + \\
&amp;&amp; \mathcal{O}(1) + \\
&amp;&amp; k \cdot (\mathcal{O}(1) + \\
&amp;&amp; \mathcal{O}(1) + \\
&amp;&amp; \mathcal{O}(1)) + \\
&amp;&amp; \mathcal{O}(1)) \\
&amp; = &amp; \mathcal{O}(1) + (n-1) \cdot (\mathcal{O}(1) + k \cdot (\mathcal{O}(1))\\
&amp; = &amp; \mathcal{O}(n \cdot (k + 1)) \\
\end{array}\]

<blockquote class="note">
  <p>La complexité de l’algorithme <code class="language-plaintext highlighter-rouge">insertion</code> est ($n$ est la taille du tableau passé en entrée) :</p>

  <ul>
    <li>la <strong>complexité min</strong> est atteinte pour $k=0$, c’est à dire lorsque le tableau est déjà trié, et vaut $\mathcal{O}(n)$</li>
    <li>la <strong>complexité (max)</strong> est atteinte pour $k=n-1$, c’est à dire lorsque le tableau est trié par ordre décroissant, et vaut $\mathcal{O}(n^2)$</li>
  </ul>

</blockquote>

<p>La complexité min est différente de la complexité maximale. On va donc calculer la complexité en moyenne pour connaitre la complexité pour des données <em>standard</em>.
Pour savoir ce que veut dire <em>standard</em>, il faut déterminer le modèle de données : prenons le équiprobable.</p>

<p>Cela signifie que pour chaque itération $i$ :</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">tableau[i]</code> sera bien placé pour une proportion de $\frac{1}{i + 1}$ tableaux</li>
  <li>
<code class="language-plaintext highlighter-rouge">tableau[i]</code> devra être positionné en $i-1$ pour une proportion de $\frac{1}{i + 1}$ tableaux,</li>
  <li>…</li>
  <li>
<code class="language-plaintext highlighter-rouge">tableau[i]</code> devra être positionné en $i-j$ pour une proportion de $\frac{1}{i + 1}$ tableaux,</li>
  <li>…</li>
  <li>
<code class="language-plaintext highlighter-rouge">tableau[i]</code> devra être positionné en $0$ pour une proportion de $\frac{1}{i + 1}$ tableaux.</li>
</ul>

<p>La complexité en moyenne sera donc égale à :</p>

\[\begin{array}{lcl}
C_m &amp;=&amp; \mbox{complexité hors boucle for} + \sum_{i=1}^{n-1}(\mbox{complexité hors boucle while} + i \cdot (\mbox{complexité boucle while}))\\
&amp;=&amp; \mathcal{O}(1) + \sum_{i=1}^{n-1} (\mathcal{O}(1) + i \cdot \mathcal{O}(1))\\
&amp;=&amp; \mathcal{O}(1) \cdot \sum_{i=1}^{n-1} i \\
&amp;=&amp; \mathcal{O}(1) \cdot \frac{n(n-1)}{2} \\
&amp;=&amp; \mathcal{O}(n^2)\\
\end{array}\]

<blockquote class="note">
  <p>La <strong>complexité en moyenne</strong> de l’algorithme <code class="language-plaintext highlighter-rouge">insertion</code> est $\mathcal{O}(n^2)$ où $n$ est la taille du tableau passé en entrée.</p>
</blockquote>

<p>Le cas le meilleur arrive très rarement par rapport au cas le pire (parmi les $n!$ ordres possibles, il y en a très peu qui sont presque triés).</p>

<p>Si l’on change le modèle de données et que l’on considère des tableaux <em>presque triées</em>, la complexité en moyenne va être de l’ordre de la complexité minimale, à savoir : $\mathcal{O}(n)$</p>

<blockquote class="note">
  <p>On utilise le tri par insertion lorsque nos données seront presque toujours déjà triées ou très peu en désordre.</p>
</blockquote>

<p>Ce calcul de complexité nous permet d’utiliser la règle suivante, qui va se révéler très utile :</p>

<blockquote class="note">
  <p>Soit $A$ un ensemble de $n$ nombres aléatoires, et $x$ un nombre également aléatoire.
Pour tout $ y \in A$, il y a 50% de chances que $x \leq y$. Il y a donc en moyenne $\frac{n}{2}$ éléments de $A$ qui sont plus grand que $x$.</p>
</blockquote>

<h2 id="tri-fusion">tri fusion</h2>

<p>Le <a href="https://fr.wikipedia.org/wiki/Tri_fusion">tri fusion</a> est un tri de complexité $\mathcal{O}(n\ln(n))$ opérations où $n$ est la taille de la liste en entrée. Il fonctionne ainsi :</p>

<p>Si l’on possède une fonction <code class="language-plaintext highlighter-rouge">colle(T1, T2)</code>, avec <code class="language-plaintext highlighter-rouge">T1</code> et <code class="language-plaintext highlighter-rouge">T2</code> des tableaux triés, qui rend le tri de la concaténation de <code class="language-plaintext highlighter-rouge">T1</code> et <code class="language-plaintext highlighter-rouge">T2</code>, alors la fonction récursive suivante (avec $\mid T \mid$ la longueur du tableau $T$) est un algorithme de tri !</p>

\[\mbox{fusion}(T) = \left\{
    \begin{array}{lr}
        \mbox{colle}(\mbox{fusion}(T[\mid T\mid //\ 2:]), \mbox{fusion}(T[:\mid T\mid //\ 2]) &amp; \mbox{si } \mid T \mid \geq 2\\
        T &amp; \mbox{sinon.}
    \end{array}
\right.\]

<p>L’algorithme fonctionne en effet ainsi :</p>

<ol>
  <li>on coupe la liste à trier en 2</li>
  <li>on trie chacune des sous-listes à part (en s’utilisant soit-même pour trier)</li>
  <li>on recolle les deux listes triées en une unique liste triée</li>
</ol>

<blockquote class="note">
  <p>L’algorithme de tri <code class="language-plaintext highlighter-rouge">fusion</code> utilise la méthode de création d’algorithme nommée <a href="https://fr.wikipedia.org/wiki/Diviser_pour_r%C3%A9gner_(informatique)">diviser pour régner</a> qui est une méthode se révélant souvent efficace lorsqu’il est facile de reconstruire une solution globale à un problème à partir de solutions partielles.</p>
</blockquote>

<h3 id="algorithme-colle">algorithme colle</h3>

<blockquote class="a-faire">
  <p>Pour comprendre pourquoi c’est une bonne idée, écrivez un algorithme qui implémente la fonction <code class="language-plaintext highlighter-rouge">colle(T1, T2)</code>. Il faut que sa complexité soit égale à $\mathcal{O}(n_1 + n_2)$ avec $n_1$ et $n_2$ les tailles des tableaux <code class="language-plaintext highlighter-rouge">T1</code> et <code class="language-plaintext highlighter-rouge">T2</code> respectivement.</p>

</blockquote>
<details><summary>une solution</summary><div>
<style>
    table, td, tr, th, pre {
        padding:0;
        margin:0;
        border:none
    }
</style>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">colle</span><span class="p">(</span><span class="n">tab1</span><span class="p">,</span> <span class="n">tab2</span><span class="p">):</span>
    <span class="n">i1</span> <span class="o">=</span> <span class="n">i2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">tab_colle</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">i1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tab1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">i2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">tab2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i2</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tab2</span><span class="p">):</span>
            <span class="n">tab_colle</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">tab1</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span>
            <span class="n">i1</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">i1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tab1</span><span class="p">):</span>
            <span class="n">tab_colle</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">tab2</span><span class="p">[</span><span class="n">i2</span><span class="p">])</span>
            <span class="n">i2</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">tab1</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">tab2</span><span class="p">[</span><span class="n">i2</span><span class="p">]:</span>
            <span class="n">tab_colle</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">tab1</span><span class="p">[</span><span class="n">i1</span><span class="p">])</span>
            <span class="n">i1</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tab_colle</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">tab2</span><span class="p">[</span><span class="n">i2</span><span class="p">])</span>
            <span class="n">i2</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">tab_colle</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

</div></details>

<h4 id="fonctionnement-colle">fonctionnement</h4>

<p>On vérifie pour deux petits tableaux <strong>triés</strong>, par exemple : <code class="language-plaintext highlighter-rouge">[1, 4, 7]</code> et <code class="language-plaintext highlighter-rouge">[0, 2, 3, 98]</code>.</p>

<h4 id="preuve-colle">preuve</h4>

<p>L’algorithme se finit bien puisqu’à chaque itération de la boucle while soit <code class="language-plaintext highlighter-rouge">i1</code> soit <code class="language-plaintext highlighter-rouge">i2</code> augmente. Au bout de <code class="language-plaintext highlighter-rouge">len(T1) + len(T2)</code> itération on aura <code class="language-plaintext highlighter-rouge">i1</code> = <code class="language-plaintext highlighter-rouge">len(T1)</code> et <code class="language-plaintext highlighter-rouge">i2</code> = <code class="language-plaintext highlighter-rouge">len(T1)</code>, donc la condition <code class="language-plaintext highlighter-rouge">i1 &lt; len(tab1) or i2 &lt; len(tab2)</code> ne sera plus vérifiée.</p>

<p>L’invariant de boucle que l’on peut facilement prouver est : <em>“<code class="language-plaintext highlighter-rouge">tab_colle</code> est trié et contient les <code class="language-plaintext highlighter-rouge">i1</code> premiers éléments <code class="language-plaintext highlighter-rouge">T1</code> et les <code class="language-plaintext highlighter-rouge">i2</code> premiers éléments <code class="language-plaintext highlighter-rouge">T2</code>“</em>.</p>

<h4 id="complexites-colle">complexités</h4>

<p>Allons un peu plus vite :</p>

<ul>
  <li>on a une boucle <code class="language-plaintext highlighter-rouge">while</code> de <code class="language-plaintext highlighter-rouge">len(T1) + len(T2)</code> itérations</li>
  <li>chaque ligne de l’algorithme est en $\mathcal{O}(1)$</li>
</ul>

<blockquote class="note">
  <p>La complexité max et min de <code class="language-plaintext highlighter-rouge">colle</code> est $\mathcal{O}(n_1 + n_2)$ avec $n_1$ et $n_2$ les tailles des tableaux <code class="language-plaintext highlighter-rouge">T1</code> et <code class="language-plaintext highlighter-rouge">T2</code> respectivement.</p>
</blockquote>

<h3 id="algorithme-fusion">algorithme fusion</h3>

<p>Une proposition d’algorithme de la fonction récurente est ci-après :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">fusion</span><span class="p">(</span><span class="n">tableau</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tableau</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tableau</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">milieu</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tableau</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">return</span> <span class="n">colle</span><span class="p">(</span><span class="n">fusion</span><span class="p">(</span><span class="n">tableau</span><span class="p">[:</span><span class="n">milieu</span><span class="p">]),</span> <span class="n">fusion</span><span class="p">(</span><span class="n">tableau</span><span class="p">[</span><span class="n">milieu</span><span class="p">:]))</span>

</code></pre></div></div>

<h4 id="fonctionnement-fusion">fonctionnement</h4>

<p>On vérifie pour deux petits tableaux, par exemple :</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">[4]</code></li>
  <li><code class="language-plaintext highlighter-rouge">[1, 2, 0, 4, 3, 98, 7]</code></li>
</ul>

<h4 id="preuve-fusion">preuve</h4>

<p>Comme  <code class="language-plaintext highlighter-rouge">milieu &lt; len(tableau)</code> si <code class="language-plaintext highlighter-rouge">len(tableau) &gt; 1</code>, l’algorihtme va bien converger. De plus, comme l’algorithme <code class="language-plaintext highlighter-rouge">colle</code> est démontré, <code class="language-plaintext highlighter-rouge">fusion</code> est bien un algorithme de tri.</p>

<h4 id="complexites-fusion">complexités</h4>

<p>La complexité de l’algorithme <code class="language-plaintext highlighter-rouge">fusion</code> est (avec $n$ la taille du tableau passé en entrée) :</p>

\[C(n) = 2 \cdot C(\frac{n}{2}) + D(n)\]

<p>Où :</p>

<ul>
  <li>$C(n)$ est la complexité de l’algorithme fusion pour une liste à $n$ éléments (algorithme <code class="language-plaintext highlighter-rouge">fusion</code>)</li>
  <li>$D(n)$ est la complexité de fusionner deux listes triées en une unique liste triées (algorithme <code class="language-plaintext highlighter-rouge">colle</code>).</li>
</ul>

<p>Comme l’algorithme <code class="language-plaintext highlighter-rouge">colle</code> est en $\mathcal{O}(n)$, l’équation de récurrence de la complexité est :</p>

\[C(n) = 2 \cdot C(\frac{n}{2}) + \mathcal{O}(n)\]

<p>Pour connaître la valeur de la complexité on utilise le <a href="https://fr.wikipedia.org/wiki/Master_theorem">master theorem</a> qui est <strong>LE</strong> théorème des complexités pour les algorithmes récursifs. Sa preuve dépasse (de loin) le cadre de ce cours, mais <a href="https://fr.wikipedia.org/wiki/Master_theorem#%C3%89nonc%C3%A9_avec_la_notation_de_Landau">son énoncé sous la notation de Landau</a>, nous permet de déterminer aisément la complexité de nombreux algorithmes récursifs dont le notre :</p>

<blockquote class="note">
  <p><strong>Master Theorem</strong></p>

\[T(n) = a \cdot T(\frac{n}{b}) + \mathcal{O}(n^d)\]

  <ul>
    <li>si $d &lt; \log_b(a)$ alors $T(n)  = \mathcal{O}(n^{\log_b(a)})$</li>
    <li>si $d = \log_b(a)$ alors $T(n)  = \mathcal{O}(n^d \cdot \ln(n))$</li>
    <li>si $d &gt; \log_b(a)$ alors $T(n)  = \mathcal{O}(n^d)$</li>
  </ul>

</blockquote>

<p>Dans notre cas on a $a = 2$, $b = 2$  et $d = 1$ donc $d = \log_2(a)$ :</p>

<blockquote class="note">
  <p>La complexité de l’algorithme <code class="language-plaintext highlighter-rouge">fusion</code> est $\mathcal{O}(n\ln(n))$ où $n$ est la taille de la liste en entrée</p>
</blockquote>

<p>Tout comme le tri par sélection, le tri fusion a la particularité d’avoir toujours le même nombre d’opérations quelque soit la liste en entrée.</p>

<details><summary>calcul de la complexité sans utiliser le master theorem</summary><div>
\[\begin{array}{lcl}
C(n) &amp;=&amp; 2 \cdot C(\frac{n}{2}) + \mathcal{O}(n)\\
&amp;=&amp; 2 \cdot (2 \cdot (C(\frac{n}{4}) + \mathcal{O}(\frac{n}{2})) + \mathcal{O}(n)\\
&amp;=&amp; 2^2 \cdot C(\frac{n}{2^2}) + 2 \cdot \mathcal{O}(\frac{n}{2})) + \mathcal{O}(n)\\
&amp;=&amp; 2^2 \cdot C(\frac{n}{2^2}) + 2 \cdot \mathcal{O}(n)\\
&amp;=&amp; ...\\
&amp;=&amp; 2^k \cdot C(\frac{n}{2^k}) + k \cdot \mathcal{O}(n)\\
&amp;=&amp; ...\\
&amp;=&amp; 2^{\log_2(n)} \cdot C(1) + \log_2(n) \cdot \mathcal{O}(n)\\
&amp;=&amp; n \cdot C(1) + \log_2(n) \cdot \mathcal{O}(n)\\
&amp;=&amp; \mathcal{O}(n) + \log_2(n) \cdot \mathcal{O}(n)\\
&amp;=&amp; \mathcal{O}(n\log_2(n))\\
&amp;=&amp; \mathcal{O}(n\ln(n))
\end{array}\]

</div></details>

<h2 id="tri-de-python">tri de python</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">T</span><span class="p">.</span><span class="n">sort</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>

</code></pre></div></div>

<p>Le tri de python est <strong>in place</strong>. L’algorithme utilisé est <a href="https://en.wikipedia.org/wiki/Timsort">timsort</a>, mix entre le tri fusion et le tri par insertion. C’est un tri très efficace puisque :</p>

<blockquote class="note">
  <p>Pour un tableau de taille $n$ :</p>

  <ul>
    <li>La complexité de l’algorithme timsort est $\mathcal{O}(n\ln(n))$</li>
    <li>La complexité min de l’algorithme timsort est $\mathcal{O}(n)$</li>
    <li>La complexité en moyenne de l’algorithme timsort est $\mathcal{O}(n\ln(n))$</li>
  </ul>

</blockquote>

<h2 id="tri-rapide">tri rapide</h2>

<p>Le tri rapide est un algorithme qui a été très utilisé par le passé. On le montre encore maintenant car c’est un exemple de <em>diviser pour régner</em> et, surtout, le calcul complexités est très intéressant.</p>

<p>Son principe est le suivant, si on souhaite trier le tableau $T$ :</p>

<ol>
  <li>on choisit un élément du tableau, souvent $T[0]$</li>
  <li>on sépare $T[1:]$ en deux sous tableaux
    <ul>
      <li>$T_1$ qui contient tous les éléments plus petit ou égal à $T[0]$</li>
      <li>$T_2$ qui contient tous les éléments plus grand strictement à $T[0]$</li>
    </ul>
  </li>
  <li>on trie $T_1$ en $T’_1$ et $T_2$ en $T’_2$</li>
  <li>on constitue le tableau initial trié : $T’_1 + [T[0]] + T’_2$</li>
</ol>

<blockquote class="a-faire">
  <p>Ecrivez cet algorithme en python</p>
</blockquote>
<details><summary>une solution</summary><div>
<style>
    table, td, tr, th, pre {
        padding:0;
        margin:0;
        border:none
    }
</style>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">rapide</span><span class="p">(</span><span class="n">tableau</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tableau</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">tableau</span>

    <span class="n">pivot</span> <span class="o">=</span> <span class="n">tableau</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">tab_gauche</span> <span class="o">=</span> <span class="p">[</span><span class="n">tableau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tableau</span><span class="p">))</span> <span class="k">if</span> <span class="n">tableau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="n">tab_droite</span> <span class="o">=</span> <span class="p">[</span><span class="n">tableau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tableau</span><span class="p">))</span> <span class="k">if</span> <span class="n">tableau</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">rapide</span><span class="p">(</span><span class="n">tab_gauche</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">+</span> <span class="n">rapide</span><span class="p">(</span><span class="n">tab_droite</span><span class="p">)</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>On a utilisé les <a href="https://python.doctor/page-comprehension-list-listes-python-cours-debutants">list comprehension</a> de python. C’est un moyen clair et efficace de générer des listes. Utilisez-les, ça rend le code plus clair et facile à écrire.</p>

</div></details>

<h3 id="fonctionnement-rapide">fonctionnement</h3>

<p>Tout comme pour le tri fusion, on peut tester pour deux petits tableaux, par exemple :</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">[4]</code></li>
  <li><code class="language-plaintext highlighter-rouge">[1, 2, 0, 4, 3, 98, 7]</code></li>
</ul>

<h3 id="preuve-rapide">preuve</h3>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">tab_gauche</code> contient tous les élements du tableau d’indice <code class="language-plaintext highlighter-rouge">&gt; 0</code> et plus petit ou égal à <code class="language-plaintext highlighter-rouge">pivot</code> qui est égal à <code class="language-plaintext highlighter-rouge">tab[0]</code>
</li>
  <li>
<code class="language-plaintext highlighter-rouge">tab_droite</code> contient tous les élements du tableau d’indice <code class="language-plaintext highlighter-rouge">&gt; 0</code> et plus plus grand strictement à <code class="language-plaintext highlighter-rouge">pivot</code>
</li>
</ul>

<p>Si rapide fonctionne pour des tableaux de longueurs strictement plus petit que $n$, il fonctionne également pour des tableaux de longueur $n$ : le tableau rendu est le tableau des valeurs plus petite que <code class="language-plaintext highlighter-rouge">pivot</code> triées (ce tableau est de longueur <code class="language-plaintext highlighter-rouge">&lt; n</code>, donc c’est trié par hypothèse de récurence) + <code class="language-plaintext highlighter-rouge">[pivot]</code> + le tableau des valeurs plus grande que <code class="language-plaintext highlighter-rouge">pivot</code> triées (ce tableau est de longueur <code class="language-plaintext highlighter-rouge">&lt; n</code>, donc c’est trié par hypothèse de récurence)</p>

<p>Or il fonctionne pour des tableau de longueur 0 ou 1, donc par récurrence, c’est ok.</p>

<h3 id="complexites-rapide">complexités</h3>

<p>En notant $n$ la taille de la liste on a comme équation de récurrence pour la complexité $C(n)$ :</p>

\[{
C(n) = \underbrace{\mathcal{O}(n)}_{\mbox{création des tableaux}}{} + \underbrace{C(n_1) + C(n_2)}_{\mbox{récursions}}{}
}\]

<p>Où $n_1$ est la taille du tableau de gauche et $n_2$ celle de droite ($n_1 + n_2 = n$)</p>

<p>On va monter que :</p>

<blockquote class="note">
  <p>Pour trier un tableau de longueur $n$, les complexités de <code class="language-plaintext highlighter-rouge">rapide</code> sont :</p>

  <ul>
    <li>la complexité (maximale) est $\mathcal{O}(n^2)$,</li>
    <li>la complexité en moyenne est $\mathcal{O}(n\ln (n))$,</li>
    <li>la complexité minimale est $\mathcal{O}(n\ln (n))$,</li>
  </ul>

</blockquote>

<blockquote>
  <p>Nous n’allons pas faire ici de calculs rigoureux, on utilisera des arguments de bon-sens pour aller plus vite. Ces arguments sont justes, mais si un calcul sans approximation vous intéresse, reportez vous à <a href="http://perso.eleves.ens-rennes.fr/~mruffini/Files/Other/rapide.pdf">http://perso.eleves.ens-rennes.fr/~mruffini/Files/Other/rapide.pdf</a></p>
</blockquote>

<h4 id="complexité-maximale-du-tri-rapide">complexité (maximale) du tri rapide</h4>

<p>Ce cas va arriver si un des deux tableaux est toujours vide. Par exemple lorsque le tableau est déjà trié. Dans ce cas là, l’autre tableau est de taille $n-1$, ce qui donne une complexité de :</p>

\[C(n) = \mathcal{O}(n) + C(n-1)\]

<p>Donc :</p>

\[\begin{array}{lcl}
C_m &amp;=&amp; \mathcal{O}(n) + C(n-1)\\
&amp;=&amp; \mathcal{O}(n) + \mathcal{O}(n-1) + C(n-2)\\
&amp;=&amp; ...
&amp;=&amp; \sum_{i=2}^{n}\mathcal{O}(i) + C(1)\\
&amp;=&amp; \sum_{i=2}^{n}\mathcal{O}(n) + C(1)\\
&amp;=&amp; \mathcal{O}(n^2)\\
\end{array}\]

<blockquote>
  <p>on a utilisé la <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/complexite-max-min.html#regle-croissance">règle de croissance</a> pour remplacer $\mathcal{O}(i)$ qui est croissant par sa valeur maximale de $\mathcal{O}(n)$</p>
</blockquote>

<h4 id="complexité-minimale-du-tri-rapide">complexité minimale du tri rapide</h4>

<p>Si l’on découpe notre tableau de façon non équilibrée, une branche de la récursion va faire plus d’opérations que $C(n/2)$. La complexité minimale est ainsi atteinte lorsque l’on coupe notre tableau exactement en 2.</p>

<p>Dans ce cas là, on a l’équation de récurrence : $C(n) = \mathcal{O}(n) + 2 \cdot C(\frac{n}{2})$ qui est la même que celle du tri fusion. La complexité minimale du tri <code class="language-plaintext highlighter-rouge">rapide</code> est donc $\mathcal{O}(n\ln(n))$.</p>

<h4 id="complexité-en-moyenne-du-tri-rapide">complexité en moyenne du tri rapide</h4>

<p>On utilise l’argument utiliser pour calculer la complexité en moyenne du <a href="#complexites-insertion">tri par insertion</a>. Si les données sont aléatoires la moitié de <code class="language-plaintext highlighter-rouge">tableau[1:]</code> est plus grande que <code class="language-plaintext highlighter-rouge">tableau[0]</code>. De là, en moyenne, on va toujours couper le talbeau en 2 parties (plus ou moins) égales.</p>

<p>Si l’on coupe toujours au milieu on a alors la même équation que pour la complexité minimale : $C(n) = \mathcal{O}(n) + 2 \cdot C(\frac{n}{2})$, ce qui donne une complexité de $\mathcal{O}(n\ln(n))$.</p>

<h3 id="conclusion">conclusion</h3>

<p>Le tri rapide a :</p>

<ul>
  <li>une complexité moyenne qui vaut sa complexité minimale et qui est $\mathcal{O}(n \ln(n))$, donc la meilleur possible</li>
  <li>il très rapide pour les tableaux en désordre et très lent pour les tableaux déjà triés.</li>
</ul>

<p>C’est donc <em>rigolo</em> :</p>

<blockquote class="note">
  <p>Commencer par mélanger un tableau pour le trier avec <code class="language-plaintext highlighter-rouge">rapide</code> ensuite est plus rapide en moyenne que de le trier directement.</p>
</blockquote>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique à l'école centrale marseille.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
