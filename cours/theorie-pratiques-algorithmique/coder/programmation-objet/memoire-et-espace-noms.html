<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>espaces de noms | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="espaces de noms">
<meta name="author" content="François Brucker">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<meta property="og:description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<link rel="canonical" href="/cours_informatique/cours/theorie-pratiques-algorithmique/coder/programmation-objet/memoire-et-espace-noms.html">
<meta property="og:url" content="/cours_informatique/cours/theorie-pratiques-algorithmique/coder/programmation-objet/memoire-et-espace-noms.html">
<meta property="og:site_name" content="cours d’informatique">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="espaces de noms">
<script type="application/ld+json">
{"description":"Support de cours/td d’informatique à l’école centrale marseille.","author":{"@type":"Person","name":"François Brucker"},"@type":"WebPage","url":"/cours_informatique/cours/theorie-pratiques-algorithmique/coder/programmation-objet/memoire-et-espace-noms.html","headline":"espaces de noms","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">espaces de noms</h1>Auteurs :
      <ul>
      
        <li><span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">François Brucker</span></span></li>
      
      </ul>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/">Théorie et pratiques algorithmique</a> / <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/coder/">coder</a> / <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/coder/programmation-objet/">programmation objet</a> / <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/coder/programmation-objet/memoire-et-espace-noms.html">mémoire et espace de noms</a></p>

  <p><strong>prérequis :</strong></p>

  <ul>
    <li><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/coder/code.html">code</a></li>
  </ul>
</blockquote>

<p>On montrer comment on peut gérer les variables dans un programme, et l’utilité des espaces de noms (en prenant l’exemple de python) pour le faire.</p>

<p>Nous ne rentrerons pas dans les détails, la gestion de la mémoire est quelque chose de compliqué. Nous nous contenterons de présenter les caractéristiques fondamentales et les conséquences que cela implique sur la gestion des variables et des objets.</p>

<h2 id="la-mémoire">la mémoire</h2>

<p>On peut considérer la mémoire d’un ordinateur comme un long tableau de taille (habituellement mesurée en <a href="https://fr.wikipedia.org/wiki/Octet">octet</a>) fixe, dépendant de votre ordinateur.</p>

<p><img src="/cours_informatique/assets/cours/algorithmie/poo/memoire.png" alt="mémoire" style="margin: auto;display: block;"></p>

<blockquote>
  <p>Cette taille est souvent plus grande que votre <a href="https://fr.wikipedia.org/wiki/M%C3%A9moire_vive">RAM</a>, grâce au mécanisme du <a href="https://fr.wikipedia.org/wiki/Espace_d%27%C3%A9change">swap</a>.</p>
</blockquote>

<p>Comme un programme n’est jamais seul à être exécuté sur un ordinateur et que — pour des raisons de sécurité — un programme $A$ ne doit pas pouvoir accéder à la mémoire utilisée par un programme $B$ :</p>

<blockquote class="note">
  <p>Le <strong>système d’exploitation</strong> est le seul à pouvoir accéder à une case donnée de la mémoire via son indice, comme on pourrait le faire avec un tableau normal. Un programme spécifique en revanche, ne peut accéder qu’à la partie de la mémoire qui lui a été allouée par le système d’exploitation</p>
</blockquote>

<h3 id="accéderallouer-de-la-mémoire">accéder/allouer de la mémoire</h3>

<p>Comme le système d’exploitation alloue de la mémoire et que plusieurs programmes se la partagent, il est uniquement possible pour un programme donné :</p>

<ul>
  <li>de demander un <strong>bloc</strong> de $k$ octets <strong>consécutifs</strong> de la mémoire</li>
  <li>de libérer un bloc de mémoire alloué.</li>
</ul>

<p>Il lui est en revanche impossible :</p>

<ul>
  <li>de modifier un bloc qui lui a été alloué</li>
  <li>de choisir l’endroit de la mémoire qu’il veut se faire allouer</li>
</ul>

<p>On ne sait en effet pas si la mémoire à côté d’un bloc est libre ou non. Par exemple dans la figure ci-dessous, le seul emplacement libre en mémoire est la case blanche. Le programme <em>vert</em> ne peut demander à augmenter le bloc de 3 octets qui lui est alloué, sinon il risque de rentrer en conflit avec le programme <em>rouge</em>.</p>

<p><img src="/cours_informatique/assets/cours/algorithmie/poo/memoire-partagee.png" alt="mémoire partagée" style="margin: auto;display: block;"></p>

<blockquote class="note">
  <p>C’est ce qui fait qu’il est impossible d’augmenter simplement la taille d’un tableau. Il faut le recréer et recopier toutes ses valeurs dans un autre endroit de la mémoire.</p>
</blockquote>

<h3 id="stocker-en-mémoire">stocker en mémoire</h3>

<p>Avant de parler des moyens qu’à un programme pour se rappeler ce qu’il a stocké, regardons comment on peut stocker des objets en mémoire en prenant l’exemple d’un entier.</p>

<p>La façon courante de stocker des objets est d’utiliser des <strong>références</strong>. Mais pour pour bien comprendre ce que c’est il faut commencer par parler (un peu) des valeurs.</p>

<h4 id="stockage-de-valeurs">stockage de valeurs</h4>

<p>La mémoire étant une suite fini d’octets, si l’on veut stocker plus qu’un nombre entre 0 et 255 (ou -128, 127 s’il est <a href="https://en.wikipedia.org/wiki/Signed_number_representations">signé</a>), il faut lui réserver plus d’une case.</p>

<p>Au début de l’informatique, il y avait plusieurs types d’entiers, selon ce qu’on voulait stocker. Pa exemple :</p>

<ul>
  <li>pour stocker ds entier de 0 à 255 on avait le <code class="language-plaintext highlighter-rouge">char</code> ( octet)</li>
  <li>pour stocker des entiers de -32768 à 32767 on avait le type <code class="language-plaintext highlighter-rouge">int</code> (2 octet)</li>
  <li>pour des entiers allant de −2147483647 à 2147483647 on avait le type <code class="language-plaintext highlighter-rouge">long</code> (4 octet)</li>
</ul>

<p>On précisait dans notre programme quel type d’entier on voulait utiliser pour telle ou telle variable et un espace mémoire lui était alloué :</p>

<blockquote class="note">
  <p>Dans l’<strong>ancien temps</strong> une variable était égale à son indice en mémoire et ne contenant qu’une donnée</p>
</blockquote>

<p><img src="/cours_informatique/assets/cours/algorithmie/poo/memoire-int.png" alt="un int" style="margin: auto;display: block;"></p>

<p>Ce type de fonctionnement a ses avantages :</p>

<ul>
  <li>de ne pas se préoccuper de la taille en mémoire. La taille est fixée au départ selon le type choisi</li>
  <li>il y a une correspondance stricte entre variable et indice dans le tableau de la mémoire</li>
  <li>la taille d’un tableau d’objets d’un type fixé est facile à calculer.</li>
</ul>

<p>Mais cela avait aussi de (très) gros inconvénients :</p>

<ul>
  <li>comment coder 32768 si je n’ai décidé au départ que ma variable était un <code class="language-plaintext highlighter-rouge">int</code> ?</li>
  <li>on ne peut pas avoir de tableaux combinant plusieurs types d’objets car il est impossible de calculer facilement l’indice donné d’un tableau contenant plusieurs types .</li>
  <li>si on écrit <code class="language-plaintext highlighter-rouge">i = j</code>, il <strong>faut</strong> recopier le contenu de <code class="language-plaintext highlighter-rouge">i</code> (à l’adresse mémoire de <code class="language-plaintext highlighter-rouge">i</code>) dans <code class="language-plaintext highlighter-rouge">j</code> (à l’adresse mémoire de <code class="language-plaintext highlighter-rouge">j</code>) : un même objet ne peut pas avoir plusieurs noms.</li>
</ul>

<h4 id="stockage-dobjets">stockage d’objets</h4>

<p>Actuellement, on préfère ne pas avoir à gérer directement la mémoire et surtout, dissocier la variable de la valeur  : écrire <code class="language-plaintext highlighter-rouge">i = j</code> doit signifier que l’objet désigné par la variable <code class="language-plaintext highlighter-rouge">j</code> doit <strong>aussi</strong> être désigné par <code class="language-plaintext highlighter-rouge">i</code>.</p>

<p>Pour cela, il faut dissocier la variable de l’emplacement en mémoire de l’objet. La définition actuelle d’une <em>variable</em> est alors :</p>

<blockquote class="note">
  <p>Une <strong>variable</strong> est une référence à un objet stocké en mémoire.</p>
</blockquote>

<p>Le moyen de le plus simple de définir une référence, c’est de prendre l’indice de la première case mémoire contenant l’objet.</p>

<p>Prenons un exemple : supposons que notre ordinateur dispose de 16Go octets de RAM. L’indice de notre notre tableau de mémoire va alors de $0$ à $10^9-1$ : il faut 4 octets pour stocker un indice en mémoire.</p>

<p><img src="/cours_informatique/assets/cours/algorithmie/poo/memoire-reference.png" alt="référence" style="margin: auto;display: block;"></p>

<p>La figure ci-dessus montre alors une variable (<em>verte</em>) représentant un objet entier (<em>orange</em>) : elle contient l’indice du tableau de la mémoire contenant le premier élément de l’objet (sa référence, $i^\star$ dans la figure).</p>

<p>Les bénéfices de cette méthode sont énormes :</p>

<ul>
  <li>les objets sont uniques, en écrivant <code class="language-plaintext highlighter-rouge">i = j</code> les deux variables ont le même objet en référence</li>
  <li>un tableau devient un tableau de référence, il peut contenir des types d’objets différents sans soucis</li>
  <li>on peut facilement modifier un objet, sans avoir à changer toutes les variables qui le référencent.</li>
</ul>

<blockquote class="attention">
  <p>Comme on manipule directement les objets, il faut faire attention aux effets de bords lorsqu’e ‘on les modifie</p>
</blockquote>

<p>Par exemple en python :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">t</span>
<span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span>
<span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</code></pre></div></div>

<details><summary>que vaut <code class="language-plaintext highlighter-rouge">print(t)</code> ?</summary><div>
<p><code class="language-plaintext highlighter-rouge">[1, 12, 3]</code> on a modifié l’objet référencé par <code class="language-plaintext highlighter-rouge">u</code>, qui est le même que celui référencé par <code class="language-plaintext highlighter-rouge">t</code></p>

</div></details>

<p>Plus insidieux :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">t</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="s">"?"</span><span class="p">]</span>
<span class="n">u</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">12</span>
<span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</code></pre></div></div>

<details><summary>que vaut <code class="language-plaintext highlighter-rouge">print(t)</code> ?</summary><div>
<p><code class="language-plaintext highlighter-rouge">[1, 12, 3]</code> on a modifié l’objet référencé par <code class="language-plaintext highlighter-rouge">u[1]</code>, qui est le même que celui référencé par <code class="language-plaintext highlighter-rouge">t</code></p>

</div></details>

<h2 id="programme-objet">programme objet</h2>

<p>La quasi-entièreté des langages actuellement sont dit <em>à objet</em>. C’est à dire que :</p>

<ul>
  <li>ce que manipule un programme est appelé objet.</li>
  <li>les variables sont des références aux objets.</li>
</ul>

<p>Ces langages permettent de créer des programmes en utilisant uniquement les deux mécanismes ci-dessous :</p>

<blockquote class="note">
  <p>Pour qu’un programme objet fonctionne, on a besoin de deux mécanismes :</p>

  <ul>
    <li>un moyen de stocker des données et de les manipuler (les objets et leurs méthodes)</li>
    <li>un moyen d’y accéder (les variables)</li>
  </ul>

</blockquote>

<h3 id="objets">objets</h3>

<p>On y reviendra, mais pour l’instant considérez qu’un objet est une structure de donnée générique permettant de gérer tout ce dont à besoin un programme :</p>

<ul>
  <li>des données</li>
  <li>des fonctions</li>
  <li>des modules</li>
  <li>…</li>
</ul>

<p>Tout est objet dans un langage objet.</p>

<h3 id="variables">variables</h3>

<p>Les variables sont des références aux objets. Pour ce faire, on utilise l’opérateur d’affectation <code class="language-plaintext highlighter-rouge">=</code> :</p>

<pre><code class="language-txt">variable = objet
</code></pre>

<p>A gauche de l’opérateur <code class="language-plaintext highlighter-rouge">=</code> se trouve une <strong>variable</strong> (en gros, quelque chose ne pouvant commencer par un nombre) et à droite un <strong>objet</strong>. Dans toute la suite du programme, dès que le programme rencontrera le nom, il le remplacera par l’objet.</p>

<blockquote class="attention">
  <p>Un variable n’est <strong>PAS</strong> une chaîne de caractères. Une chaîne de caractère est un objet alors qu’un nom n’est qu’un alias vers un objet.</p>
</blockquote>

<p>Il est important de comprendre que l’opérateur d’affectation <code class="language-plaintext highlighter-rouge">=</code> n’est pas symétrique. À gauche, des variables et à droite, des objets.</p>

<blockquote class="note">
  <p>Une variable n’est <strong>pas</strong> l’objet, c’est une référence à celui-ci</p>
</blockquote>

<p>La variable peut être vue comme le <strong>nom</strong> de l’objet à ce moment du programme. Un objet pourra avoir plein de noms différents au cours de l’exécution du programme, voir plusieurs noms en même temps.</p>

<p>Pour s’y retrouver et et avoir une procédure déterministe pour retrouver les objets associés aux variables, voir choisir parmi plusieurs variables de même noms, elles sont regroupées par ensembles — nommés <strong>espaces de noms</strong> hiérarchiquement ordonnés.</p>

<h2 id="espace-noms">espaces de noms</h2>

<p>Les espaces de noms nous permettent d’abstraire ce qu’il se passe en mémoire :</p>

<ul>
  <li>on considère que les objets sont stocké dans <em>l’espace des objets</em> : cet espace est <strong>unique</strong>
</li>
  <li>on accède aux objets via leurs noms, eux même stockés des des <em>espaces de noms</em> : il y a de <strong>nombreux</strong> espaces de noms.</li>
</ul>

<p>Pour chaque <em>espace de noms</em> :</p>

<ul>
  <li>il ne peut y avoir 2 noms identiques dans un même espace de noms</li>
  <li>à chaque nom est associé un objet</li>
  <li>certains espaces de noms possèdent un parent</li>
</ul>

<blockquote>
  <p>Pour expliciter comment tout ça se passe, on va se concentrer sur le <a href="https://docs.python.org/3/tutorial/classes.html#python-scopes-and-namespaces">langage python</a>, mais la procédure est similaire pour les autres langages à objets.</p>
</blockquote>

<p>Lorsque l’on exécute un programme, un premier espace de nom est créé :</p>

<blockquote class="note">
  <p>Au démarrage d’une exécution d’un programme l’espace de nom principal, nommé <code class="language-plaintext highlighter-rouge">global</code> est crée.</p>
</blockquote>

<p>Au départ, il ne contient rien, à part des noms commençant et finissant par <code class="language-plaintext highlighter-rouge">__</code>, et qui sont utilisés par python.</p>

<blockquote>
  <p>Pour voir les noms définit dans l’espace de nom global, on utilise en python la fonction <code class="language-plaintext highlighter-rouge">globals()</code>.</p>
</blockquote>

<p>A tout moment de l’exécution d’un programme, un espace de nom pourra être crée. En  revanche :</p>

<blockquote class="note">
  <p>A tout moment du programme, on pourra créer un nouvel espace de nom : de nombreux espaces de noms pourront être définis, mais il existera toujours <strong>un</strong> espace de nom courant qui où l’on créera les et où dont on cherchera le nom par défaut.</p>
</blockquote>

<p>On donnera dans la suite de cette partie des exemples qui permettront de mieux comprendre ce processus.</p>

<blockquote>
  <p>Pour voir les noms définit dans l’espace de nom courant, on utilise en python la fonction <code class="language-plaintext highlighter-rouge">locals()</code>.</p>
</blockquote>

<h3 id="noms-et-variables">noms et variables</h3>

<p>Prenons plusieurs exemples, qui illustrerons les cas principaux.</p>

<h4 id="association-objet-et-noms">association objet et noms</h4>

<p>Considérons le programme suivant :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Exécutons le ligne à ligne :</p>

<ol>
  <li>avant l’exécution de la première ligne :
    <ol>
      <li>on a un unique espace de nom (<code class="language-plaintext highlighter-rouge">global</code>) qui est l’espace courant (en vert sur la figure)</li>
      <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-1-1.png" alt="cas-1-1" style="margin: auto;display: block;"></li>
    </ol>
  </li>
  <li>on exécute la première ligne. Elle s’exécute ainsi :
    <ol>
      <li>on commence à droite du <code class="language-plaintext highlighter-rouge">=</code> : on crée un objet de type entier</li>
      <li>on crée le nom <code class="language-plaintext highlighter-rouge">x</code> dans l’espace de nom courant (ici <code class="language-plaintext highlighter-rouge">global</code>) et on lui affecte l’objet.</li>
      <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-1-2.png" alt="cas-1-2" style="margin: auto;display: block;"></li>
    </ol>
  </li>
  <li>on exécute la deuxième ligne. Elle s’exécute ainsi :
    <ol>
      <li>on commence à droite du <code class="language-plaintext highlighter-rouge">=</code> : on crée un objet de type entier</li>
      <li>on crée le nom <code class="language-plaintext highlighter-rouge">y</code> dans l’espace de nom courant (ici <code class="language-plaintext highlighter-rouge">global</code>) et on lui affecte l’objet.</li>
      <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-1-3.png" alt="cas-1-3" style="margin: auto;display: block;"></li>
    </ol>
  </li>
</ol>

<p>A la fin du programme, il y a <strong>2 objets entiers différents</strong> (même si tous les 2 valent 1), dont les noms sont, dans l’espace de nom global, respectivement <code class="language-plaintext highlighter-rouge">x</code>et <code class="language-plaintext highlighter-rouge">y</code>.</p>

<h4 id="réutilisation-du-même-nom">réutilisation du même nom</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div></div>

<p>Exécutons le ligne à ligne :</p>

<ol>
  <li>avant l’exécution de la première ligne :
    <ol>
      <li>on a un unique espace de nom (<code class="language-plaintext highlighter-rouge">global</code>) qui est l’espace courant (en vert sur la figure)</li>
      <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-1-1.png" alt="cas-1-1" style="margin: auto;display: block;"></li>
    </ol>
  </li>
  <li>on exécute la première ligne. Elle s’exécute ainsi :
    <ol>
      <li>on commence à droite du <code class="language-plaintext highlighter-rouge">=</code> : on crée un objet de type entier</li>
      <li>on crée le nom <code class="language-plaintext highlighter-rouge">x</code> dans l’espace de nom courant (ici <code class="language-plaintext highlighter-rouge">global</code>) et on lui affecte l’objet.</li>
      <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-1-2.png" alt="cas-1-2" style="margin: auto;display: block;"></li>
    </ol>
  </li>
  <li>on exécute la deuxième ligne. Elle s’exécute ainsi :
    <ol>
      <li>on commence à droite du <code class="language-plaintext highlighter-rouge">=</code> : on crée un objet de type entier</li>
      <li>on crée le nom <code class="language-plaintext highlighter-rouge">x</code> dans l’espace de nom courant (ici <code class="language-plaintext highlighter-rouge">global</code>) et on lui affecte l’objet.</li>
      <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-2-1.png" alt="cas-2-1" style="margin: auto;display: block;"></li>
    </ol>
  </li>
</ol>

<p>Notez que le fait qu’un nom identique existe déjà n’est pas important. Le nouveau nom écrase l’autre :</p>

<blockquote class="note">
  <p>Dans un espace de noms, chaque nom est différent. Réutiliser le même nom remplace le nom précédent.</p>
</blockquote>

<p>Le programme a créé <strong>2 objets</strong> (un entier valant 1 et un entier valant 3), mais à la fin de la deuxième ligne du programme, seul l’entier valant 3 a un nom (<code class="language-plaintext highlighter-rouge">x</code>).</p>

<p>Comme il est maintenant impossible d’accéder à l’entier valant <code class="language-plaintext highlighter-rouge">1</code> : python le détruit.</p>

<p><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-2-2.png" alt="cas-2-2" style="margin: auto;display: block;"></p>

<blockquote class="note">
  <p>Tout objet qui n’est plus référencé par une variable est détruit.</p>
</blockquote>

<h4 id="un-objet-peut-avoir-plusieurs-noms">un objet peut avoir plusieurs noms</h4>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span>
</code></pre></div></div>

<p>Exécutons le ligne à ligne :</p>

<ol>
  <li>avant l’exécution de la première ligne :
    <ol>
      <li>on a un unique espace de nom (<code class="language-plaintext highlighter-rouge">global</code>) qui est l’espace courant (en vert sur la figure)</li>
      <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-1-1.png" alt="cas-1-1" style="margin: auto;display: block;"></li>
    </ol>
  </li>
  <li>on exécute la première ligne. Elle s’exécute ainsi :
    <ol>
      <li>on commence à droite du <code class="language-plaintext highlighter-rouge">=</code> : on crée un objet de type entier</li>
      <li>on crée le nom <code class="language-plaintext highlighter-rouge">x</code> dans l’espace de nom courant (ici <code class="language-plaintext highlighter-rouge">global</code>) et on lui affecte l’objet.</li>
      <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-1-2.png" alt="cas-1-2" style="margin: auto;display: block;"></li>
    </ol>
  </li>
  <li>on exécute la deuxième ligne. Elle s’exécute ainsi :
    <ol>
      <li>on commence à droite du <code class="language-plaintext highlighter-rouge">=</code> : on cherche le nom <code class="language-plaintext highlighter-rouge">x</code> dans l’espace de nom courant. On le trouve et on lui substitue son objet (un entier valant 1)</li>
      <li>on crée le nom <code class="language-plaintext highlighter-rouge">x</code> dans l’espace de nom courant (ici <code class="language-plaintext highlighter-rouge">global</code>) et on lui affecte l’objet.</li>
      <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-3-1.png" alt="cas-3-1" style="margin: auto;display: block;"></li>
    </ol>
  </li>
</ol>

<p>Le programme n’a crée qu’un objet (un entier valant 1) et il a deux noms (<code class="language-plaintext highlighter-rouge">x</code> et <code class="language-plaintext highlighter-rouge">y</code>) :</p>

<blockquote class="note">
  <p>Dans un même espace de noms, un même objet peut être référencé plusieurs fois, sous plusieurs noms différents.</p>
</blockquote>

<p>Les noms ne sont jamais utilisés en tant que tel. Dès qu’ils sont rencontrés, ils sont immédiatement remplacés par les objets qu’ils référencent.</p>

<blockquote class="note">
  <p>Pour exécuter une instruction, on commence <strong>toujours</strong> par remplacer les variables par les objets qu’elles référencent.</p>
</blockquote>

<p>La remarque précédente permet de comprendre mieux ce que fait le code suivant (et pourquoi cela fonctionne) :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">y</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>
</code></pre></div></div>

<details><summary>solution</summary><div>
<p>Il échange les objets référencés par <code class="language-plaintext highlighter-rouge">x</code> et <code class="language-plaintext highlighter-rouge">y</code>.</p>

<p>Cela marche car on commence par remplacer les variables par les objets (la droite du <code class="language-plaintext highlighter-rouge">=</code>) avant de créer les variables (la gauche du <code class="language-plaintext highlighter-rouge">=</code>).</p>
</div></details>

<h3 id="fonctions">fonctions</h3>

<p>L’exécution d’une fonction est un moment où un espace de nom est créé. Cela se passe  selon le processus suivant :</p>

<blockquote>
  <p>Lorsque l’on exécute une fonction on procède comme suit :</p>

  <ol>
    <li>on crée un nouvel espace de nom $F$</li>
    <li>l’espace de nom courant est affecté au parent de $F$</li>
    <li>$F$ devient le nouvel espace de nom courant.</li>
    <li>on affecte les paramètres de la fonction à leurs noms</li>
    <li>on exécute ligne à ligne la fonction</li>
    <li>le parent de $F$ devient le nouvel espace de nom courant</li>
    <li>on supprime l’espace de nom $F$</li>
  </ol>
</blockquote>

<h4 id="exécution-dune-fonction">exécution d’une fonction</h4>

<style>
    table, td, tr, th, pre {
        padding:0;
        margin:0;
        border:none
    }
</style>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
   <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Exécutons le ligne à ligne :</p>

<ol>
  <li>avant l’exécution de la première ligne :
    <ol>
      <li>on a un unique espace de nom (<code class="language-plaintext highlighter-rouge">global</code>) qui est l’espace courant (en vert sur la figure)</li>
      <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-1-1.png" alt="cas-1-1" style="margin: auto;display: block;"></li>
    </ol>
  </li>
  <li>la ligne 2 définit une fonction de nom <code class="language-plaintext highlighter-rouge">f</code> qui est ajouté à l’espace de nom courant.
    <ol>
      <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-4-1.png" alt="cas-4-1" style="margin: auto;display: block;"></li>
    </ol>
  </li>
  <li>on passe directement à la ligne 5 puisque les lignes 3 et 4 sont le contenu de la fonction.
    <ol>
      <li>Cette ligne crée un objet entier (valant 2) et l’affecte au nom <code class="language-plaintext highlighter-rouge">i</code>.</li>
      <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-4-2.png" alt="cas-4-2" style="margin: auto;display: block;"></li>
    </ol>
  </li>
  <li>la ligne 6 est encore une affectation. On commence par trouver l’objet à droite du <code class="language-plaintext highlighter-rouge">=</code> c’est le résultat de <code class="language-plaintext highlighter-rouge">f(i)</code>. Il faut donc exécuter la fonction <code class="language-plaintext highlighter-rouge">f</code> pour connaître cet objet :
    <ol>
      <li>on cherche l’objet associé à <code class="language-plaintext highlighter-rouge">i</code> qui sera le (premier) paramètre de la fonction</li>
      <li>on crée un espace de nom qui devient l’espace de nom courant :
        <ol>
          <li>l’ancien espace de nom courant devient son parent</li>
          <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-4-3.png" alt="cas-4-3" style="margin: auto;display: block;"></li>
        </ol>
      </li>
      <li>on affecte le premier paramètre de <code class="language-plaintext highlighter-rouge">f</code> au nom <code class="language-plaintext highlighter-rouge">x</code>(le nom du premier paramètre de <code class="language-plaintext highlighter-rouge">f</code> lors de sa définition)
        <ol>
          <li>les nouveaux noms sont <strong>toujours</strong> créés dans l’espace de nom courant</li>
          <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-4-4.png" alt="cas-4-4" style="margin: auto;display: block;"></li>
        </ol>
      </li>
      <li>on exécute la ligne 2 qui est la première ligne de la fonction <code class="language-plaintext highlighter-rouge">f</code> :
        <ol>
          <li>on crée un objet entier (valant 4) qui est le résultat de l’opération à droite du <code class="language-plaintext highlighter-rouge">=</code> (notez que le nom <code class="language-plaintext highlighter-rouge">x</code> est bien défini dans l’espace de nom courant) et on l’affecte au nom <code class="language-plaintext highlighter-rouge">i</code> dans l’espace de nom courant</li>
          <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-4-5.png" alt="cas-4-5" style="margin: auto;display: block;"></li>
        </ol>
      </li>
      <li>on exécute la ligne 3 :
        <ol>
          <li>on crée l’objet résultant de l’opération somme (un entier valant 7)</li>
          <li>la fonction est terminée, son espace de nom courant est détruit</li>
          <li>l’espace de nom courant devient le parent de l’espace de nom détruit</li>
          <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-4-6.png" alt="cas-4-6" style="margin: auto;display: block;"></li>
          <li>on rend l’objet résultat de la fonction</li>
        </ol>
      </li>
      <li>la droite du signe <code class="language-plaintext highlighter-rouge">=</code> de la ligne 6 est trouvée (c’est un entier valant 6) et il est affecté à la variable <code class="language-plaintext highlighter-rouge">x</code> de l’espace de nom courant (qui est à nouveau <code class="language-plaintext highlighter-rouge">global</code>)
        <ol>
          <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-4-7.png" alt="cas-4-7" style="margin: auto;display: block;"></li>
          <li>les objets sans nom sont détruits</li>
          <li><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-4-8.png" alt="cas-4-8" style="margin: auto;display: block;"></li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<h4 id="espaces-de-noms-parent">espaces de noms parent</h4>

<p>L’espace de nom parent sert lorsque l’on cherche un nom qui n’est pas défini dans l’espace de nom courant :</p>

<blockquote class="note">
  <p>Si un nom est recherché, mais que celui-ci n’est défini dans l’espace de nom courant, le nom est recherché dans l’espace de nom parent de l’espace courant.</p>
</blockquote>

<style>
    table, td, tr, th, pre {
        padding:0;
        margin:0;
        border:none
    }
</style>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td>
<td class="code"><pre><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
   <span class="n">i</span> <span class="o">=</span> <span class="n">C</span> <span class="o">*</span> <span class="n">x</span>
   <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">3</span>

<span class="n">C</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

<p>Lors de l’exécution de la fonction <code class="language-plaintext highlighter-rouge">f</code> (instruction de la ligne 7), sa première ligne cherche la variable nommée <code class="language-plaintext highlighter-rouge">C</code>. On se trouve dans cet état là :</p>

<p><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-5-1.png" alt="cas-5-1" style="margin: auto;display: block;"></p>

<p>La variable <code class="language-plaintext highlighter-rouge">C</code> n’existe pas dans l’espace de nom courant (celui de <code class="language-plaintext highlighter-rouge">f</code>), le programme va alors cherche dans l’espace de nom parent s’il existe. Ici c’est le cas puisque l’espace parent de <code class="language-plaintext highlighter-rouge">f</code> est <code class="language-plaintext highlighter-rouge">global</code> dans lequel <code class="language-plaintext highlighter-rouge">C</code> est défini : le programme ne produit donc pas une erreur et trouve le bon objet.</p>

<blockquote class="note">
  <p>Les variables sont <strong>toujours</strong> crées dans l’espace d nom courant, mais leur recherche remonte de parent en parent jusqu’à la trouver.</p>
</blockquote>

<h3 id="import">import</h3>

<p>Lorsque l’on importe un fichier, un espace de nom est créé et le fichier entier est lu. Lors de sa lecture, les noms définis sont placés dans cet espace.</p>

<blockquote class="note">
  <p>Les modules possèdent un espace de nom qui contient les variables qui y sont définies</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span>

<span class="k">print</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">42</span><span class="p">)))</span>
</code></pre></div></div>

<p>Avant l’exécution de l’instruction <code class="language-plaintext highlighter-rouge">print</code> on est dans cet état :</p>

<p><img src="/cours_informatique/assets/cours/algorithmie/poo/cas-4-8.png" alt="cas-6-1" style="margin: auto;display: block;"></p>

<p>On accède à l’espace de nom du module par la notation pointée : <code class="language-plaintext highlighter-rouge">random.randint</code> signifie le nom <code class="language-plaintext highlighter-rouge">randint</code> dans l’espace de nom de <code class="language-plaintext highlighter-rouge">random</code>.</p>

<blockquote>
  <p>notez que le module <code class="language-plaintext highlighter-rouge">math</code> n’a plus d’espace de nom associé puisque l’on a juste <em>récupéré</em> un nom qui y est défini.</p>
</blockquote>

<h2 id="notation-pointée">notation pointée</h2>

<p>En python, (pratiquement) tout a un espace de nom. On s’en sert dès qu’on utilise la notation pointée.</p>

<p>on l’a vue pour les modules, mais c’est aussi vrai pour les objets. En considérant le code suivant :</p>

<pre><code class="language-pyhton">c = "coucou"
c2 = c.uppercase()
</code></pre>

<p>Le nom <code class="language-plaintext highlighter-rouge">uppercase</code> est défini dans l’espace de nom de la chaine de caractère <code class="language-plaintext highlighter-rouge">"coucou"</code> (en fait, c’est dans sa classe, mais on le verra précisément plus tard).</p>

<p>C’est une notation <strong>très puissante</strong> ! Il ne faut pas avoir peur de chainer ces notations. ON appelle cela des chaînages :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">c</span><span class="p">.</span><span class="n">d</span><span class="p">()</span>
</code></pre></div></div>

<p>Signifie :</p>

<ol>
  <li>On exécute <code class="language-plaintext highlighter-rouge">d</code> qui est dans l’espace de nom de <code class="language-plaintext highlighter-rouge">a.b.c</code>
</li>
  <li>
<code class="language-plaintext highlighter-rouge">c</code> est dans l’espace de nom de <code class="language-plaintext highlighter-rouge">a.b</code>
</li>
  <li>
<code class="language-plaintext highlighter-rouge">b</code> est dans l’espace de nom de <code class="language-plaintext highlighter-rouge">a</code>
</li>
  <li>
<code class="language-plaintext highlighter-rouge">a</code> est dans l’espace de noms courant.</li>
</ol>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique à l'école centrale marseille.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
