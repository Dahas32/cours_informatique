<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Algorithme : calcul | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="Algorithme : calcul">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<meta property="og:description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<link rel="canonical" href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/calcul.html">
<meta property="og:url" content="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/calcul.html">
<meta property="og:site_name" content="cours d’informatique">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Algorithme : calcul">
<script type="application/ld+json">
{"description":"Support de cours/td d’informatique à l’école centrale marseille.","@type":"WebPage","url":"/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/calcul.html","headline":"Algorithme : calcul","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Algorithme : calcul</h1>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/">Théorie et pratiques algorithmique</a> / <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/">théorie</a> / <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/calcul.html">calcul</a></p>

  <p>prérequis :</p>

  <ul>
    <li><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/pseudo-code.html">algorithmie/pseudo-code</a></li>
  </ul>
</blockquote>

<p>Dans <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/pseudo-code.html">la partie précédente</a>, on a donné une façon d’écrire des pseudo-codes. Mais est-ce la seule façon de faire ? Et, au final, que peut-on réellement faire avec un algorithme ?</p>

<h2 id="algorithmes-et-pseudo-code">algorithmes et pseudo-code</h2>

<p>Un algorithme, <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/algorithmes.html#algorithme">on l’a vu</a>, est un ensemble de règles propre à un <strong>calcul</strong>. La <a href="https://dictionnaire.lerobert.com/definition/calcul">définition de calcul</a> du Petit Robert est cependant très générale et ne pose pas vraiment la question du choix des règles, ni de comment réaliser effectivement ce calcul.</p>

<p>La définition générale d’un algorithme est alors (voir <a href="https://fr.wikipedia.org/wiki/Th%C3%A8se_de_Church#Formulation_de_la_th%C3%A8se">la page wikipedia sur la calculabilité</a>)  :</p>

<blockquote class="note">
  <p>Les <strong>4 propriétés générales</strong> qui définissent un algorithme :</p>

  <ol>
    <li>un algorithme est constitué d’un ensemble fini de règles, décrites avec un nombre fini de symboles</li>
    <li>si l’algorithme produit un résultat cela doit être fait après un nombre fini d’étapes (une étape étant l’application d’une règle) successives.</li>
    <li>un humain doit pouvoir suivre chaque étape avec un papier et un crayon</li>
    <li>exécuter une règle ne doit pas nécessiter d’intelligence (à part celle pour comprendre la règle)</li>
  </ol>

</blockquote>

<p>Le terme <strong>fini</strong> est crucial : pour qu’un humain comprenne, et surtout puisse agir, il ne faut pas qu’il y ait un nombre infini de choses à regarder (chaque chose à faire prend un temps de réflexion non nul, une instruction contenant un nombre infini n’est humainement pas réalisable).</p>

<h3 id="règles-dun-algorithme">règles d’un algorithme</h3>

<p>On en déduit la définition (très générale) d’une règle d’un algorithme :</p>

<blockquote class="note">
  <p>Une <strong>règle</strong> d’un algorithme est une instruction définie par un nombre <strong>fini</strong> de symboles.</p>
</blockquote>

<p>Fini ne veut pas dire petit nombres. Un algorithme peut utiliser des nombres entiers aussi grand qu’il
le veut, du moment qu’ils ne soient pas infini.</p>

<h3 id="objet-manipulables">objet manipulables</h3>

<p>Puisque l’on a le droit de ne manipuler que des choses finies, un algorithme ne peut manipuler que des <a href="https://fr.wikipedia.org/wiki/Mot_(math%C3%A9matiques)">mots d’un alphabet fini</a>. La conséquence fondamentale de ceci est que :</p>

<blockquote class="note">
  <p><strong>un algorithme ne peut pas manipuler de nombres réels</strong>. On ne peut considérer un réel que comme une abstraction (un symbole particulier) ou une approximation (on ne considère qu’un nombre fini de décimales).</p>
</blockquote>

<p>Prenons $\pi$ par exemple. On peut le considérer de deux manières : comme le symbole $\pi$ et de là faire des opérations sur lui (comme $2 \cdot \pi$, ou $\frac{3\pi}{3}$, …) de façon formelle, c’est à dire sans jamais connaître sa valeur ou comme une valeur approchée de lui (3.1415 par exemple) et ainsi rendre des valeurs approchées des différentes opérations. On ne pourra cependant <strong>jamais</strong> avoir la valeur exacte de $\pi$ avec un algorithme (et ce même s’il avait une mémoire infinie).</p>

<p>Ce n’est pas bien grave en général puisque les lois physiques sont presque tout le temps stables (de petits effets impliquent de petites causes) : considérer les réels en <a href="https://fr.wikipedia.org/wiki/Notation_scientifique">notation scientifique</a> en se fixant une précision ne gène pas les calculs physiques.</p>

<blockquote>
  <p>Faites tout de même attention car parfois, c’est problématique. Pour le calcul d’effets chaotiques comme la météo où <a href="https://fr.wikipedia.org/wiki/Effet_papillon">de petits effets produisent de grandes causes</a>, certes, mais aussi lorsque l’on prend l’inverse de choses très petites qui du coup deviennent très grandes. Ce sont des problèmes dit de <a href="https://fr.wikipedia.org/wiki/Stabilit%C3%A9_num%C3%A9rique">stabilité numérique</a>.</p>
</blockquote>

<p>En conclusion :</p>

<blockquote class="note">
  <p>Les objets manipulables par un algorithme sont uniquement :</p>

  <ul>
    <li>les entiers finis</li>
    <li>les approximations finies de réels</li>
    <li>les chaînes de caractères</li>
  </ul>

</blockquote>

<h3 id="regles-pseudo-code">règles d’un pseudo-code</h3>

<p>Un <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/pseudo-code.html#regles">pseudo-code</a> est un algorithme particulier. Il respecte bien les 4 propriétés générales d’un algorithme, mais les règles qui le régissent sont <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/pseudo-code.html#regles">définies précisément</a>. On peut montrer que toutes ces règles peuvent être réduites à un ensemble bien plus petit :</p>

<blockquote class="note">
  <p>On peut ramener l’ensemble des <a href="https://en.wikipedia.org/wiki/Structured_program_theorem">règles d’un pseudo-code</a> (même si ce sera plus compliqué d’écrire le code) à trois types d’instructions et à trois façon de les exécuter.</p>

  <p>Une <strong>instruction</strong>  est soit :</p>

  <ul>
    <li>une affectation d’un entier (voir même juste un bit) à une variable</li>
    <li>une lecture d’une variable</li>
    <li>un test d’égalité entre deux variables</li>
  </ul>

  <p>Un pseudo-code doit pouvoir :</p>

  <ul>
    <li>exécuter une instruction puis une autre, <strong>séquentiellement</strong>
</li>
    <li>exécuter une instruction si un test d’égalité est vrai</li>
    <li>exécuter un bloc d’instructions tant qu’un test d’égalité est vrai</li>
  </ul>
</blockquote>

<p>Tous les pseudo-codes utilisant les 6 règles ci-dessus auront la même expressivité (on pourra faire exactement les mêmes choses) que ceux utilisant <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/pseudo-code.html#regles">les règles</a> utilisées couramment, ce sera juste plus long et compliquer à écrire, c’est pourquoi leur intérêt est uniquement théorique.</p>

<h3 id="equi-algo-pseudo-code">équivalence entre algorithme et pseudo-code ?</h3>

<p>On est intimement convaincu (c’est ce qu’on appelle la <a href="https://fr.wikipedia.org/wiki/Th%C3%A8se_de_Church">thèse de Church-Turing</a>) que les règles d’un pseudo-code sont équivalentes aux règles d’un algorithme, c’est çà dire que toutes les règles qu’on pourrait inventer en un nombre fini de symbole peuvent s’écrire sous la forme de règles d’un pseudo-code.</p>

<h2 id="fonctions">fonctions</h2>

<p>Un algorithme, représenté par son pseudo code, a des entrées et une sortie : c’est une fonction. D’après ce qui précède, on a donc :</p>

<blockquote class="note">
  <p>Un algorithme à $p$ entrées, dont $q$ entrées entières, $r$ entrées approximation des réels et $s$ chaînes de caractères est une fonction de :</p>

\[f: \mathbb{N}^{q} \times R^r \times C^t \rightarrow N \cup A \cup C\]

  <p>où $\mathbb{N}$ est l’ensemble des entiers, $R$ l’ensemble des approximations de réels et $C$ l’ensemble des chaînes de caractères.</p>
</blockquote>

<p>On a pas trop dit grand chose pour l’instant. On a fait que reécrire ce qu’on savait déjà sous la forme de fonctions. On va montrer qu’on peut faire bien mieux en montran qu’un algorithme est une fonction de $\mathbb{N}$ (les entiers) dans $\mathbb{N}$.</p>

<p>Cela nous permettra de montrer qu’un algorithme ne peut pas <strong>tout</strong> calculer : il existe des fonctions de $\mathbb{N}$ dans $\mathbb{N}$ qu’aucun ordinateur ne pourra calculer (trouver des fonctions non calculables par un ordinateur n’est pas une tâche simple cependant. Il nous faudra un peut plus de connaissances pour en exhiber).</p>

<h3 id="fonction-plusieurs-entier">fonctions à plusieurs paramètres entiers</h3>

<p>Les paramètres d’un algorithme peuvent tous être représentés par des entiers :</p>

<ul>
  <li>des entiers finis : c’est clair.</li>
  <li>des approximations finies de réels : on peut utiliser la norme <a href="https://fr.wikipedia.org/wiki/IEEE_754">IEEE 754</a>. Par exemple 3.1415 en codage IEEE 754 sur 32 bits correspond à l’entier binaire : <code class="language-plaintext highlighter-rouge">01000000010010010000111001010110</code> (j’ai utilisé <a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">un convertisseur</a>)</li>
  <li>des chaînes de caractères : que l’on peut représenter comme un entier en utilisant le le codage <a href="https://fr.wikipedia.org/wiki/UTF-8">utf-8</a>. Par exemple la chaîne de caractère “Yop !” correspond au nombre binaire <code class="language-plaintext highlighter-rouge">111100101101111011100000010000000100001</code> en utilisant  (là aussi, j’ai utilisé <a href="http://hapax.qc.ca/conversion.fr.html">un convertisseur</a>).</li>
</ul>

<p>On peut donc reformuler notre assertion précédente en unifiant les paramètres (on les recodent tous sous la forme d’entiers) :</p>

<blockquote class="note">
  <p>Un algorithme est une fonction de $p$ paramètres entiers et qui rend un entier.</p>

\[f: \mathbb{N}^p \rightarrow \mathbb{N}\]

</blockquote>

<p>C’est bien mieux mais on sépare encore les algorithmes par leur nombre de paramètres. Allons plus loin.</p>

<h3 id="fonction-un-entier">fonctions à un paramètre entiers</h3>

<p>Démontrons que tout élément de $\mathbb{N}^p$ peut être représenté par un entier. Pour ce faire on montrera que $\mathbb{N}^p$ est en bijection avec $\mathbb{N}$ quelque soit $p$.</p>

<p>La figure ci-dessous montre comment faire pour $\mathbb{N}^2$. On ordonne les diagonales (la diagonale $D_i$ contient les éléments dont la somme des coordonnées est égale à $i$) les une par rapport aux autres et dans chaque diagonale on prend l’ordre lexicographque (ordre du dictionnaire en considérant chaque coordonnée comme une lettre).</p>

<p><img src="/cours_informatique/assets/cours/algorithmie/theorie_n2dansN.png" alt="compteur" style="margin: auto;display: block; width: 200px"></p>

<p>Dans le cas général, notons $D_k$ (la diagonale numéro $k$) l’ensemble des éléments $(n_1, \dots, n_p)$ de $\mathbb{N}^p$ dont la somme $\sum_i n_i$ vaut $k$. Il y a un nombre fini d’éléments dans $D_k$ puisque chaque coordonnées est plus petite que $k$ (il y a au plus $k^p$ éléments dans $D_k$), ce qui nous permet d’ordonner tous les éléments de $\mathbb{N}^p$ : $e &lt; f$ si :</p>

<ul>
  <li>$e \in D_k$ et $f \in D_{k’}$ avec $k’ &lt; k$</li>
  <li>ou si $e, f \in D_k$ et que $e$ est avant $f$ dans l’<a href="https://fr.wikipedia.org/wiki/Ordre_lexicographique#G%C3%A9n%C3%A9ralisation_aux_produits_cart%C3%A9siens_finis">ordre lexicographique</a> de $D_k$.</li>
</ul>

<p>Cet ordre nous permet de définir <a href="https://fr.wikipedia.org/wiki/Injection_(math%C3%A9matiques)">une injection</a> de $\mathbb{N}^p$ dans $\mathbb{N}$ par l’application :</p>

\[h(e) = \vert \{ g \mid g &lt; e \}\vert\]

<p>Cela fonctionne car :</p>

<ul>
  <li>si $f &lt; e$ alors $f$ est dans une diagonale plus petite ou égale à $e$, il y a donc un nombre fini d’éléments plus petit que $e$</li>
  <li>si $f &lt; e$ alors $\{ g \mid g &lt; f \} \cup \{f \} \subseteq \{ g \mid g &lt; e \}$ et donc $h(f) &lt; h(e)$</li>
  <li>si $e$ et $f$ sont deux éléments différents de $\mathbb{N}^p$ alors soit $e &lt; f$ soit $f &lt; e$</li>
</ul>

<p>On conclut en remarquant que la fonction $h’(n) = (n, 0, \dots , 0)$ est une injection de $\mathbb{N}$ dans $\mathbb{N}^p$. Il existe donc une injection de $\mathbb{N}$ dans $\mathbb{N}^p$ (la fonction $h’$) et une injection de $\mathbb{N}^p$ dans $\mathbb{N}$ (la fonction $h$) : il existe une bijection entre $\mathbb{N}^p$ et $\mathbb{N}$.</p>

<p>Toute fonction de $\mathbb{N}^p$ dans $\mathbb{N}$ peut alors s’écrire comme une fonction de $\mathbb{N}$ dans $\mathbb{N}$ ce qui nous permet de dire que :</p>

<blockquote class="note">
  <p>Un algorithme est une fonction de :</p>

\[f: \mathbb{N} \rightarrow \mathbb{N}\]

</blockquote>

<h3 id="fonction-un-binaire">pour la bonne bouche</h3>

<p>Vous allez rire, on peut encore aller plus loin. Pour l’instant, on sait qu’un algorithme est une fonction $f: \mathbb{N} \rightarrow \mathbb{N}$. Elle associe donc un entier à un autre. Cette fonction est alors équivalente à la fonction $f’$ ci-dessous :</p>

\[f'(n, m) = \left\{
    \begin{array}{ll}
        1 &amp; \mbox{si } f(n) = m\\
        0 &amp; \mbox{sinon.}
    \end{array}
\right.\]

<p>D’après ce qui précède, en utilisant une bijection entre $\mathbb{N} \times \mathbb{N}$ et $\mathbb{N}$, il existe alors une fonction $f’’: \mathbb{N} \rightarrow \{0, 1\}$ équivalente à $f’$ et donc à $f$.</p>

<p>En remarquant que tout entier peut s’écrire sous sa <a href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_binaire">notation binaire</a>, il existe une bijection entre $\mathbb{N}$ et l’ensemble des mots que l’on peut former avec $0$ et $1$. En notant cet ensemble $\{0, 1\}^\star$, on en conclut que :</p>

<blockquote class="note">
  <p>Un algorithme est une fonction de :</p>

\[f: \{0, 1\}^\star \rightarrow \{0, 1\}\]

</blockquote>

<h2 id="que-calcule-t-on-">que calcule-t-on ?</h2>

<p>On a démontré qu’un algorithme était une fonction de $\mathbb{N}$ dans $\mathbb{N}$ (ou, ce qui est identique, de $\{0, 1\}^\star$ dans $\{0, 1\}$). Mais c’est une fonction particulière puisque ce qu’elle procède selon un plan détaillé (des instructions) qu’elle exécute petit à petit (séquentiellement).</p>

<p>On ne donnera pas ici d’exemple concret de fonction non calculable on montre juste que contrairement à une idée répandue :</p>

<blockquote class="note">
  <p>Un algorithme ne peut pas <strong>tout</strong> calculer. En revanche, quelque soit le formalisme utilisé pour le calcul (le pseudo-code ou code) ils peuvent tous calculer <strong>la même chose</strong>.</p>
</blockquote>

<h3 id="on-ne-calcule-pas-tout">on ne calcule pas tout</h3>

<p>On va montrer qu’il existe des fonctions qui ne sont pas des algorithmes car il existe strictement plus de fonctions que d’algorithmes.</p>

<h4 id="nombre-algorithmes">nombre d’algorithmes</h4>

<p>Comme un algorithme peut-être décrit par son pseudo-code, qui est une chaîne de caractères (qu’on peut limiter aux mots Français si on a envie), il y a au plus autant d’algorithmes que de chaînes de caractères. Ça en fait un sacré paquet mais comme chaque chaîne de caractère est un entier (on l’a vu <a href="#fonction-plusieurs-entier">juste avant</a>) :</p>

<blockquote class="note">
  <p>Il ne peut y avoir plus d’algorithme que de nombres entiers.</p>
</blockquote>

<h4 id="nombre-de-fonctions">nombre de fonctions</h4>

<p>Soit $f: \mathbb{N} \rightarrow \mathbb{N}$. En associant pour chaque entier $n$ le couple $(n, f(n))$ on associe à chaque fonction de $\mathbb{N}$ dans $\mathbb{N}$ l’ensemble :</p>

\[I(f) = \{ (n, f(n)) \vert n \in \mathbb{N} \}\]

<p>Connaître $f$ ou $I(f)$ est équivalent et comme $I(f) \subseteq \mathbb{N} \times \mathbb{N}$ on en conclut :</p>

<blockquote class="note">
  <p>Il y a autant de fonctions $f: \mathbb{N} \rightarrow \mathbb{N}$ que de parties de $\mathbb{N} \times \mathbb{N}$</p>
</blockquote>

<p>Or pour tout ensemble $E$ il y a strictement plus d’éléments dans l’ensemble de ses parties (qu’on note $2^E$) que dans $E$ (c’est le <a href="https://fr.wikipedia.org/wiki/Th%C3%A9or%C3%A8me_de_Cantor">théorème de Cantor</a>). On en conclut qu’il y a strictement plus de fonctions que d’éléments dans $\mathbb{N} \times \mathbb{N}$. Or comme $\mathbb{N} \times \mathbb{N}$ et $\mathbb{N}$ sont en bijection (mais si, on l’a vu <a href="#fonction-un-entier">précédemment</a>) :</p>

<blockquote class="note">
  <p>Il y a strictement plus de fonctions $f: \mathbb{N} \rightarrow \mathbb{N}$ que de nombres entiers.</p>
</blockquote>

<p>La preuve du Théorème de Cantor repose sur le fait que pour toute fonction $f: E \rightarrow 2^E$, l’ensemble $D = \{x \in E \vert x \notin f(x)\}$ n’a pas d’antécédent pour $f$. En effet, s’il en avait un, disons $y$, on aurait $f(y) = D$ et alors :</p>

<ul>
  <li>$y \notin D$ car s’il y était alors $y \notin f(y)$ ce qui est incohérent avec le fait que $f(y) = D$</li>
  <li>$y \in D$ car s’il n’y était pas alors $y \in f(y)$ ce qui est incohérent avec le fait que $f(y) = D$</li>
</ul>

<p>Bref, $y$ n’existe pas. On en conclut qu’il existe des éléments de $2^E$ qui ne sont pas des images de $f$ : ce n’est pas une <a href="https://fr.wikipedia.org/wiki/Surjection">surjection</a>. Comme $f$ a été prise au hasard, ça signifie que pour toute fonction de $E$ dans $2^E$ il existera des éléments de $2^E$ qui ne seront pas atteints : il y a strictement plus d’élément dans $2^E$ que dans $E$.</p>

<h3 id="mais-lorsquon-calcule-on-calcule-la-même-chose">mais lorsqu’on calcule, on calcule la même chose</h3>

<p>Les règles qu’on s’est données pour écrire du pseudo-code vont être pratiques pour décrire un algorithme pour un humain. Le fait qu’une fois posées, les règles ne nécessitent pas d’intelligence pour être exécutées, les rendent même accessible à des étudiants !
Cependant les termes qu’on peut utiliser ne sont pas définis clairement, il y a de multiples façons d’interpréter les <a href="#regles-generales">4 règles générales</a>, ou de manipuler les <a href="#regles-pseudo-code">6 règles d’un pseudo-code</a>.</p>

<p>On peut déjà penser aux multiples langages de programmation, allant de <a href="https://fr.wikipedia.org/wiki/Assembleur">l’assembleur</a> compréhensible par les processeurs de nos ordinateurs au <a href="https://fr.wikipedia.org/wiki/Python_(langage)">python</a> que tout le monde connait, en passant par le <a href="https://fr.wikipedia.org/wiki/Haskell">haskell</a> ou encore le <a href="https://fr.wikipedia.org/wiki/C_(langage)">C</a>.</p>

<p>On trouve même des langages désignées pour être les plus simples possibles (appelés <a href="https://fr.wikipedia.org/wiki/Langage_de_programmation_exotique">turing tarpit</a>) tout en étant aussi expressif que le python. Le plus célèbre d’entre eux est le <a href="https://fr.wikipedia.org/wiki/Brainfuck">brainfuck</a>.</p>

<blockquote>
  <p><em>fun fact</em>, on peut utiliser aussi certains jeu comme langage de programmation comme <a href="https://www.factorio.com/">factorio</a> (l’algorithme de tri <a href="https://www.youtube.com/watch?v=ts5EKp9w4TU">quicksort</a>), ou encore <a href="https://www.minecraft.net/">minecraft</a> (<a href="https://www.youtube.com/watch?v=uGug-4xkw6M">une calculatrice</a>).</p>
</blockquote>

<p>Le représentant de toute ces variabilités est la <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/machine-turing.html">machine de Turing</a>. C’est un outil simple qui capture merveilleusement les <a href="#regles-generales">4 règles générales</a> dans le sens où c’est <strong>et</strong> un outil puissant de démonstration <strong>et</strong> un un moyen de créer des algorithmes. C’est pourquoi la <a href="#equi-algo-pseudo-code">question sur l’équivalence entre algorithme et pseudo-code</a> est souvent écrite de cette façon  :</p>

<blockquote class="note">
  <p>On est convaincu que tout ce qu’un humain, une machine, ou encore un système physique peut calculer (c’est à dire en suivant les 4 règles générales de l’algorithme) est exactement égal à ce qu’une machine de Turing peut calculer. C’est ce qu’on appelle <a href="https://plato.stanford.edu/entries/church-Turing/#ReasForAcceThes">la thèse de Church-Turing</a></p>
</blockquote>

<p>Pour répondre à notre question initiale, <em>que peut-on calculer ?</em>, on peut maintenant répondre : ce qu’une machine de Turing peut calculer (et ce n’est pas tout, mais c’est quand même pas mal de choses).</p>

<h2 id="algorithmes-et-démonstration-mathématiques">algorithmes et démonstration mathématiques</h2>

<p>On n’en parlera pas trop dans ce cours (à moins que vous me le demandiez très fort) mais, en gros, les mathématiques sont une partie de l’informatique.</p>

<p>De façon plus précise on a la suite d’équivalences :</p>

<ol>
  <li>faire une démonstration consiste — à partir d’une série finie d’axiomes — à effectuer une suite finie de déductions pour parvenir à un résultat. (<a href="https://fr.wikipedia.org/wiki/Aristote#Enqu%C3%AAte,_d%C3%A9monstration_et_syllogisme">Aristote</a>, en -350 environ)</li>
  <li>(1) est équivalent à démontrer à l’aide d’une suite finie de déductions qu’une proposition logique est vraie (<a href="https://fr.wikipedia.org/wiki/Syst%C3%A8me_%C3%A0_la_Hilbert">Hilbert</a>, début XXe siècle)</li>
  <li>(en passant, <a href="https://fr.wikipedia.org/wiki/Th%C3%A9or%C3%A8mes_d%27incompl%C3%A9tude_de_G%C3%B6del">Gödel</a>, en 1931, démontre qu’il existe des propositions logiques qui sont vraies mais qu’il est impossible de démontrer)</li>
  <li>
<a href="https://fr.wikipedia.org/wiki/Correspondance_de_Curry-Howard">Curry puis Howard qui généralise</a>, en 1950 et 1980, montrent que (2) est équivalent à écrire en terme de <a href="https://fr.wikipedia.org/wiki/Lambda-calcul">$\lambda$-calcul</a>
</li>
  <li>
<a href="https://fr.wikipedia.org/wiki/Alan_Turing">Turing</a> démontre en 1937, que (4) est équivalent à écrire une machine de Turing.</li>
  <li>(en passant, Turing démontre qu’il existe des machine de turing qui ne s’arrêtent jamais et que savoir si une machine de turing va s’arrêter est <a href="https://fr.wikipedia.org/wiki/Probl%C3%A8me_de_l%27arr%C3%AAt">indécidable</a>, ce qui est équivalent à (3))</li>
  <li>Turing, en 1936, démontre que (5) est équivalent à écrire un algorithme</li>
</ol>

<h2 id="conclusion">Conclusion</h2>

<p>On a montré ici 3 choses fondamentales :</p>

<ul>
  <li>un algorithme ne peut pas tout faire</li>
  <li>un algorithme est une démonstration</li>
  <li>quelque soit le langage utilisé on pourra résoudre les même problèmes</li>
</ul>

<p>Ceci signifie que l’on doit toujours utiliser le formalisme (ou langage) qui est le plus simple pour résoudre le problème qu’on s’est fixé :</p>

<ul>
  <li>d’algorithmie : on utilisera les mots du pseudo-code les plus adaptés, dans le respect des 4 règles fondamentales (chaque instruction doit être simple ou explicitée)</li>
  <li>de code : on utilisera le langage qui est plus adapté à notre problème car ils ont tous leurs spécificités. Il est donc impératif d’apprendre plus d’un langage et surtout d’apprendre à en changer quand on change de problème à résoudre.</li>
  <li>théorique : on utilisera <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/machine-turing.html">la machine de Turing</a>, modèle théorique simple qui permet d’appréhender tout ce qui est calculable.</li>
</ul>

<p>Enfin, faites attention aux réels ! Ils n’existent pas (en informatique). Vous ne manipulez que des approximations : il faut faire attention à la stabilité numérique de vos algorithme et ne <strong>jamais</strong> tester l’égalité entre deux réels mais <strong>toujours</strong> les comparer à epsilon prêt.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique à l'école centrale marseille.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
