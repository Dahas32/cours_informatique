<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Machine de Turing | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="Machine de Turing">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<meta property="og:description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<link rel="canonical" href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/machine-turing.html">
<meta property="og:url" content="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/machine-turing.html">
<meta property="og:site_name" content="cours d’informatique">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Machine de Turing">
<script type="application/ld+json">
{"description":"Support de cours/td d’informatique à l’école centrale marseille.","@type":"WebPage","url":"/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/machine-turing.html","headline":"Machine de Turing","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Machine de Turing</h1>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/">Théorie et pratiques algorithmique</a> / <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/">théorie</a> / <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/machine-turing.html">machine de Turing</a></p>

  <p>prérequis :</p>

  <ul>
    <li><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/calculabilite.html">calculabilité</a></li>
    <li><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/pseudo-code.html">algorithmie/pseudo-code</a></li>
  </ul>

</blockquote>

<p>La <a href="https://fr.wikipedia.org/wiki/Machine_de_Turing">machine de Turing</a> est une façon simple d’implémenter les <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/calcul.html#regles-generales">4 règles générales d’un algorithme</a>. Turing lui-même a montré que :</p>

<blockquote class="note">
  <p>La machine de Turing permet exactement de calculer tout ce qu’on peut faire avec un <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/algorithmie/pseudo-code.html#regles">pseudo-code</a>.</p>
</blockquote>

<p>De plus, toutes les tentatives de généralisation de son modèle se sont révélés infructueuses : on arrive pas à calculer plus de choses qu’avec la machine de Turing (c’est juste plus simple de le faire).</p>

<p>On peut même montrer qu’une machine de Turing est elle même équivalent à un ordinateur !</p>

<p>La force d’une machine de turing est qu’il n’y a rien (modèle très simple) et pourtant il y a tout (on peut tout calculer).</p>

<blockquote>
  <p>L’article où d’Allan Turing décrit cette machine est <a href="https://www.espace-turing.fr/IMG/pdf/turing_paper_1936.pdf">là</a></p>
</blockquote>

<h2 id="définition">définition</h2>

<p>Il existe plusieurs définitions équivalentes d’une machine de Turing. Nous allons utiliser une variation de <a href="https://fr.wikipedia.org/wiki/Machine_de_Turing#D%C3%A9finition_formelle">celle de wikipedia</a>, que l’on va pouvoir utiliser tout au long de ce cours :</p>

<p>Une <strong>machine de Turing</strong> est un 7-uplet $(Q, \Gamma, \Sigma, \delta, q_0, q_a, q_r)$ où :</p>

<ul>
  <li>$Q$ est un ensemble fini d’<strong>état</strong>
</li>
  <li>$\Gamma$ est un ensemble fini nommé <strong>alphabet de travail</strong>. Il contient un symbole spécial $\sharp$, dit <strong>blanc</strong>.</li>
  <li>$\Sigma$ est un ensemble fini nommé <strong>alphabet d’entré</strong>. C’est un sous ensemble de $\Gamma$ ne contenant pas $\sharp$</li>
  <li>$\delta : Q \times \Gamma \rightarrow Q \times \Gamma \times \{ \leftarrow, \rightarrow \}$ est la <strong>fonction de transition</strong>
</li>
  <li>$q_0 \in Q$ est l’<strong>état initial</strong> de la machine</li>
  <li>$q_a \in Q$ est l’<strong>état d’acceptation</strong> de la machine</li>
  <li>$q_r \in Q \backslash { q_0, q_a }$ est l’<strong>état de rejet</strong> de la machine</li>
</ul>

<blockquote>
  <p>On appelle cette machine <strong>déterministe</strong> car $\delta$ est une fonction.</p>
</blockquote>

<p>Pour fonctionner, la machine nécessite :</p>

<ul>
  <li>un <strong>ruban</strong> constitué de cases contiguës pouvant chacune contenir un élément de $\Gamma$</li>
  <li>un <strong>curseur</strong> qui est positionné sur une case du ruban</li>
</ul>

<p>Initialement toutes les cases du ruban contiennent le symbole $\sharp$.</p>

<p>Voici la représentation d’une machine à la fin de la $i$ème instruction. Son état est $q$ et son curseur est positionné sur la case d’indice $j$ :</p>

<p><img src="/cours_informatique/assets/cours/algorithmie/machine-turing.png" alt="machine" style="margin: auto;display: block;"></p>

<p>Par convention, on considérera que le ruban initial aura comme numéro d’instruction 0 et que l’indice de la case où est initialement le curseur sera d’indice 0.</p>

<blockquote class="note">
  <p>L’<strong>exécution</strong> d’une machine de Turing $(Q, \Gamma, \Sigma, \delta, q_0, q_a, q_r)$ se déroule comme suit :</p>

  <ol>
    <li>on place la tête de lecture sur une case du ruban</li>
    <li>on initialise si besoin le ruban avec une chaine de caractères (finie) contenant des caractères de $\Sigma$ et on place le curseur sur la première case de la chaine.</li>
    <li>si l’état de la machine est $q_a$ ou $q_r$, on stoppe le programme.</li>
    <li>on lit le caractère $a$ sous le curseur, l’état $q$ de la machine et on note $\delta(a, q) = (a’, q’, f)$</li>
    <li>on écrit $a’$ dans la case du ruban pointé par le curseur, on place la machine dans l’état $q’$ et on déplace le curseur vers la gauche si $f$ vaut $\leftarrow$ et vers la droite sinon ($f$ vaut $\rightarrow$)</li>
    <li>retour en 3.</li>
  </ol>

</blockquote>

<blockquote>
  <p>L’exécution d’une machine de Turing, n’est pas forcément finie. Elle ne s’arrête que si elle atteind l’état $q_a$ ou $q_r$, ce qui peut ne jamais arriver.</p>
</blockquote>

<p>Remarquez la minimalité du fonctionnement :</p>

<ul>
  <li>on ne peut déplacer la tête de lecture que d’une case vers la gauche ou vers la droite (il est impossilbe d’écrire ou l’on veut dans la mémoire comme on peut le faire avec un ordinateur classique)</li>
  <li>on ne peut écrire qu’une lettre à la fois (pas d’entier, de réel, rien que des lettres)</li>
  <li>pas de variables</li>
  <li>pas de boucle for ni de saut</li>
  <li>un unique test entre un état et une case du tableau</li>
  <li>…</li>
</ul>

<p>Et pourtant, elle capte toutes les possiblités d’un alorithme.</p>

<p>Essayez de supprimer une règle et plus rien ne marche et en ajouter ne sert à rien, comme on le verra dans la partie <a href="#substantifique-moelle">substantifique moelle</a></p>

<h2 id="machine-de-turing-algorithmes-et-fonctions">machine de turing, algorithmes et fonctions</h2>

<p>Une machine de Turing peut être vue comme un algorithme dont l’entrée et la sorite sont écrits sur le ruban. Pour préciser cela, il faut commencer par définir clairemnt les entrées et sorties.</p>

<blockquote class="note">
  <p>Un <strong>mot</strong> $\omega$ d’un ensemble fini $\Sigma$ est une suite fini $\omega = (\omega_1, \dots, \omega_n)$ d’éléments de $\Sigma$. La <strong>longueur</strong> d’un mot est la longueur de la suite (le mot de longueur 0 est la suite vide).
On appelle alors souvent $\Sigma$ l’<strong>alphabet</strong> et <strong>caractère</strong> un élément de la suite d’un mot.
On note $\Sigma^\star$ l’ensemble des mots de $\Sigma$ et $\Sigma^+$ l’ensemble des mots non vide (de longeur strictement positive)</p>
</blockquote>

<p>A chaque étape de l’exécution du programme d’une machine le ruban contient des caractères de $\Gamma$. On sait de plus que les bords du rubans sont constituées de $\sharp$.</p>

<blockquote class="note">
  <p>Une <strong>configuration</strong> d’une machine de Turing $M = (Q, \Gamma, \Sigma, \delta, q_0, q_a, q_r)$ est un triplet $(m_1, q, m_2)$ de $\Gamma^\star \times Q \times \Gamma^+$ tel que :</p>

  <ul>
    <li>l’état de la machine soit $q$</li>
    <li>le mot $m_1$ suivi directement du mot $m_2$ est sur le ruban</li>
    <li>le curseur est placé sur le premier caractère de $m_2$</li>
  </ul>

</blockquote>

<p>Par exemple, la figure suivante correspond par exemple aux configurations $(1011, b, 010)$, $(11, b, 0)$ ou encore $(1011, b, 010\sharp\sharp)$ :</p>

<p><img src="/cours_informatique/assets/cours/algorithmie/turing-configuration.png" alt="configuration" style="margin: auto;display: block;"></p>

<p>On peut maintenant préciser l’entrée et la sortie (si elle existe) de l’exécution d’une machine de Turing.</p>

<blockquote class="note">
  <p>L’<strong>entrée</strong> d’une exécution est un mot $m \in \Sigma^\star$ telle que la <strong>configuration initiale</strong> de l’exécution de la machine (l’étape 2 lors de l’exéctuion) soit $(\emptyset, q_0, m)$ avec des blancs à gauche et à droite de la configuration.</p>
</blockquote>

<p>Si l’exécution d’une machine s’arrête dans l’état $q_a$, on peut lire la <strong>sortie</strong> de la machine :</p>

<blockquote class="note">
  <p>La <strong>sortie</strong> de l’exécution d’une machine de Turing est la concaténation des mots $m_1$ et $m_2$ où la machine est dans la configuration  $(\sharp m_1, q_a, m_2\sharp)$ avec $m_1, m_2 \in \Sigma^*$.</p>
</blockquote>

<p>En reprenant la machine de la figure précédente et un considérant que $b$ est son état d’acceptation. La sortie de la machine serait : $1011010$.</p>

<blockquote>
  <p>Notez que la sortie de l’exécution d’une machine de Turing n’est définie que si la machine s’est arrêtée dans l’état d’acceptation et que dans ce cas là, elle est définie de façon unique (c’est les cases autour du curseur qui contiennent des caractères de l’alphabet d’entrée).</p>
</blockquote>

<p>Finissons par quelques définitions qui précisent des différents résultats de l’exécution d’une machine $M = (Q, \Gamma, \Sigma, \delta, q_0, q_a, q_r)$.</p>

<blockquote class="note">
  <p>Un mot $\mu$ de $\Sigma^\star$ est <strong>accepté</strong> par $M$ si l’exécution de $M$ pour l’entrée $\mu$ se termine sur l’état $q_a$, il est <strong>rejeté</strong> si l’exécution de $M$ pour l’entrée $\mu$ se termine sur l’état $q_r$. Dans les deux cas on dira que la machine s’<strong>arrête</strong> pour $\mu$, sinon on dira qu’elle <strong>boucle</strong>.</p>

  <p>Le <strong>langage</strong> de $M$ est l’ensemble des mots acceptés par elle et on le note $\mathcal{L}(M)$.</p>
</blockquote>

<h2 id="exemples-de-programmes">exemples de programmes</h2>

<h3 id="répéteur">répéteur</h3>

<p>Le premier exemple donné par Allan Turing est celui-ci :</p>

<ul>
  <li>$Q = \{ a, b, c, d \}$</li>
  <li>$\Gamma = \{ 0, 1, \sharp \}$ et $\Sigma = \{ 0, 1 \}$</li>
  <li>$q_0 = a$</li>
  <li>on aura pas besoin d’états finaux</li>
  <li>$\delta(a, \sharp) = (0, b, \rightarrow)$</li>
  <li>$\delta(b, \sharp) = (\sharp, c, \rightarrow)$</li>
  <li>$\delta(c, \sharp) = (1, d, \rightarrow)$</li>
  <li>$\delta(d, \sharp) = (\sharp, a, \rightarrow)$</li>
</ul>

<p>La fonction $\delta$ est ici partielle, avec la convention que si l’on arrive dans une configuration non décrite, on stoppe la machine dans un état de rejet (on peut donc étendre $\delta$ à tout $Q \times \Gamma$ si on le voulait).</p>

<p>Allons-y. Essayons ce code. On considère la machine de Turing ci-après, avec l’entrée vide :</p>

<p><img src="/cours_informatique/assets/cours/algorithmie/turing-1.png" alt="Turing 1" style="margin: auto;display: block;"></p>

<p>Par convention, on considérera que le ruban initial aura comme numéro d’instruction 0 et que l’indice de la case où est initialement le curseur sera d’indice 0.</p>

<p>On est à l’état $a$ et on lit $\sharp$ dans la machine : la table de transition nous indique qu’il faut :</p>

<ul>
  <li>écrire $0$</li>
  <li>passer dans l’état $b$</li>
  <li>aller à droite</li>
</ul>

<p><img src="/cours_informatique/assets/cours/algorithmie/turing-2.png" alt="Turing 2" style="margin: auto;display: block;"></p>

<p>On est à l’état $b$ et on lit $\sharp$ dans la machine : la table de transition nous indique qu’il faut :</p>

<ul>
  <li>écrire $\sharp$</li>
  <li>passer dans l’état $c$</li>
  <li>aller à droite</li>
</ul>

<p><img src="/cours_informatique/assets/cours/algorithmie/turing-3.png" alt="Turing 3" style="margin: auto;display: block;"></p>

<p>On est à l’état $c$ et on lit $\sharp$ dans la machine : la table de transition nous indique qu’il faut :</p>

<ul>
  <li>écrire $1$</li>
  <li>passer dans l’état $d$</li>
  <li>aller à droite</li>
</ul>

<p><img src="/cours_informatique/assets/cours/algorithmie/turing-4.png" alt="Turing 4" style="margin: auto;display: block;"></p>

<p>On est à l’état $d$ et on lit $\sharp$ dans la machine : la table de transition nous indique qu’il faut :</p>

<ul>
  <li>écrire $\sharp$</li>
  <li>passer dans l’état $a$</li>
  <li>aller à droite</li>
</ul>

<p><img src="/cours_informatique/assets/cours/algorithmie/turing-5.png" alt="Turing 5" style="margin: auto;display: block;"></p>

<p>Et ainsi de suite. On voit que cette machine ne va jamais s’arrêter et qu’elle écrit continuellement 0 puis 1 sur le ruban. Cette machine n’a pas d’entrée ni de sortie.</p>

<p>Si vous voulez le voir en action, allez sur <a href="https://Turingmachine.io/">https://Turingmachine.io/</a>. C’est le programme “repeat 0 1”.</p>

<blockquote>
  <p>Si vous avez trifouillé le code sur <a href="https://Turingmachine.io/">https://Turingmachine.io/</a> et que vous ne retouvez pas vos petits, recommencez en ouvrant une nouvelle fenêtre de naviguation privée pour supprimer les données conservées.</p>
</blockquote>

<p>Le site représente la machine sous la forme de son diagramme de transition. Les nœuds représentent l’état de la machine et sur l’arc est représenté la transition selon selon la lecture sur le ruban.</p>

<h3 id="exemple-doublement-batons">doublement des bâtons</h3>

<p>Autre exemple classique des machines de Turing, le doublement des bâtons. Elle s’écrit comme ça :</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>1</th>
      <th>$\sharp$</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>s</strong></td>
      <td>$(\sharp, l, \leftarrow)$</td>
      <td>$(\sharp, e, \leftarrow)$</td>
    </tr>
    <tr>
      <td>l</td>
      <td> </td>
      <td>$(1, g, \leftarrow)$</td>
    </tr>
    <tr>
      <td>g</td>
      <td>$(1, g, \leftarrow)$</td>
      <td>$(1, d, \rightarrow)$</td>
    </tr>
    <tr>
      <td>d</td>
      <td>$(1, d, \rightarrow)$</td>
      <td>$(\sharp, s, \rightarrow)$</td>
    </tr>
  </tbody>
</table>

<p>On a représenté la machine sous la forme d’un tableau où les état sont des lignes et chaque colonne est un élément de l’alphabet. L’état initial est la première ligne et les états finaux sont ceux qui n’ont pas de ligne, ici $e$ qui est notre état d’acceptation.</p>

<p>On initialise cette machine avec une chaine de 1 : $\Sigma = \{ 1 \}$ (et $\Gamma = \{ 1, \sharp \}$).</p>

<p>Suivont l’exécution de cette machine avec l’entrée <code class="language-plaintext highlighter-rouge">11</code> (la position du curseur est en orange) :</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center" rowspan="2">
<h1 id="instruction">instruction</h1>
<p><br></p>
</th>
      <th style="text-align: center" colspan="7">ruban</th>
      
      
      
      
      
      
    </tr>
    <tr>
      
      <th style="text-align: center">-3</th>
      <th style="text-align: center">-2</th>
      <th style="text-align: center">-1</th>
      <th style="text-align: center">0</th>
      <th style="text-align: center">1</th>
      <th style="text-align: center">2</th>
      <th style="text-align: center">^^</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">0</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center;background: orange" class="cls">
<strong>1</strong> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">s</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center;background: orange" class="cls">
<strong>#</strong> </td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">l</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center;background: orange" class="cls">
<strong>#</strong> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">g</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center;background: orange" class="cls">
<strong>1</strong> </td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">d</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center;background: orange" class="cls">
<strong>#</strong> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">d</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center;background: orange" class="cls">
<strong>1</strong> </td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">s</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center;background: orange" class="cls">
<strong>#</strong> </td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">l</td>
    </tr>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center;background: orange" class="cls">
<strong>1</strong> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">g</td>
    </tr>
    <tr>
      <td style="text-align: center">8</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center;background: orange" class="cls">
<strong>1</strong> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">g</td>
    </tr>
    <tr>
      <td style="text-align: center">9</td>
      <td style="text-align: center;background: orange" class="cls">
<strong>#</strong> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">g</td>
    </tr>
    <tr>
      <td style="text-align: center">10</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center;background: orange" class="cls">
<strong>1</strong> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">d</td>
    </tr>
    <tr>
      <td style="text-align: center">11</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center;background: orange" class="cls">
<strong>1</strong> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">d</td>
    </tr>
    <tr>
      <td style="text-align: center">12</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center;background: orange" class="cls">
<strong>1</strong> </td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">d</td>
    </tr>
    <tr>
      <td style="text-align: center">13</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center;background: orange" class="cls">
<strong>#</strong> </td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">d</td>
    </tr>
    <tr>
      <td style="text-align: center">14</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">#</td>
      <td style="text-align: center;background: orange" class="cls">
<strong>#</strong> </td>
      <td style="text-align: center">s</td>
    </tr>
    <tr>
      <td style="text-align: center">15</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center;background: orange" class="cls">
<strong>#</strong> </td>
      <td style="text-align: center">#</td>
      <td style="text-align: center">e</td>
    </tr>
  </tbody>
</table>

<p>La machine s’arrête ! Avant de voir exactement pourquoi cette machine s’arrête, essayer de comprendre son fonctionnement.</p>

<blockquote class="a-faire">
  <p>Testez la machine avec <a href="https://Turingmachine.io/">https://Turingmachine.io/</a> en utilsant le code ci-dessous, traduction de la machine, avec une entrée de <code class="language-plaintext highlighter-rouge">1111</code> :</p>
</blockquote>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>input: '1111'
blank: '#'
start state: start
table:
  start:
    1: {write: '#', L: lien}
    '#': {L: done}
  lien:
    '#': {write: 1, L: gauche}
  gauche:
    1: {write: 1, L: gauche}
    '#': {write: 1, R: droite}
  droite:
    1: {write: 1, R: droite}
    '#': {write: '#', R: start}
  done:
</code></pre></div></div>

<p>Son fonctionnement est le suivant :</p>

<ol>
  <li>on remarque qu’au départ on est placé sur un <code class="language-plaintext highlighter-rouge">1</code>
</li>
  <li>de là, on va effectuer deux instructions à la suite (l’état $l$ ne sert qu’à ça) :
    <ol>
      <li>on remplace le premier 1 par un $\sharp$ et on se déplace à gauche</li>
      <li>on écrit 1, puis on se déplace encore une fois à gauche</li>
    </ol>
  </li>
  <li>Une fois là, on se déplace autant de fois que nécessaire sur la gauche jusqu’à arriver sur une case avec $\sharp$ (au début, on a pas besoin de bouger).</li>
  <li>Arrivé là on écrit 1, puis on se déplace autant de fois que nécessaire sur la droite jusqu’à arriver sur une case $\sharp$.</li>
  <li>Arrivé là, on se déplace à droite et on replace la machine de Turing à son été initial pour recommencer en 1. si on est placé sur un 1.</li>
</ol>

<p>A chaque itération, la machine supprime un 1 et en écrit 2 nouveaux : un à droite et un à gauche des nouveaux 1 inscrits. Les étapes de cette itération poeut être décrite comme suit :</p>

<p><img src="/cours_informatique/assets/cours/algorithmie/turing-6.png" alt="Turing 6" style="margin: auto;display: block;"></p>

<p>On aura toujours une configuration où les nouveaux 1 seront à gauche des anciens 1 (ceux initialement sur le ruban) et séparé par <strong>un unique caractère blanc</strong> :</p>

<p><img src="/cours_informatique/assets/cours/algorithmie/turing-7.png" alt="doublement de batons" style="margin: auto;display: block;"></p>

<p>Le programme de la machine de Turing a machine va donc ici s’arrêter puisqu’à un moment tous les anciens $1$ auront-été effacés et on se retrouvera à l’état initial avec le curseur placé sur un $\sharp$ , ce qui enverra vers l’état final.</p>

<p>On remarque que la configuration de sortie est $(1111,e, \emptyset)$. : la sortie de l’exécution de la machine avec en entrée $11$ est $1111$.</p>

<p><strong>Félicitations</strong> ! Vous venez d’implémenter la fonction $f(n) = 2n$ dans une machine de Turing.</p>

<p>Remarquez que par construction de la machine de Turing, le nombre d’opérations nécessaires pour exécuter le programme correspond aussi au nombre maximum de cases différentes du ruban qui ont put être parcourues :</p>

<blockquote class="note">
  <p>Le nombre de cases du ruban parcouru par une machine de Turing est plus petit ou égal aux nombres d’instructions effectuées.</p>
</blockquote>

<h3 id="autres-programmes">autres programmes</h3>

<p>Le site <a href="https://Turingmachine.io/">https://Turingmachine.io/</a> contient bien d’autres programmes à essayer. Vous pouvez aussi aller du côté de <a href="https://machinedeTuring.com/">https://machinedeTuring.com/</a> pour aller voir le programme donné par Turing pour <a href="https://machinedeTuring.com/exemple.php?page=9">générer tous les entiers</a>.</p>

<p>Notez qu’il est facile de composer des machines de Turing ensemble en <em>concaténant</em> les paramètres (alphabets, fonction de compositions, états). On peut ainsi créer des gros programmes en assemblant des machines de Turing toutes simples. On peut ainsi plus ou moins facilement créer des machines de Turing qui :</p>

<ul>
  <li>déplacent un caractère sur le ruban vers la gauche ou la droite</li>
  <li>mettent des bornes à gauche et à droite du rubans pour délimiter l’intervalle des cases modifiées par le programme à tout moment de son exécution</li>
  <li>cherchent une case contenant un caractère en particulier</li>
  <li>…</li>
</ul>

<h2 id="substantifique-moelle">substantifique moelle de la machine de Turing</h2>

<p>Le modèle de la machine de Turing admet quatre paramètres :</p>

<ul>
  <li>un ruban</li>
  <li>un curseur</li>
  <li>l’alphabet</li>
  <li>une fonction de transitions</li>
</ul>

<p>On peut se demander ce qui est vraiment utile là-dedans (peut-on simplifier le modèle sans perdre en expressivité ?) ou au contraire si complexifier le modèle permet de calculer plus de chose.</p>

<h3 id="généralisation-du-modèle--inutile">généralisation du modèle : inutile</h3>

<p>Commençons par répondre à la seconde question : <em>est-ce que complexifier le modèle permet de calculer plus de chose ?</em> La réponse est <strong>non</strong>.</p>

<p>Il existent de nombreuses généralisations des machines de Turing, elles ne permettent pas de calculer plus de choses, mais sont utiles car elle permettent de calculer plus facilement/rapidement. Ces généralisations nous permettent d’écrire rapidement des programmes en sachant qu’on pourrait (si on en avait très envie) les écrire avec une machine de Turing normale.</p>

<h4 id="machines-à-plusieurs-rubans">machines à plusieurs rubans</h4>

<p>Une machine de Turing à $k$ rubans peut être définie comme suit.</p>

<p>Une <strong>machine de Turing à $k$ rubans</strong> est un 7-uplet $(Q, \Gamma, \Sigma, \delta_k, q_0, q_a, q_r)$ où :</p>

<ul>
  <li>tout est idendique à la machine de turing classique sauf $\delta_k$</li>
  <li>$\delta_k : Q \times \Gamma^k \rightarrow Q \times \Gamma^k \times \{ \leftarrow, \rightarrow \}^k$ est la <strong>fonction de transition</strong>
</li>
</ul>

<p>Pour fonctionner, la machine nécessite :</p>

<ul>
  <li>$k$ <strong>rubans</strong> constitués de cases contiguës pouvant chacune contenir un élément de $\Gamma$</li>
  <li>$k$ <strong>curseurs</strong>, un pour chaque ruban</li>
</ul>

<p>Tout se passe comme pour la machine de Turing mais on lit la valeur des $k$ rubans, puis la fonction de transition écrit une valeur sur chaque ruban et déplace les curseurs de chaque ruban.</p>

<blockquote class="note">
  <p>On peut toujours transformer une machine à plusieurs rubans en une machine de Turing normale équivalente.</p>
</blockquote>

<p>Nous n’allons pas donner la preuve complète de ceci, mais juste une idée de la preuve de comment simuler une machine à 2 rubans avec une machine avec un seul ruban.</p>

<p>Lorsque l’on a une machine à 2 rubans, on a un curseur pour chaque ruban. A chaque instruction on lit le contenu de chaque ruban sous le curseur et selon l’état de la machine on écrit sur les 2 rubans puis on déplace chaque curseur vers la gauche ou la droite. On peut alors simuler les 2 rubans en un seul ruban en ajoutant une lettre $\bigtriangledown$ à l’alphabet et en découpant le ruban en paquets de 4 cases :</p>

<ul>
  <li>la première case valant soit $\bigtriangledown$ si le curseur du premier ruban est sur cette case, soit $\sharp$ sinon,</li>
  <li>la deuxième case valant le caractère de la case sur le premier ruban</li>
  <li>la troisième case valant soit $\bigtriangledown$ si le curseur du second ruban est sur cette case, soit $\sharp$ sinon,</li>
  <li>la deuxième case valant le caractère de la case sur le second ruban</li>
</ul>

<p>Enfin, on peut toujours s’arranger pour qu’au départ, le curseur du premier ruban et du second ruban soient sur le même paquet de 4 cases.</p>

<p>De là, à chaque itération de la machine à 1 seul ruban, on commence par chercher les paquets de 4 cases contenant les curseurs de chaque ruban et on lit leurs valeurs (on peut faire ça en parcourant le ruban jusqu’à trouver $\bigtriangledown$ en premier ou en troisième position d’un paquet à 4 cases) puis on effectue la fonction de transition de la machine à 2 rubans et on écrit les nouvelles valeurs en recherchant les positions respectives des curseurs dans les paquets à 4 cases.</p>

<h4 id="machines-à-plusieurs-curseurs">machines à plusieurs curseurs</h4>

<p>Plutôt que de multiplier les rubans, on peut aussi multiplier les curseurs :</p>

<p>Une <strong>machine de Turing à $k$ curseurs</strong> est un 7-uplet $(Q, \Gamma, \Sigma, \delta_k, q_0, q_a, q_r)$ où :</p>

<ul>
  <li>tout est idendique à la machine de turing classique sauf $\delta_k$</li>
  <li>$\delta_k : Q \times \Gamma^k \rightarrow Q \times \Gamma^k \times \{ \leftarrow, \rightarrow \}^k$ est la <strong>fonction de transition</strong>
</li>
</ul>

<p>Pour fonctionner, la machine nécessite :</p>

<ul>
  <li>un <strong>ruban</strong> constitués de cases contiguës pouvant chacune contenir un élément de $\Gamma$</li>
  <li>$k$ <strong>curseurs</strong>, sur le ruban</li>
</ul>

<p>Elle fonctionne de la même manière que la machine à $k$ rubans sauf qu’on lit les valeurs sur le même ruban.</p>

<blockquote class="note">
  <p>On peut toujours transformer une machine à plusieurs curseurs en une machine de Turing normale équivalente.</p>
</blockquote>

<p>La preuve est identique à celle pour simuler une machine à $k$ rubans sur une machine à 1 ruban.</p>

<h4 id="machines-à-plusieurs-curseurs-et-rubans">machines à plusieurs curseurs et rubans</h4>

<p>On peut bien sur combiner les deux approches et construire une machine de Turing à $k$ rubans et $k’$ curseurs réparis sur les rubans. Mais, comme vous devez vous en douter :</p>

<blockquote class="note">
  <p>On peut toujours transformer une machine à plusieurs rubans et plusieurs curseurs en une machine de Turing normale équivalente.</p>
</blockquote>

<h4 id="machines-de-turing-non-déterministe">machines de Turing non déterministe</h4>

<p>Il existe aussi, <a href="https://fr.wikipedia.org/wiki/Machine_de_Turing_non_d%C3%A9terministe">la machine de Turing non déterministe</a>, qui se définit comme suit :</p>

<p>Une <strong>machine de Turing non déterministe</strong> est un 7-uplet $(Q, \Gamma, \Sigma, \delta, q_0, q_a, q_r)$ où :</p>

<ul>
  <li>tout est idendique à la machine de turing classique sauf $\delta$</li>
  <li>$\delta : Q \times \Gamma \rightarrow 2^{Q \times \Gamma \times \{ \leftarrow, \rightarrow \}}$ est la <strong>fonction de transition</strong>
</li>
</ul>

<p>Cette machine se distingue de la machine de Turing normale parce que la fonction de transition rend un sous ensemble fini de $Q \times \Gamma \times \{ \leftarrow, \rightarrow \}$ et non juste un élément de $Q \times \Gamma \times \{ \leftarrow, \rightarrow \}$. Cette machine donne un ensemble de transitions possible pour chaque transition.</p>

<p>Ce qui nous intéresse ici ce n’est plus le calcul effectif mais <strong>s’il existe pour une entrée donnée une suite de transitions emmenant à un état final</strong>. C’est à dire qu’il existe une suite de nombres $(t_1, \dots, t_k)$ telle que à chaque instruction $i$  on ait pu choisir le $t_i$ème choix pour que la $k$ instruction mêne à un état final.</p>

<p>En représentant les choix sous la forme d’un arbre, on peut représenter $\delta$ comme ça :</p>

<p><img src="/cours_informatique/assets/cours/algorithmie/Turing-nd-arbre.png" alt="Turing non déterministe arbre" style="margin: auto;display: block;"></p>

<p>Une exécution de la machine revient à suivre un chemin dans cet arbre, donc qu’à partir de l’état initial $e$ et du caractère $a$ sous le curseur, on a :</p>

<ul>
  <li>$(e_{t_1}, a_{t_1}, f_{t_1}) \in \delta(e, a)$</li>
  <li>$(e_{t_1\dots t_i}, a_{t_1\dots t_i}, f_{t_1\dots t_i}) \in \delta(e_{t_1t_2\dots t_{i-1}}, a_{t_1t_2\dots t_1i-1})$</li>
</ul>

<p>C’est un outil théorique très puissant car il permet de démontrer simplement beaucoup de théorèmes d’informatique théorique. Cependant, <strong>elle ne permet pas de faire plus de chose qu’une machine normale</strong> :</p>

<blockquote class="note">
  <p>Pour toute machine de Turing non déterministe, on peut créer une machine de Turing <em>normale</em> qui s’arrêtera sur les même entrées.</p>
</blockquote>

<p>Idée de la preuve. En utilisant la représentation arborée, en regardant chaque possibilité <em>couche par couche</em> (on appelle ça faire un <a href="https://fr.wikipedia.org/wiki/Algorithme_de_parcours_en_largeur">parcours en largeur</a>), on construit une machine de Turing <em>simple</em> qui s’arrête bien si et seulement si la machine de Turing non déterministe s’arrête.</p>

<h4 id="autres-variantes">autres variantes</h4>

<p>par exemple des machines utilisant <a href="https://perso.liris.cnrs.fr/sylvain.brandel/wiki/lib/exe/fetch.php?media=ens:m1if09:m1if09-cm03.pdf">plusieurs rubans et/ou plusieurs curseurs</a>. L’intérêt de ces machines est qu’elle sont plus facilement programmables.</p>

<h3 id="simplification-de-lalphabet">simplification de l’alphabet</h3>

<p>Diminuer ou agrandir l’alphabet d’une machine de Turing ne permet pas de calculer plus de choses non plus. On peut se restreindre à un alphabet à 2 lettres :</p>

<blockquote class="note">
  <p>On peut simuler toute machine de Turing par une machine de Turing sur un alphabet $\{\sharp, 0, 1\}$, avec $\{0, 1\}$ comme alphabet d’entrée.</p>
</blockquote>

<p>Idée de la preuve. Comme l’alphabet $\Gamma$ d’une machine de Turing est fini, on peut associer à chaque lettre non blanc un numéro allant de $1$ à $\vert \Gamma \vert$, puis coder celui-ci par le mot $0 \cdots 0 1 \cdots 1$ de longueur $\vert \Gamma \vert$ et ayant autant de $1$ que la valeur de son numéro.</p>

<p>On termine par coder le caractère blanc par une suite de $\Gamma$ caractères $\sharp$. Une fois cette traduction d’alphabet effectué, on modifie les transitions pour qu’elles se déplacent de $\vert \Gamma \vert$ cases à chaque fois en utilisant des états transitoires (comme l’état $l$ dans l’exemple du <a href="#exemple-doublement-batons">doublement des batons</a>).</p>

<p>On montre par là que :</p>

<blockquote class="note">
  <p>Une machine de Turing $M$ calcule un fonction  $f: A \rightarrow \{0, 1\}$ où $A$ est l’ensemble des mots de $\{0, 1\}$ qui sont soit acceptés (et dans ce cas là $f(m) = 1$) soit rejetés (et $f(m) = 0$) par $M$.</p>
</blockquote>

<p>Si l’on considère des machines de Turing sans alphabet d’entrée (c’est à dire que l’alphabet de travail est aussi l’alphabet d’entrée, on peut simuler toute machine de Turing sur uniquemnt $\{\sharp, 1\}$ (on remplace les $0$ par des $\sharp$ dans l’encodage).</p>

<h2 id="machine-de-turing-universelle">machine de Turing universelle</h2>

<p>Ce qui différentie une machine de Turing d’une autre c’est l’alphabet et la fonction de transition. On a vu qu’on pouvait utiliser un alphabet commun ($\{ \sharp, 0, 1\}$), les différences entre machines sont donc uniquement dues à la fonction de transition.</p>

<p>Un des résultat les plus surprenant de Turing est qu’en fait on ne peut construire qu’<strong>une seule machine</strong> qui simulera toutes les autres. Cette machine est appelée <a href="https://fr.wikipedia.org/wiki/Machine_de_Turing_universelle">Machine de Turing universelle</a> et possède deux paramètres, le premier, $M$ représentant le programme d’une machine de Turing et le second $E$ une entrée.</p>

<blockquote class="note">
  <p>Il existe une machine de Turing $U$ à 2 rubans sur l’alphabet d’entrée $\{ 0, 1\}$ (et $\{\sharp, 0, 1\}$ comme alphabet de traval) telle que pour une machine de Turing $M$ et une entrée $E$ donnée, $U(M, E)$ calculera ce que calcule $M$ pour l’entrée $E$ :</p>

  <ul>
    <li>elle ne s’arrête pas si l’exécution de $M$ avec $E$ comme entrée ne s’arrête pas,</li>
    <li>elle rejette $E$ si $M$ la rejette,</li>
    <li>elle accepte $E$ si $M$ ‘accepte et sa sortie est celle de $M$ pour l’entrée $E$.</li>
  </ul>

</blockquote>

<p>Nous ne démontrerons pas ce résultat que l’on doit à Turing lui-même, contentons nous de voir comment on peut encoder une Machine de Turing $M$ sur l’alphabet $\{ 0, 1\}$ pour en faire un paramètre d’entrée possible d’une machine de Turing.</p>

<p>Il y a bien des façons de faire. Nous prendrons ici celle utilisée dans la partie 3.3.4 de <a href="http://pageperso.lif.univ-mrs.fr/~kevin.perrot/documents/2016/calculabilite/Cours_16.pdf">ce document</a>. L’idée est de pouvoir :</p>

<ul>
  <li>encoder chaque transition</li>
  <li>avoir des séparateurs nous permettant de délimiter chaque transition</li>
</ul>

<p>Soit $M$ une machine de Turing à $n$ états (de $q_0$ à $q_{n-1}$) et $m$ caractères (de $c_1$ à $c_m$). Une transition est alors $\delta(q_i, c_j) = (q_k, c_l, D)$  où $D$ est soit $\leftarrow$ soit $\rightarrow$.</p>

<p>On code :</p>

<ul>
  <li>$q_i$ par $\underbrace{0 \cdots 0}_{i}{}$</li>
  <li>$c_j$ par $\underbrace{0 \cdots 0}_{j}{}$,</li>
  <li>$\leftarrow$ par $0$,</li>
  <li>$\leftarrow$ par $00$</li>
  <li>le séparateur par $1$</li>
</ul>

<p>La transition $\delta(q_i, c_j) = (q_k, c_l, \leftarrow)$ est alors :
\({
\underbrace{0 \cdots 0}_{i}{1} \underbrace{0 \cdots 0}_{j}{1} \underbrace{0 \cdots 0}_{k}{1} \underbrace{0 \cdots 0}_{l}{1} \underbrace{0}_{\leftarrow}
}\)</p>

<p>On sépare ensuite toutes les transitions par $11$ :
\(cdots11\mbox{transition}11\cdots\)</p>

<p>Il nous reste à renseigner le nombre d’états et de caractères en début de code et de donner un début et une fin à ce code ($111$) pour finaliser notre encodage $\langle M \rangle$ de la machine de Turing $M$ :</p>

\[\langle M \rangle = 111\underbrace{0 \cdots 0}_{n}11\underbrace{0 \cdots 0}_{m}11\mbox{transition}_111\cdots11 \mbox{transition}_i11\cdots11\mbox{transition}_N111\]

<p><strong>Félicitations !</strong> : vous venez de créer votre 1er ordinateur !</p>

<blockquote class="note">
  <p>La machine de Turing universelle $U$ permet d’exécuter n’importe quelle machine $M$ : c’est un ordinateur dont le langage machine est l’encodage $\langle M \rangle$.</p>
</blockquote>

<p>C’est un résultat extrêmement puissant. On a besoin que d’une machine de Turing pour exécuter toutes les machines de Turing.</p>

<p>Attention cependant, On a l’impression qu’on a besoin de rien, que toutes les machines de Turing sont en faite une seule. Ce n’est pas exactement le cas car l’encodage cache la machine. C’est un petit peu comme dans la blague ci-dessous. Un numéro n’est drôle que parce qu’il code une blague !</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Une famille qui connaît toutes les blagues de la planète 
les a classées et numérotées. Ainsi, le seul numéro suffit 
à les faire rire.

Lors d' un repas le père s'exclame : "12" !
Tout le monde pouffe de rire.
La mère dit : "32" !
Et ils éclatent de rire.
Le petit sort alors : "104" !
Et personne ne rit.
Son frère lui dit alors : " Tu la racontes mal !"
</code></pre></div></div>

<blockquote>
  <p>Grâce à la machine de Turing universelle, démontrer qu’un langage est <a href="https://fr.wikipedia.org/wiki/Turing-complet">Turing complet</a> c’est à dire qu’il permet de calculer tout ce qu’une machine de Turing peut calculer revient à montrer qu’on peut simuler une machine de Turing. C’est comme ça par exemple qu’on a démontrer que la <a href="https://en.wikipedia.org/wiki/Rule_110">règle 110</a> est un ordinateur.</p>
</blockquote>

<h2 id="conclusion">conclusion</h2>

<ul>
  <li>une machine de Turing est un outil théorique permettant de calculer exactement ce que peut calculer un ordinateur (ce n’est ni moins ni plus puissant).
    <ul>
      <li>toutes les généralisations des machines de Turing ne permettent pas de calculer plus de chose que la machine toute simple.</li>
      <li>on peut se restreindre à une machine à une entrée sur un alphabet à 2 lettres sans perte de généralité</li>
    </ul>
  </li>
  <li>on peut encoder une machine de Turing $M$ sous la forme d’un mot de $\{0, 1 \}$ noté $\langle M \rangle$</li>
  <li>il existe une machine de Turing universelle $U$ qui permet de simuler toutes les machine de Turing existantes : $U(M, E)$ sera égal à $M(E)$</li>
</ul>

<p>Enfin :</p>

<blockquote>
  <p>la simplicité de son fonctionnement et la puissance de ce qu’elle calcule convainc (les informaticiens de tous les pays) que tout ce qu’un humain, une machine, ou encore un système physique peut calculer (c’est à dire en suivant des opérations que l’on peut décrire en un nombre fini d’opérations) est exactement égal à ce qu’une machine de Turing peut calculer. C’est ce qu’on appelle <a href="https://plato.stanford.edu/entries/church-Turing/#ReasForAcceThes">la thèse de Church-Turing</a>.</p>
</blockquote>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique à l'école centrale marseille.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
