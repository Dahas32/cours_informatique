<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Décidabilité et calculabilité | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="Décidabilité et calculabilité">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<meta property="og:description" content="Support de cours/td d’informatique à l’école centrale marseille.">
<link rel="canonical" href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/decidabilite_calculabilite.html">
<meta property="og:url" content="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/decidabilite_calculabilite.html">
<meta property="og:site_name" content="cours d’informatique">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Décidabilité et calculabilité">
<script type="application/ld+json">
{"description":"Support de cours/td d’informatique à l’école centrale marseille.","@type":"WebPage","url":"/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/decidabilite_calculabilite.html","headline":"Décidabilité et calculabilité","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Décidabilité et calculabilité</h1>
  </header>

  <div class="post-content">
    <blockquote class="chemin">
  <p><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/">Théorie et pratiques algorithmique</a> / <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/">théorie</a> / <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/decidabilite_calculabilite.html">décidabilité et calculabilité</a></p>

  <p>prérequis :</p>

  <ul>
    <li><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/algorithmes-fonctions-pseudo-code.html">Algorithmes, fonctions et pseudo-code</a></li>
    <li><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/machine-turing.html">machine de Turing</a></li>
  </ul>
</blockquote>

<p>On a vu dans la partie <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/fonctions.html">fonctions</a> qu’un algorithme ne pouvait pas tout calculer, qu’il y a avait même bien plus de choses qu’on ne pouvait pas faire avec un algorithme que de chose qu’on pouvait faire avec.</p>

<p>Nous allons ici, enfin, exhiber de tels exemples. On va étudier le problème sous deux angles :</p>

<ol>
  <li>savoir si un problème peut être résolu par un algorithme : c’est la <em>décidabilité</em>
</li>
  <li>savoir si une fonction/nombre peut être calculée par un algorithme : c’est la <em>calculabilité</em>
</li>
</ol>

<p>Aucun de ces deux problèmes n’est simple.</p>

<blockquote class="attention">
  <p>on utilisera indifféremment des pseudo-codes, code ou machine de Turing pour décrire nos algorithmes, puisque ces trois notions sont équivalentes.</p>
</blockquote>

<p>Ce qui faut retenir de cette partie :</p>

<ul>
  <li>un décideur est un algorithme spécifique à un problème de décision donné. Il répond oui si l’entrée admet une réponse au problème et non sinon</li>
  <li>savoir si un algorithme va s’arrêter est un problème indécidable</li>
  <li>il existe des fonctions ou des nombres qu’on ne peut pas calculer avec un algorithme (même beaucoup) mais ceux qu’on utilise couramment le sont</li>
</ul>

<h2 id="décidabilité">décidabilité</h2>

<p>Commençons par définir un <em>problème de décision</em> :</p>

<blockquote class="note">
  <p>Un <strong>problème de décision</strong>, est une question qui ne peut avoir que deux réponses <em>vrai</em> ou <em>fausse</em> selon l’entrée donnée.</p>
</blockquote>

<p>Par exemple le problème suivant :</p>

<ul>
  <li>
<strong>nom</strong> : premier</li>
  <li>
<strong>entrée</strong> : un nombre $n$</li>
  <li>
<strong>question</strong> : $n$ est-il un nombre premier ?</li>
</ul>

<p>Un problème de décision est <strong>décidable</strong>,  si on peut lui associer un algorithme (on dit un <em>décideur</em>) qui répond comme lui :</p>

<blockquote class="note">
  <p>Un <strong>décideur</strong> est un algorithme qui pour toute entrée, répond <em>Vraie</em> ou <em>faux</em></p>
</blockquote>

<p>Le problème de décision <em>premier</em> admet un décideur (il suffit de tester tous les entiers plus petit que $n$ pour voir si le reste de la division entière vaut 0), mais ce n’est pas de tous les les problèmes.</p>

<p>Par exemple le problème suivant n’admet pas de décideur (<a href="#arret">on va le démontrer</a>), ce problème est indécidable :</p>

<ul>
  <li>
<strong>nom</strong> : arrêt</li>
  <li>
<strong>entrées</strong> : un algorithme, et une entrée $E$</li>
  <li>
<strong>question</strong> : L’algorithme s’arrête-t-il avec $E$ comme entrée ?</li>
</ul>

<p>La décidabilité est donc le fait de savoir si on peut reconnaitre l’ensemble $L$ des entrées qui satisfont une propriété donnée :</p>

<blockquote class="note">
  <p>Un ensemble de mots $L$ est décidable s’il existe un <strong>décideur</strong> qui répond <em>vrai</em> si l’entrée est dans $L$ et <em>faux</em> sinon.</p>
</blockquote>

<p>Il existe un cas plus faible que la décidabilité, c’est la <em>reconnaissabilité</em> :</p>

<blockquote class="note">
  <p>Un ensemble de mots $L$ est <strong>reconnaissable</strong> s’il existe un algorithme $M$ telle que $L = \mathcal{L}(M)$ (l’algorithme ne va s’arrêter que pour les entrées de $L$)</p>
</blockquote>

<p>Notez que tout problème décidable est reconnaissable (à la place de répondre <em>Faux</em> on boucle indéfiniment), mais ce n’est pas le cas de tous les problèmes (<a href="#poli-z">ce problème</a> par exemple).</p>

<h3 id="poli-z">exemple des polynômes à coefficients dans $\mathbb{Z}$</h3>

<p>Soit le problème de décision suivant : Soit $P(X)$ un <a href="https://fr.wikipedia.org/wiki/Polyn%C3%B4me">polynôme</a> à coefficients dans $\mathbb{Z}$. Possède-t-il une <a href="https://fr.wikipedia.org/wiki/Racine_d%27un_polyn%C3%B4me">racine</a> dans $\mathbb{N}$ (un entier $a$ tel que $P(a) = 0$) ?</p>

<details><summary>ce problème est reconnaissable</summary><div>
<p>On peut facilement créer un algorithme qui, à partir d’un polynôme $P(x)$ à coefficients dans $\mathbb{Z}$ et d’un entier $a$ calcule $P(a)$.</p>

<p>Il suffit ensuite d’essayer tous les entiers un à un. Si le polynôme en entrée admet une racine entière, on va bien tomber dessus à un moment donné.</p>

</div></details>

<details><summary>il est même décidable</summary><div>
<p>On peut borner les racines d’un polynôme. Voir par exemple <a href="https://fr.wikipedia.org/wiki/Racine_d%27un_polyn%C3%B4me_r%C3%A9el_ou_complexe#Une_premi%C3%A8re_estimation">le corollaire de ce lien</a>. On aura donc pour chaque polynôme qu’un nombre fini de possibilités à examiner avant de donner la réponse.</p>

</div></details>

<p>Il existe bien sûr des langages qui sont reconnaissables et non décidables, par exemple une généralisation du problème précédent :</p>

<blockquote class="note">
  <p>Savoir si un <a href="https://fr.wikipedia.org/wiki/Polyn%C3%B4me_en_plusieurs_ind%C3%A9termin%C3%A9es">polynôme à plusieurs variables</a> à coefficients dans $\mathbb{Z}$ admet une racine dans $\mathbb{N}$ est un problème <strong>reconnaissable</strong> mais <strong>indécidable</strong>.</p>
</blockquote>

<p><strong>Félicitations !</strong> Vous venez de rencontrer votre premier problème que ne pourra pas résoudre un ordinateur.</p>

<blockquote>
  <p>Ce cas est historiquement important car il correspond au <a href="https://fr.wikipedia.org/wiki/Dixi%C3%A8me_probl%C3%A8me_de_Hilbert">dixième problème de Hilbert</a>. Il a été prouvé indécidable par Matiiassevitch en 1970 en montrant qu’on ne pouvait pas borner les racine d’un polynôme à plusieurs variables.</p>
</blockquote>

<h3 id="arret">arrêt d’un algorithme</h3>

<p>Savoir si un algorithme va s’arrêter, ou pas, sur une entrée est un problème compliqué. Prenez par exemple l’<a href="https://fr.wikipedia.org/wiki/Conjecture_de_Syracuse">algorithme suivant</a> :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">def</span> <span class="nf">syracuse</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>

</code></pre></div></div>

<p>L’algorithme est très simple : à partir d’un entier $n$, il le divise par 2 s’il est pair ou le multiplie par 3 et ajoute 1 s’il est impair et recommence tant que ce nombre est strictement plus grand que 1.</p>

<blockquote class="a-faire">
  <p>Testez chez vous pour plusieurs nombres, c’est assez bluffant.</p>

  <p>Affichez également la suite de nombre ou la représenter graphiquement pour voir l’évolution de votre nombre d’entrée jusqu’à 1.</p>
</blockquote>

<p>Personne ne sait (à l’heure où je tape ces caractères) si cet algorithme s’arrête pour tout $n$.</p>

<p>De façon plus générale :</p>

<blockquote class="note">
  <p><a href="https://fr.wikipedia.org/wiki/Probl%C3%A8me_de_l%27arr%C3%AAt">Le problème</a> de décision de savoir si un algorithme $M$ va s’arrêter sur l’entrée $E$ est indécidable.</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>On doit la preuve à Turing lui-même, qui l’a démontrée dans le cadre des machine de Turing.</p>

<p>Commençons par remarquer qu’un algorithme, tout comme une machine de Turing, peut s’<a href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/machine-turing.html#mtu">encoder sous la forme d’une suite de 0 et de 1</a>, on peut donc bien passer un algorithme comme paramètre d’entrée d’un algorithme.</p>

<p>On va maintenant supposer qu’un tel décideur existe et notons le <code class="language-plaintext highlighter-rouge">halt(&lt;M&gt;, E)</code> avec <code class="language-plaintext highlighter-rouge">&lt;M&gt;</code> le mot encodant l’algorithme <code class="language-plaintext highlighter-rouge">M</code>. Cet encodeur rend <em>Vrai</em> si l’exécution de <code class="language-plaintext highlighter-rouge">M</code> avec <code class="language-plaintext highlighter-rouge">E</code> va s’arrêter et <em>Faux</em> sinon.</p>

<p>On peut alors créer un  autre algorithme dont le pseudo-code est :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def diag(x):
    if halt(x, x) == 1:
        boucle infinie
    else:
        return Vrai
</code></pre></div></div>

<p>Tout comme <a href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/fonctions.html#nb-ss-ensemble-N">la preuve du théorème de Cantor</a> cette nouvelle machine va tout casser :</p>

<ol>
  <li>
<code class="language-plaintext highlighter-rouge">diag(x)</code> ne va s’arrêter que si <code class="language-plaintext highlighter-rouge">halt(x, x)</code> est faux</li>
  <li>
<code class="language-plaintext highlighter-rouge">halt(&lt;diag&gt;, x)</code> va répondre 1 que si <code class="language-plaintext highlighter-rouge">diag(x)</code> s’arrête</li>
  <li>
<code class="language-plaintext highlighter-rouge">halt(&lt;diag&gt;, &lt;diag&gt;)</code> va répondre 1 si <code class="language-plaintext highlighter-rouge">diag(&lt;diag&gt;)</code> s’arrête or <code class="language-plaintext highlighter-rouge">diag(&lt;diag&gt;)</code> ne peut s’arrêter que si <code class="language-plaintext highlighter-rouge">halt(&lt;diag&gt;, &lt;diag&gt;)</code> ne s’arrête pas</li>
  <li>contradiction</li>
</ol>

</div></details>

<blockquote>
  <p>Le problème de l’arrêt est souvent donné pour une machine de Turing.  on cherche à savoir si une machine de Turing donnée s’arrête ou pas. Comme il y a équivalence entre pseudo-code et machine de Turing et qu’on a décidé d’accepter la thèse de Church-Turing, on a reformulé tout ces problèmes avec des algorithmes.</p>
</blockquote>

<p>On peut montrer que le cas particulier suivant est lui aussi indécidable :</p>

<blockquote class="note">
  <p>Le problème consistant à savoir si un algorithme $M$ va s’arrêter sur l’entrée vide est indécidable.</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Si $E$ est une entrée et $M$ un algorithme, il existe un algorithme $M_E$ qui commente par affecter l’entrée $E$ à une variable, puis exécute l’algorithme $M(E)$. On a donc que $M$ accepte $E$ que si et seulement si $M_E$ accepte le mot vide.</p>

<p>De là, un algorithme qui pourrait décider si $M$ accepte ou non le mot vide déciderait également si $M$ accepte $E$, ce qui est impossible puisque le problème de l’arrêt est indécidable.</p>

</div></details>

<p>Il faut bien comprendre l’énoncé ci-dessus. Il n’existe pas de décideur qui prend comme entrée <strong>et</strong> un algorithme <strong>et</strong> une entrée et qui rend <em>Vrai</em> si l’algorithme va s’arrêter : l’algorithme et le mot d’entrée sont les paramètres du décideur.</p>

<p>Cela ne contredit pas le fait qu’on puisse créer un décideur spécifique à un algorithme qui réponde <em>vrai</em> ou <em>faux</em> selon le paramètre d’entrée de celle-ci. C’est l’algorithme général, indépendant de l’algorithme à tester, qui n’existe pas.</p>

<blockquote>
  <p>lorsque l’on parle de décidabilité ou de problème il faut toujours bien faire attention à ce qui est un paramètre d’entrée et ce qui est donné.</p>
</blockquote>

<p>Le théorème d’indécidabilité de l’arrêt d’un algorithme est fondamental théoriquement. Il est à la base de nombreux contre-exemples et :</p>

<ul>
  <li>il exhibe le fait qu’il existe des choses que l’on ne peut pas calculer avec un ordinateur</li>
  <li>en creux, il montre qu’on peut tout de même faire beaucoup de choses avec des algorithmes puisqu’il faut chercher des exemples bien tordus pour que ça ne marche pas</li>
</ul>

<h2 id="calculabilité">calculabilité</h2>

<p>La décidabilité cherche à reconnaitre des solutions d’un problème avec un algorithme. La calculabilité utilise la sortie d’une machine pour calculer des valeurs.</p>

<p><a href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/fonctions.html#nombre-fonction">On l’a vu</a>, il existe bien plus de fonctions que d’algorithmes. On peut maintenant essayer d’y voir un peu plus clair.</p>

<h3 id="fonctions-calculables">fonctions calculables</h3>

<blockquote class="note">
  <p>Un fonction de $f: \mathcal{F} \rightarrow \{0, 1\}^\star$, avec $\mathcal{F} \in \{0, 1\}^\star$ ($f$ prend en entrée un mot d’un sous-ensemble de $\{0, 1\}^\star$ et redonne un mot en sortie) est <strong>calculable</strong> s’il existe un algorithme $M$ telle que :</p>

  <ul>
    <li>$M(\mu) = f(\mu)$ si $\mu \in \mathcal{F}$</li>
    <li>$\mathcal{L}(M) = \mathcal{F}$</li>
  </ul>

</blockquote>

<p><a href="https://en.wikipedia.org/wiki/Computable_function#Examples">Par exemple</a> :</p>

<ul>
  <li>les fonctions constantes sont calculables</li>
  <li>si $f$ et $g$ sont deux fonctions calculables, alors $f+g$, $f \cdot g$ et $f \circ g$ sont calculables</li>
  <li>les fonctions dont le domaine de définition est fini, sont calculables</li>
  <li>…</li>
</ul>

<p>Beaucoup, beaucoup, beaucoup de fonctions sont calculables, il suffit d’exhiber un algorithme pour le prouver.</p>

<p>De façon plus bizarre, il existe aussi des fonctions, que l’on sait calculable, mais dont on ne connait pas l’algorithme pour le calculer :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def f(n):
    si il existe n "5" consécutifs dans les décimals de π:
        rend 1
    sinon:
        rend 0
</code></pre></div></div>

<p>La fonction ci-dessus est :</p>

<ul>
  <li>soit constante et $f(n) = 1$ pour tout $n$ (ce qui est calculable)</li>
  <li>soit il existe $n_0$ tel que pour tout $n \geq n_0$ ont ait $f(n) = 0$ et avant $f(n) = 1$ ($f$ revient à faire un test sur $n$, ce qui est aussi calculable).</li>
</ul>

<p>Elle est donc calculable, mais on ne sait pas quel algorithme c’est (cas on ne sais pas si π est <a href="https://fr.wikipedia.org/wiki/Nombre_univers">un nombre univers</a>).</p>

<p>Enfin, finissons cette partie en remarquant que décidabilité et calculabilité sont les deux faces d’une même pièce en remarquant que :</p>

<blockquote class="note">
  <p>Si une fonction $f: \mathcal{F} \rightarrow \{0, 1\}^\star$ est <strong>calculable</strong> alors $\{ (a, f(a) \mid a \in \mathcal{F}\}$ est <strong>reconnaissable</strong>.</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Si $f: \mathcal{F} \rightarrow \{0, 1\}^\star$ est calculable, l’algorithme $M$ prenant en entrée deux mots $a$ et $b$ et qui rend <em>Vrai</em> si $f(a) = b$ et ne s’arrête pas sinon est bien tel que $\mathcal{L}(M) = \{ (a, f(a) \mid a \in \mathcal{F}\}$.</p>

</div></details>

<p>Et si $f$ est défini sur tout mot (ce qui est très souvent le cas) on a même :</p>

<blockquote class="note">
  <p>Une fonction $f: \{0, 1\}^\star \rightarrow \{0, 1\}^\star$ est <strong>calculable</strong> si et seulement si $\{ (a, f(a) \mid a \in \{0, 1\}^\star\}$ est <strong>décidable</strong>.</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Si $f: \mathcal{F} \rightarrow \{0, 1\}^\star$ est calculable, l’algoithme $M$ prenant en entrée deux mots $a$ et $b$ et qui rend <em>vrai</em> si $f(a) = b$ et <em>faux</em> sinon est bien un décideur sur $\{ (a, f(a) \mid a \in \{0, 1\}^\star\}$</p>

<p>Réciproquement, soit $M$ un décideur sur $\{ (a, f(a) \mid a \in \{0, 1\}^\star\}$, l’algorithme $M’$ qui prend itérativement tous les mots $b$ et qui rend $b$ lorsque $M(a, b)$ rend <em>vrai</em> est bien fini pour tout $a$ et calcule bien $f(a)$.</p>

</div></details>

<h3 id="fct-non-calculable">fonctions non calculables</h3>

<p>Comme il suffit d’exhiber un algorithme pour montrer qu’une fonction est calculable, presque toutes les fonctions auxquelles on peut penser le sont. Pour trouver des fonctions non calculables, il faut chercher des exemples tordus.</p>

<p>Nous en donnons une ici, la plus célèbre : <a href="https://fr.wikipedia.org/wiki/Castor_affair%C3%A9">les castors affairés</a> (<em>busy beavers</em> dans la verion originale):</p>

<blockquote class="note">
  <p>On définit le <strong>score</strong> $\rho(M)$ d’une machine de Turing $M$ acceptant le mot vide comme étant le nombre de $1$ de $M()$.</p>

  <p>La fonction du <strong>castor affairé</strong> $\Sigma : \mathbb{N} \rightarrow \mathbb{N}$ est définie telle que $\beta(n)$ vaut le score maximal pour toutes les machine de Turing à $n$ états acceptant le mot vide.</p>

</blockquote>

<p>La fonction est bien définie pour tout $n&gt;0$ puisqu’il n’y a qu’un nombre fini de machine de Turing à $n$ états : la valeur $\beta(n)$ est un maximum d’un ensemble fini, ce nombre existe.</p>

<blockquote class="note">
  <p>$\beta(n) \geq n - 1$ pour tout $n &gt;0$</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Considérons la machine $M_n$ à $n$ états $(q_0, \dots, q_{n-1}) telle que :</p>

<ul>
  <li>$q_0$ est l’état initial</li>
  <li>$q_{n-1}$ l’état d’acceptation</li>
  <li>la fonction de transition $\delta$ telle que $\delta(q_i, \sharp) = (q_{i+1}, 1, \rightarrow)$</li>
</ul>

<p>On a $M_n() = \underbrace{1\cdots 1}_{n-1}{}$.</p>
</div></details>

<blockquote class="note">
  <p>$\beta(n)$ est strictement croissante</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Soit $B_n$ une machine à $n$ états telle que $\rho(B_n) = \beta(n)$. La machine obtenue en enchaînant $B_n$ et $M_1$ (voir preuve précédente) en associant l’état final de $B_n$ à l’état initial de $M_1$ a $n+1$ états (les état de B_n$ plus l’état d’acceptation de $M_1$) et sa sorite produit un 1 de plus que $\beta_n$ : $\beta(n+1) \geq \beta(n) + 1$.</p>

</div></details>

<p>Ce qui nous permet de prouver que :</p>

<blockquote class="note">
  <p>La fonction $\beta$ est non calculable.</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Supposons que $\beta$ soit calculable. Il existe alors une machine $F$ de pseudo code :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def F(n):

efface l'entrée du ruban

i = 0
tant que i &lt; 2 * β(n):
    écrire 1 sur le ruban et décaler le curseur un cran à droite
    i = i + 1
</code></pre></div></div>

<p>On peut supposer, sans perte de généralité, que l’entrée de $F$ soit uniquement composée de $1$(donc $n$ signifie que l’entrée est composée de n $1$ consécutifs).</p>

<p>De là, on peut également construire la machine $M$ :</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def M():
    M_n()
    déplace le curseur à gauche jusqu'à obtenir un blanc puis déplace le curseur d'un cran à droite
    F(n)
</code></pre></div></div>

<p>Cette machine enchaîne $M_n$ à $F$. Pour la sorite de $M_n()$ soit l’entrée de $F$, il faut décaler le ruban pour le placer jusqu’au premier 1 (ceci se fait avec une machine à 3 états). Cette machine à un nombre d’états égal au nombre d’état de $M_n$ plus le nombre d’état de la machine qui déplace le ruban (3) plus le nombre d’état de $F$ (disons $k$) moins les liants entre les machines (les états finaux des machines intermédiaires sont les états initiaux des machines suivantes), c’est à dire 2. Au final, la machine $M$ à : $n + 3 + k - 2 = n + k +1$ états et est telle que $\rho(M) = \beta(2n)$.</p>

<p>On en déduit l’inégalité : $\beta(n + k + 1) \geq \beta(2n)$ et comme $\beta$ est strictement croissante on a l’inégalité : $2n \leq n + k + 1$ pour tout $n &gt; 0$ ce qui est impossible.</p>

</div></details>

<blockquote>
  <p>L’<a href="https://www.gwern.net/docs/cs/1962-rado.pdf">article</a> de Tibor Radò où les busy beavers sont définis.</p>
</blockquote>

<h3 id="réels-calculables">réels calculables</h3>

<p>Tous les entiers sont calculables, il suffit de créer une machine qui écrit l’entier désiré sur le ruban. Comme les réels ont une notation décimale avec ne infinité de chiffre, on ne peut de toute façon  pas les écrire sur le ruban en temps fini. Certains d’entre eux sont cependant approchable d’aussi prêt que l’on veut à partir d’une machine de Turing :</p>

<blockquote class="note">
  <p>Un réel $x$ est calculable s’il existe une machine de Turing $X$ à un paramètre tel que :</p>

  <ul>
    <li>$X(0)$ rend la partie entière de $x$</li>
    <li>$X(i)$ rend la $i$-ème décimale de $x$, pour tout $i &gt; 0$</li>
  </ul>

</blockquote>

<p>Il existe d’autres définitions équivalentes, voir <a href="https://fr.wikipedia.org/wiki/Nombre_r%C3%A9el_calculable">cette page wikipédia</a>, des nombres calculable.</p>

<p>Un cas particulier important est lorsque le nombre est la limite d’une suite $u_n$ :</p>

<blockquote class="note">
  <p>Si $x$ est la limite d’une suite $(u_n)_{n \geq 0}$ et qu’il existe une machine de Turing $M$ telle que $M(n) = u_n$ pour tout $n$, alors $x$ est calculable.</p>
</blockquote>
<details><summary>preuve</summary><div>
<p>Comme $u_n$ converge vers $x$, pour tout $i&gt; 0$, il existe $N_i$ tel que $\mid x - u_n\mid &lt; 10^{-i}$ pour tout $n &gt; N_i$. Si l’on veut calculer la $i$-ème décimale de $x$, Il suffit de calculer $u_{N_{i}}$ et de prendre sa $i$-ème décimale</p>

</div></details>

<p>Par exemple, $\pi$ est calculable en utilisant <a href="https://fr.wikipedia.org/wiki/Formule_de_Leibniz#S%C3%A9rie_altern%C3%A9e">la série de Leibniz de $\pi$</a>. De la même manière, on peut calculer $cos(x)$, $sin(x)$ ou encore $\sqrt{x}$ pour tout $x$ calculable grâce à leur <a href="https://fr.wikipedia.org/wiki/Formulaire_de_d%C3%A9veloppements_en_s%C3%A9ries">développement en séries entières</a>.</p>

<blockquote class="note">
  <p>Si l’on pense à un réel calculé à partir d’une fonction mathématique usuelle, il y a toute les chances qu’il soit calculable</p>
</blockquote>

<h3 id="réels-non-calculables">réels non calculables</h3>

<p>On l’<a href="/cours_informatique/cours/theorie-pratiques-algorithmique/theorie/fonctions.html#r-et-n">a démontré</a>, il y a beaucoup plus de réels que de nombres entiers et il y a au plus autant d’algorithmes différents que de nombres entiers. Il y a donc de très nombreux réels qu’on ne peut pas calculer, et beaucoup plus qu’on ne peux en calculer.</p>

<p>Il est cependant dur d’en trouver un car tout ceux auxquels on peut penser sont soit des limites de suites, soit combinaison de fonctions calculables… Les exemples de nombres non calculables sont donc tordus.</p>

<p>Nous allons en montrer un nombre non calculable, le <a href="https://fr.wikipedia.org/wiki/Om%C3%A9ga_de_Chaitin#Le_%C2%AB_nombre_de_Turing_%C2%BB">nombre de Turing</a>, dérivé du célèbre<a href="https://fr.wikipedia.org/wiki/Om%C3%A9ga_de_Chaitin">nombre oméga de Chaitin</a>, lui aussi non dénombrable.</p>

<p>Comme il n’existe qu’un nombre dénombrable de machine de Turing (moins ou égal aux nombres d’entiers), on peut les ranger selon un ordre : $M_1$ première machine de Turing, $M_2$ deuxième machine de Turing, etc.</p>

<p>Le nombre de Turing $T$ est un réel entre 0 et 1 tel que sa $i$-ème décimal soit :</p>

<ul>
  <li>égale à 1 si la machine $M_i$ s’arrête pour une entrée vide</li>
  <li>égale à 0 si la machine $M_i$ se s’arrête pas pour une entrée vide</li>
</ul>

<p>Ce nombre n’est évidemment pas calculable car si on pouvait le faire, le problème de l’<a href="#arret">arrêt</a> serait décidable.</p>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique à l'école centrale marseille.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
