<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Exercices gloutons : corrigé</title>

    <link href="/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet">
    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">

    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Exercices gloutons : corrigé</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/">Algorithmie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/design-algorithmes/">Design d&#39;algorithmes</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/design-algorithmes/algorithmes-gloutons/">Algorithmes gloutons</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/design-algorithmes/algorithmes-gloutons/exercices-corrigé/">Exercices gloutons : corrigé</a>

</div>
</div>


    
  

  <h2>Glouton optimal</h2>
<h3>Recouvrement</h3>
<p><a href="https://algo.gricad-pages.univ-grenoble-alpes.fr/L3I-S5-algo/TD1-10-corrige.pdf">https://algo.gricad-pages.univ-grenoble-alpes.fr/L3I-S5-algo/TD1-10-corrige.pdf</a></p>
<blockquote>
<p>recouvrement de points par des intervalles exo 3</p>
</blockquote>
<p>On classe les réels par ordre croissants puis pour chaque réel $x_i$, s'il n'est pas couvert par un intervalle on ajoute l'intervalle $[x_i, x_i + 1]$.</p>
<h4>Initialisation de la récurrence</h4>
<p>Il existe bien une solution optimale avec $[x_1, x_1 +1]$ comme plus petit intervalle :<br>
- $x_1$ est couvert et soit l'intervalle le plus à gauche aui le couvre. Il n'y a aucun réel à gauche de $x_1$ donc aucun intervalle nécessaire à gauche de cet intervalle<br>
- si l'intervalle min ne commence pas en $x_1$ on le remplace par $[x_1, x_1 +1]$ et la solution continue d'être optimale</p>
<h4>Récurrence</h4>
<p>Soit $[x_i, x_i +1]$ le plus petit intervalle qui n'est pas dans la solution optimale.</p>
<p>Comme $x_i$ doit être couvert, il existe un intervalle qui le couvre. Comme tout $x_j$, avec $j &lt; i$ est couvert (les deux solutions coincident), on peut remplacer l'intervalle le plus à gauche couvrant $x_i$ dans la solution optimale par $[x_i, x_i +1]$ et la solution reste optimale.</p>
<h3>réservation SNCF</h3>
<h4>solution possible ?</h4>
<p>Une solution en $\mathcal{O}(n+K)$ :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">d <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> K

<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    d<span class="token punctuation">[</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>

<span class="token keyword">for</span> t <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>K<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> d<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">></span> P<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"le train"</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token string">"contient"</span><span class="token punctuation">,</span> d<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">-</span> P<span class="token punctuation">,</span> <span class="token string">"passagers de trop."</span><span class="token punctuation">)</span>
</code></pre>
<h4>solution approchée</h4>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">while</span> d<span class="token punctuation">[</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">></span> P<span class="token punctuation">:</span>
        d<span class="token punctuation">[</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>
        t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
</code></pre>
<p>A la fin de l'itération, les passagers surnuméraires ont été déplacés dans le premier train disponible.</p>
<p>Cette solution est optimale pour la fonction $\sum_{i\geq 1}(t'[i] - t[i])$ où $t'[i]$ est le train effectivement pris par le passager $i$.</p>
<h3>Une quête d'essence</h3>
<h4>Admissibilité</h4>
<p>Il faut et il suffit que les stations services soient éloignées de moins de $L$ kilomètres.</p>
<h4>Algorithme</h4>
<p>Il faut aller le plus loin possible à chaque fois : la prochaine station est la station la plus éloignée dont la distance est inférieure à $L$.</p>
<p>Soit $s_i$ la première station d'une solution optimale qui ne correspond pas avec la station $g_i$ choisie par le glouton . On a :</p>
<ul>
<li>$i&gt;1$ puisque la première station est la station de départ</li>
<li>$s_{i-1} = g_{i-1}$</li>
</ul>
<p>On en conclut que $s_i &lt; g_i$ et que l'on peut choisir $g_i$ comme $i$ ème choix pour la solution optimale et que, comme justement la solution est optimale, $s_{i+1} &gt; g_i$ sinon on aurait pu s'en passer.</p>
<p>Le raisonnement précédent montre que l'on peut construire une solution optimale qui coïncide avec le glouton : le glouton est optimal.</p>
<h4>Prix fluctuants</h4>
<p>On considère les stations par prix croissants et on leur associe à chacune un recouvrement de taille $L$.</p>
<p>Dans l'exemple ci-dessous on considère que l'ordre de prix croissant est le nombre, que chaque case fait 1km et que $L=10$ :</p>
<pre class="language-text " style="counter-reset: linenumber 0"><code class="language-text">1111111111
               2222222222
      3333333333
         4444444444
1     3  4     2        5   : ordre des prix
1     2  3     4        5   : ordre dans le parcours
</code></pre>
<p>On découpe ensuite les intervalles pour qu'ils partitionnent l'espace en ne conservant que la partie la plus petite.</p>
<pre><code>On suppose que les intervalles I[i] sont rangés par prix croissant

pour i allant de 1 à n-1:
    pour j allant de i+1 à n-1:
        I[j] = I[j] privé de I[i]
</code></pre>
<p>L'intervalle restant est la quantité d'essence mettre dans le réservoir :</p>
<pre class="language-text " style="counter-reset: linenumber 0"><code class="language-text">1111111111
               2222222222
          33333 
                   
1     3  4     2        5
1     2  3     4        5
</code></pre>
<p>On voit dans l'exemple que la station 4 est inutile et qu'il faut tout de même mettre de l'essence en passant à la station 3.</p>
<p>La preuve de l'optimalité vient du fait que l'essence mise à la station $i$ permet de faire la distance allant de $d_i$ à $d_i + L$. On a gardé que les kilomètres ne pouvant pas être couvert par une station ayant un prix inférieur.</p>
<h2>Problèmes d'ordonnancements</h2>
<h3>Ordonnancement avec pénalité</h3>
<p>Tout pareil. On dit que la pénalité est un gain qu'on cherche à maximiser : on réalisera en priorité les tâches avec la plus grande pénalité et donc on minimisera les pénalités des tâches non effectuées.</p>
<h3>Ordonnancement avec départ différé</h3>
<h4>Formalisation du problème</h4>
<ul>
<li>la tâche $\sigma_1$ a commencé en 0 et a fini en $p_{\sigma_1}$</li>
<li>la tâche $\sigma_2$ a commencé en $p_{\sigma_1}$ et a fini en $p_{\sigma_1} + p_{\sigma_2}$</li>
<li>la tâche $\sigma_3$ a commencé en $p_{\sigma_1} + p_{\sigma_2}$ et a fini en $p_{\sigma_1} + p_{\sigma_2} + p_{\sigma_3}$</li>
</ul>
<p>On a donc la formule suivante pour donner la somme de toutes les débuts de tâches :</p>
<div>
$$
   T = \sum_{1\leq i \leq n}( \sum_{1\leq j < i}p_{\sigma_j}) = \sum_i(n-i)p_{\sigma_i}
$$
</div>
<p>Pour 3 tâches, il y a 6 ordonnancements possibles qui donnent respectivement :</p>
<ul>
<li>1 puis 3 puis 5 : $T = 2 \cdot 1 + 1 \cdot 3 = 5$</li>
<li>1 puis 5 puis 3 : $T = 2 \cdot 1 + 1 \cdot 5 = 7$</li>
<li>3 puis 1 puis 5 : $T = 2 \cdot 3 + 1 \cdot 1 = 7$</li>
<li>3 puis 5 puis 1 : $T = 2 \cdot 3 + 1 \cdot 5 = 11$</li>
<li>5 puis 1 puis 3 : $T = 2 \cdot 5 + 1 \cdot 1 = 11$</li>
<li>5 puis 3 puis 1 : $T = 2 \cdot 5 + 1 \cdot 3 = 13$</li>
</ul>
<h4>Algorithme</h4>
<p>Minimiser la valeur moyenne des débuts de réalisation minimise $T/n$. Il suffit donc de minimiser $T$.</p>
<p>L'ordre selon lequel il faut ordonner les tâches est par durée décroissante. S'il existait en effet $i &lt; j$ tel que $p_{\sigma_i} &gt; p_{\sigma_j}$ changer les deux tâches diminuerait strictement $T$ puisque $n-i &gt; n-j$. Cet ordre donne directement l'algorithme glouton :</p>
<pre class="language-text " style="counter-reset: linenumber 0"><code class="language-text">On trie les tâches par durée croissante
Pour chaque tâche dans cet ordre:
    réaliser cette tache
</code></pre>
<h4>Dates de disponibilité</h4>
<p>Le même raisonnement que précédemment montre que l'on peut ordonner les tâches par $d_i + p_i$ croissants.</p>
<h4>Interruption de tâches</h4>
<p>On peut à chaque unité réaliser une unité de temps de la tâche qui se finit au plus tôt parmi les tâches que l'on peut réaliser. Ceci garantit que les tâches sont bien réalisées de la plus rapide à la plus lente.</p>
<h3>Ordonnancement avec retard</h3>
<h4>Premières propriétés</h4>
<p>Si l'on réduit l'inactivité de l'ouvrier, les tâches vont commencer plus tôt, donc $s_i$ va diminuer et donc $r_i$ aussi : $R$ ne peut que diminuer.</p>
<p>La remarque précédente nous indique que l'ouvrier doit commencer une nouvelle tâche immédiatement après avoir fini la précédente.</p>
<h4>Mauvais ordres</h4>
<p>Durée croissante :</p>
<ul>
<li>$d_1 = 1$, $f_1 = 11$</li>
<li>$d_2 = 10$, $f_2 = 10$</li>
</ul>
<p>Durée décroissante :</p>
<ul>
<li>$d_1 = 10$, $f_1 = 11$</li>
<li>$d_2 = 1$, $f_2 = 1$</li>
</ul>
<h4>Ordre optimal</h4>
<p>On a $r_{i+1} = s_{i+1} + d_{i+1} - f_{i+1} = s_{i} + d_{i} + d_{i+1} - f_{i+1}$, donc :</p>
<ul>
<li>$r_{i+1} \geq s_{i} + d_{i+1} - f_{i+1}$</li>
<li>$r_{i+1} \geq s_{i} + d_{i+1} + d_{i} - f_{i}$, si $f_{i}&gt; f_{i+1}$</li>
</ul>
<p>L'échange des deux tâches n'augmente pas le retard maximal.</p>
<p>Si l'on range les éléments par taille de fin demandée croissante, on est alors minimal car $f_{i}&lt; f_{i+1}$ pour tout $i$ est  équivalent à $f_{i}&lt; f_{j}$ pour tout $i&lt;j$.</p>
<h2>Glouton pas optimal mais pas mal</h2>
<h3>Empaquetage</h3>
<h4>Applications</h4>
<p>Le transport de marchandises, le déchargement d'un cargo dans des camions, ...</p>
<h4>Solution optimale</h4>
<p>Si l'on a $m$ ensembles, on peut ranger au maximum une somme valant $K\cdot m$ qui doit donc être supérieure à la somme de tous les entiers.</p>
<h4>Propriétés</h4>
<p>On crée un nouvel ensemble que si l'entier courant ne tient pas dans l'ensemble considéré : la somme de ces deux ensembles consécutifs est donc strictement plus grande que $K$.</p>
<p>Dans le cas où $m$ est pair on a alors :</p>
<ul>
<li><code class="language-">somme(E[0]) + somme(E[1]) &gt; K</code></li>
<li><code class="language-">somme(E[2]) + somme(E[3]) &gt; K</code></li>
<li><code class="language-">somme(E[4]) + somme(E[5]) &gt; K</code></li>
<li>...</li>
</ul>
<p>Et on en déduit, si $m$ est pair, que : <code class="language-">somme(E[0]) + ... + somme(E[m-1]) &gt; K * m / 2</code>. Le calcul est identique si $m$ est impair.</p>
<h4>Performance garantie</h4>
<p>Clair en utilisant les 2 questions précédentes.</p>
<p>De plus ceci montre  que c'est vrai quel que soit l'ordre utilisé</p>
<h4>Cas le pire</h4>
<p>On suppose une alternance d'entiers valant $\frac{K}{2}$ et $1$.</p>
<h3>Équilibrage de charge</h3>
<h4>Quelques propriétés</h4>
<p>La première inégalité vient du fait que toute tâche doit être effectuée par une machine : la machine $i$ qui réalisera la tâche de plus longue durée aura un $T_i$ plus grand que cette durée.</p>
<p>La seconde inégalité découle du fait que $\min T_i \leq \frac{1}{m}\sum_i T_i \leq \max_i T_i$, et que $\sum_i T_i = \sum_j t_j$. L'inégalité est ainsi vraie pour toute assignation donc également pour l'assignation optimale.</p>
<h4>Un algorithme glouton</h4>
<p>Il vaut mieux répartir les tâches longues sur plusieurs machines, par exemples pour trois machines la répartition $[(4,), (4,), (1, 1, 1)]$ est préférable à la répartition $[(1, 4), (1, 4), (1,)]$ de 5 tâches de durée 4, 4, 1, 1 et 1.</p>
<p>On rangera donc les tâches par durées décroissantes.</p>
<p>Il est clair que s'il y a moins de $m$ tâches à ranger chaque machine aura au plus 1 tâche : la répartition sera optimale.</p>
<h4>Propriétés</h4>
<ol>
<li>avant l'affectation de la tâche $j$ à la machine, son temps total était le plus faible. S'il y a eu des tâches d'affectées après la tâche $j$ elles l'ont été à d'autres machines qui ont augmenté leur temps total d'exécution, la propriété est donc toujours vrai à la fin de l'algorithme.</li>
<li>En sommant l'inégalité précédente pour toutes les machines on obtient : $m\cdot(T_{i^\star} -t_j)\leq \sum_{1\leq k\leq m}T_k$</li>
<li>vient directement du fait que $T^\star \geq \frac{1}{m}\sum_{1 \leq j\leq n} t_j$</li>
<li>clair puisque $t_j \leq \max t_k \leq T^\star$</li>
</ol>
<h5>Performances</h5>
<p>La première partie est évidente et comme les inégalités ne dépendent pas de l'ordre choisit la seconde également.</p>
<h3>Plan de tables</h3>
<blockquote>
<p>TBD</p>
</blockquote>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>