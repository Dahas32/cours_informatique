<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Algorithmes classiques</title>

    <link href="/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet">
    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">

    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Algorithmes classiques</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/">Algorithmie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/projet-classiques/">Algorithmes classiques</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/projet-classiques/exercices-sujets/">Algorithmes classiques</a>

</div>
</div>


    
  

  <p>Algorithmes classiques dont l'intérêt est à la fois esthétique (ce sont de jolis algorithmes),<br>
pratiques (ils mettent en oeuvre des techniques facilement réutilisables) et didactiques (trouver et prouver leurs fonctionnement vous fera progresser).</p>
<h2>Récursion et complexité</h2>
<h3>Exercice 1</h3>
<p>On considère le code suivant :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">ma_fonction</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">2</span>
    <span class="token keyword">return</span> ma_function<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> ma_fonction<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span>
</code></pre>
<ul>
<li>Quelle est la complexité de cet algorithme ? $\mathcal{O}(1)$, $\mathcal{O}(2^n)$ ou $\mathcal{O}(n)$ ? Justifiez votre réponse.</li>
<li>Donnez une version itérative de l'algorithme</li>
</ul>
<h3>Exercice 2</h3>
<p>On considère le code suivant :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">ma_fonction</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">2</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">+</span> ma_function<span class="token punctuation">(</span>n <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> ma_fonction<span class="token punctuation">(</span>n <span class="token operator">//</span> <span class="token number">4</span><span class="token punctuation">)</span>
</code></pre>
<ul>
<li>
<p>Quelle est l'équation de complexité vérifiée par ce algorithme ?</p>
<ul>
<li>$t(n)= \mathcal{O}(1) + t(n/2) + 2 \cdot t(n/4)$</li>
<li>$t(n)= \mathcal{O}(1) + t(n/2) + t(n/4)$</li>
<li>$t(n) = t(n/2) \cdot t(n/4)$</li>
</ul>
</li>
<li>
<p>Calculez la complexité de l'algorithme</p>
</li>
</ul>
<h2>Tour de Hanoï</h2>
<p>Les <em>tours de Hanoï</em> sont un célèbre casse tête inventé par Édouard Lucas qui consiste à déplacer $n$ disques de diamètres différents d'une tour de <em>&quot;départ&quot;</em> à une tour d' <em>&quot;arrivée&quot;</em> en passant par une tour <em>&quot;intermédiaire&quot;</em>, tout en respectant les règles suivantes :</p>
<ul>
<li>on ne peut déplacer qu'un disque à la fois</li>
<li>on ne peut placer un disque sur un disque plus petit que lui.</li>
</ul>
<p>On suppose que cette dernière règle est également respectée dans la configuration de départ.</p>
<p>Donnez un algorithme récursif permettant de résoudre le problème. Quelle est sa complexité ? Peut-on faire mieux ?</p>
<h2>Polynômes</h2>
<p>Un polynôme peut être vu comme une liste de ses coefficients. Le polynôme $P(x) = 1 + 3x^2$ s'écrira ainsi avec la liste $[1, 0, 3]$ et plus généralement, le polynôme $P(x) = \sum_{i=0}^n a_ix^i$ s'écrira sous la forme d'une liste $L$ à $n+1$ éléments telle que $L[i] = a_i$.</p>
<p>Manipulons cette structure.</p>
<h3>Écrivez une fonction <em>somme</em></h3>
<p>Écrivez une fonction permettant de rendre le polynôme $R(x) = P(x) + Q(x)$, somme des 2 polynômes $P(x)$ et $Q(x)$ passés en paramètres.</p>
<p>Vous pourrez utiliser la méthode <code class="language-">append</code> des listes qui ajoute un élément en fin de liste (si <code class="language-">l= [1, 2]</code>, l'instruction <code class="language-">l.append(3)</code> <strong>modifie</strong> <code class="language-">l</code>, pour qu'elle soit égale à <code class="language-">l= [1, 2, 3]</code>)</p>
<h3>Écrivez une fonction <em>produit</em></h3>
<p>Écrivez une fonction permettant de rendre le produit le polynôme $R(x) = P(x) \cdot Q(x)$, produit des 2 polynômes $P(x)$ et $Q(x)$ passés en paramètres.</p>
<h3>Écrivez une fonction <em>valeur</em></h3>
<p>Écrivez une fonction prenant un polynôme $P(x)$ et un réel $r$ et rendant l'évaluation $P(r)$ de $P(x)$ en $r$.</p>
<p>Vous pourrez utiliser le fait que <code class="language-">x ** i</code> en python soit égal à $x^i$</p>
<p>L'exonentiation est une opération couteuse en multiplications. Combien en avez-vous eu besoin pour exécuter votre fonction ?</p>
<h3>Amélioration</h3>
<p>Si on note :</p>
<ul>
<li>$A(x) = a_0$</li>
<li>$X(x) = x$</li>
<li>$P(x) = \sum_{i=0}^n a_ix^i$</li>
<li>$Q(x) = \sum_{i=0}^{n-1} a_{i+1}x^i$</li>
</ul>
<p>On a clairement que : $P(x) = A(x) + X(x) \cdot R(x)$.</p>
<p>En déduire une méthode d'évaluation de polynômes moins gourmande en multiplications.</p>
<h2>Suppression de valeurs</h2>
<p>La structure de donnée utilisée ici est la <strong><em>liste</em></strong>. On considérera que :</p>
<ul>
<li>la création d'une liste vide se fait en $\mathcal{O}(1)$ opérations,</li>
<li>l'ajout d'un élément en fin de liste se fait en $\mathcal{O}(1)$ opérations,</li>
<li>lire un élément d'une liste se fait en $\mathcal{O}(1)$ opérations.</li>
</ul>
<h3>Suppression d'une valeur</h3>
<p>Écrire un algorithme permettant de résoudre le problème suivant :</p>
<ul>
<li>Données : Une liste <code class="language-">L</code> et une valeur <code class="language-">val</code>.</li>
<li>Rendre : Une liste <code class="language-">L_2</code>, restriction de <code class="language-">L</code> aux valeurs différentes de <code class="language-">val</code>.</li>
</ul>
<p>Quel est sa complexité ?</p>
<h3>Suppression d'une valeur in-place</h3>
<p>Écrire un algorithme permettant de supprimer une valeur d'une liste :</p>
<ol>
<li>sans créer de liste annexe</li>
<li>de façon optimale</li>
</ol>
<p>Pour cet exercice, on ne se préoccupe pas de l'ordre des éléments dans la liste.</p>
<h2>Suppression de doublons</h2>
<p>Même structure que pour l'exercice précédent.</p>
<p>La structure de donnée utilisée ici est la <strong><em>liste</em></strong>. On considérera que :</p>
<ul>
<li>la création d'une liste vide se fait en $\mathcal{O}(1)$ opérations,</li>
<li>l'ajout d'un élément en fin de liste se fait en $\mathcal{O}(1)$ opérations,</li>
<li>lire un élément d'une liste se fait en $\mathcal{O}(1)$ opérations.</li>
</ul>
<h3>Suppression de doublon en conservant l'ordre</h3>
<p>Utilisez la question précédente pour écrire un algorithme résolvant le problème suivant :</p>
<ul>
<li>Données : Une liste <code class="language-">L</code>.</li>
<li>Rendre : Une liste <code class="language-">L_2</code> ne contenant qu'une seule occurrence de chaque valeur de <code class="language-">L</code> et en conservant le même ordre.</li>
</ul>
<p>Quel est sa complexité ?</p>
<h3>Suppression de doublon d'une liste ordonnée</h3>
<p>Même question que précédemment, mais on considère que la liste <code class="language-">L</code> en entrée est triée. Donnez un algorithme en $\mathcal{O}(n)$ pour résoudre ce problème, où $n$ est le nombre d'éléments de <code class="language-">L</code>.</p>
<h3>Suppression de doublon d'une liste sans ordre</h3>
<p>Si l'ordre des éléments de <code class="language-">L_2</code> n'est pas important, proposez une meilleure solution à la deuxième question.</p>
<h2>Min et max d'un tableau d'entiers</h2>
<p>On compte précisément les comparaisons (comme on l'a fait en comptant les multiplications avec le problème de l'exponentiation)</p>
<ul>
<li>juste min</li>
<li>juste max</li>
<li>faire les deux ensemble</li>
</ul>
<h2>Suite de Fibonacci</h2>
<ul>
<li>F(n) = 1/sqrt(5)(phi^n - phi'^n) = ou` racines de x^2 = x + 1 (phi = nombre d'or, phi'=-1/phi)</li>
<li>F(n+1)/F(n) -&gt; phi</li>
<li>récursif, algorithme et complexité</li>
<li>itératif, algorithme et complexité</li>
<li>récursif en temps linéaire (en montée)</li>
</ul>
<h2>Triangle de Pascal</h2>
<ul>
<li>récursif, algorithme et complexité</li>
<li>itératif, algorithme et complexité</li>
<li>itératif avec une complexité en mémoire de $\mathcal{O}(n)$</li>
</ul>
<h2>Ackermann</h2>
<p>La fonction d'Ackermann se définit de la manière suivante, pour tous entiers $m$ et $n$ positifs :</p>
<div>
$$
A(m,n) =
\left\{
\begin{array}{lll}
 & n + 1 &\mbox{ si } m = 0\\
& A(m - 1, 1) &\mbox{ si } n = 0, m>0\\
& A(m - 1, A(m, n - 1)) &\mbox{ sinon }\\
\end{array}
\right.
$$
</div>
<ul>
<li>Donnez un pseudo-code récursif et itératif de cette fonction.</li>
<li>Donnez le nombres d'appels récursif du calcul de A(n, n).</li>
</ul>
<blockquote>
<p>TBD calculs de A(m, n) avec les puissances itérées de Knuth.</p>
</blockquote>
<h2>Méthodes de tri</h2>
<h3>Tri par base</h3>
<p>Ce tri s'applique uniquement aux entiers positifs, que l'on considère écrits en base 2. Notre entrée est une liste de listes composées de 0 et de 1. Par exemple : T = [[1, 0, 0, 1], [1, 1, 1, 0], [0, 0, 0, 1]] qui correspond aux nombres [9, 14, 1] On supposera également que toutes les listes ont même longueur. Le principe de ce tri est très simple :</p>
<ul>
<li>On considère d'abord le bit de poids le plus faible (<em>ie.</em> le plus à droite). On crée alors deux listes L0 et L1 initialement vides et on va itérativement considérer chaque élément de la liste à trier :
<ul>
<li>les entiers dont le bit de poids le plus faible est 0 sont ajoutés à la fin de L0</li>
<li>les entiers dont le bit de poids le plus faible est 1 sont ajoutés à la fin de L1</li>
</ul>
</li>
<li>On concatène les deux sous-listes T = L0 + L1</li>
<li>On recommence sur le bit à gauche de celui qu'on vient de traiter.</li>
<li>...</li>
</ul>
<p>Les parcours des liste T se font, toujours, de la gauche vers la droite.</p>
<p>Pour notre exemple :</p>
<ol>
<li>après premiere boucle : [[1,1,1,0], [1, 0, 0, 1], [0, 0, 0, 1]]</li>
<li>après deuxième boucle : [[1, 0, 0, 1], [0, 0, 0, 1], [1,1,1,0]]</li>
<li>après troisième boucle :[[1, 0, 0, 1], [0, 0, 0, 1], [1,1,1,0]]</li>
<li>après quatrième boucle : [[0, 0, 0, 1], [1, 0, 0, 1], , [1,1,1,0]]</li>
</ol>
<p>Donnez le pseudo-code, la preuve et la complexité de cet algorithme (on supposera que l'on dispose d'une fonction qui, étant donnés deux entiers $n$ et $i$, donne le $i^{me}$ bit de $n$).</p>
<p>Rappelez la complexité minimale du tri (dans le cas le pire). Commentaires.</p>
<h3>Tri par monotonies</h3>
<p>Étant donné un tableau $T$, <strong><em>une monotonie</em></strong> est une suite croissante maximale d'éléments consécutifs de $T$. Par exemple :<br>
si $T = [2,6, 1,3, 3, 5,2,6, 4,0, 1,8,9,1,3, 2,0,1,0]$, alors $[2,6]$, $[1,3,3,5]$, $[2,6]$, $[4]$, $[0, 1,8,9]$, $[1,3]$, $[2]$, $[0,1]$ et $[0]$ sont les monotonies de $T$.</p>
<p>Donnez un algorithme qui, étant donné un tableau $T$ construit une liste (de listes) $L$, chaque élément de $L$ étant une monotonie de $T$ (et vice versa). À partir de notre exemple, on obtient :<br>
$L = [[2,6], [1,3,3,5],[2,6], [4], [0, 1,8,9], [1,3], [2] ,[0,1], [0]]$.</p>
<p>Donnez un algorithme qui fusionne deux monotonies ; par exemple, à partir de $[2,6]$ et $[1,3,3,5]$, on obtient $[1,2,3,3,5,6]$ (ceci est aussi une question de cours).</p>
<p>Donnez un algorithme qui, étant donnée une liste $L$ de monotonies, les fusionne deux-à-deux (en en laissant éventuellement une ``toute seule&quot; à la fin) et met le résultat dans une liste (de listes) $L'$. Par exemple, à partir de<br>
$L = [[2,6], [1,3,3,5],[2,6], [4], [0, 1,8,9], [1,3], [2] ,[0,1], [0]]$, on obtient $L' = [[1,2,3,3,5,6], [2,4,6],[0,1,1,3,8,9], [0,1,2], [0]]$.</p>
<p>En déduire un algorithme de tri. Donnez sa complexité dans le cas le meilleur et dans le cas<br>
le pire.</p>
<p>Cet algorithme est en fait une variante d'un algorithme vu en cours. Lequel ?</p>
<h2>Compteur binaire</h2>
<ul>
<li>suivant</li>
<li>tous</li>
</ul>
<blockquote>
<p>TBD. Avec calcul de complexité naif et exact.</p>
</blockquote>
<h2>Jets de dés</h2>
<ul>
<li>algorithme itératif (généralisation du compteur binaire)</li>
<li>algorithme récursif. Complexité en mémoire ?</li>
</ul>
<p>On considère l'algorithme suivant:</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">LaFonction</span> <span class="token punctuation">(</span>L<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            LaFonction<span class="token punctuation">(</span>L <span class="token operator">+</span> <span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> n <span class="token operator">-</span>  <span class="token number">1</span><span class="token punctuation">)</span>

</code></pre>
<p>On rappelle que, appliqué à des listes, le $+$ est la concaténation. On supposera que l'appel initial se fait avec la liste L vide. Que fait cet algorithme ? Quelle est sa complexité ? Quelle place mémoire consomme-t-il ?</p>
<h2>Chaînes de caractères</h2>
<h3>Sous-séquence</h3>
<p>Soient deux chaînes de caractères $S_1$ et $S_2$. On dit que $S_2$ est une {\em sous-séquence} de $S_1$ si il existe une fonction strictement croissante</p>
<p>$$<br>
f : {0,\ldots, len(S_2)-1} \longrightarrow {0,\ldots, len(S_1)-1}<br>
$$</p>
<p>Telle que $S_1[f(j)] = S_2[ j]$ pour tout $j$ de ${0,\ldots, len(S_2)-1}$.</p>
<p>Proposez, prouvez et donnez la complexité d'un algorithme qui détermine si $S_2$ est une sous-séquence de $S_1$.</p>
<h3>Sous-mot</h3>
<p>Soient deux chaînes de caractères $S_1$ et $S_2$. On dit que $S_2$ est un <strong><em>sous-mot</em></strong> de $S_1$ s'il existe un indice $i$ tel que $S_2[j] = S_1[i + j]$ pour tout $j$ de $0$ à $len(S_2) - 1$.</p>
<ul>
<li>Proposez, prouver et donner la complexité d'un algorithme qui détermine si $S_2$ est un sous-mot de $S_1$.</li>
<li>Si toutes les lettres de $S_2$ sont deux à deux différentes, donnez un algorithme en $\mathcal{O}(len(S_1))$ pour résoudre ce problème.</li>
</ul>
<h2>Algorithme mystère</h2>
<p>L'algorithme suivant, à partir d'une liste d'entiers positifs, rend une autre liste. On suppose pour cet exercice que la création des deux listes tempo et sortie est en $\mathcal{O}(1)$ opérations.</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> mystère<span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">:</span>
    k <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span>
    tempo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    sortie <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        tempo<span class="token punctuation">[</span>tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        tempo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> tempo<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        sortie<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tempo<span class="token punctuation">[</span>tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span>
        tempo<span class="token punctuation">[</span>tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>

    <span class="token keyword">return</span> sortie

</code></pre>
<ul>
<li>Donnez la complexité de cet algorithme.</li>
<li>Dites ce qu'il fait et prouvez le (<em>indication</em>: après chacune des deux premières boucles, que contient tempo ?).</li>
<li>Commentaires ?</li>
</ul>
<h2>Cols</h2>
<ul>
<li>d'une liste (max ou min local). Trouver un algorithme en log</li>
<li>d'une matrice (min ligne et max colonne) avec un algorithme linéaire en la taille de la matrice (pourquoi le log ne marche-t-il pas ?)</li>
</ul>
<h2>Permutation circulaire</h2>
<p>Étant donné un liste $L$ de longueur $n$ et un entier $k$, le problème est de transformer $L$ par permutation circulaire en décalant (circulairement) tous les éléments de $L$ de $k$ places. Par exemple, avec $L = \text{LongtempsJeMeSuisCouchéDeBonneHeure}$ et $k = 4$, on obtient $L' = \text{eureLongtempsJeMeSuisCouchéDeBonneH}$.</p>
<ul>
<li>Donnez un algorithme $\text{Permut}(L, k)$ qui, avec une liste $L$ et un entier $k$ en entrées, construit une nouvelle liste $L'$, permutation circulaire de $L$.</li>
<li>Si on veut transformer $L$ en $\text{Permut}(L,k)$, montrez que la place mémoire utilisée (en plus de celle des données du problème ($L$)) par votre algorithme est $O(n)$.</li>
</ul>
<p>On veut maintenant faire une permutation circulaire sur site, <em>ie.</em> sans utiliser plus que $O(1)$ place mémoire supplémentaire (il arrive (par exemple quand on étudie le génome) que $n$ soit très grand). Il faut pour cela<br>
remarquer que permuter circulairement $L$ revient à prendre les $k$ dernières lettres de $L$ et à les mettre en tête. On note $L^R$ la liste $L$ <strong><em>renversée</em></strong> (par exemple, si $L =\text{Couché}$, $L^R = \text{éhcuoC}$).</p>
<ul>
<li>Donnez un algorithme en $O(n)$ et utilisant $O(1)$ place mémoire supplémentaire, qui transforme $L$ en $L^R$.</li>
<li>Montrez que, si on note $L = AB$, où $B$ est de longueur $k$ (par exemple, avec $L = \text{LongtempsJeMeSuisCouchéDeBonneHeure}$ et $k = 4$, $A =\text{LongtempsJeMeSuisCouchéDeBonneH}$ et $B =\text{eure}), alors \text{Permut}(L, k) = (A^RB^R)^R$.</li>
<li>Déduisez-en un algorithme de complexité $O(n)$ qui permute une liste (de longueur $n$), <em>ie.</em> qui transforme $L$ en $\text{Permut}(L,k)$, en utilisant $O(1)$ espace mémoire supplémentaire.</li>
</ul>
<h2>Algorithmes arithmétique</h2>
<ul>
<li>addition de listes de chiffres</li>
<li>multiplications de listes de chiffres</li>
</ul>
<p>(- <a href="https://fr.wikipedia.org/wiki/Algorithme_de_Karatsuba">optimisation de Karastuba</a>)</p>
<h2>Matrices</h2>
<ul>
<li>structure</li>
<li>addition</li>
<li>produit par un scalaire</li>
<li>produit naïf</li>
</ul>
<p>(- <a href="https://fr.wikipedia.org/wiki/Algorithme_de_Strassen">produit de Strassen</a>}</p>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>