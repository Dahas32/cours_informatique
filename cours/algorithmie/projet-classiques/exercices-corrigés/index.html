<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Corrigé</title>

    <link href="/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet">
    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">

    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Corrigé</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/">Algorithmie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/projet-classiques/">Algorithmes classiques</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/projet-classiques/exercices-corrigés/">Corrigé</a>

</div>
</div>


    
  

  <h2>Fibonacci</h2>
<h3>Récursif</h3>
<p>En notant $A(n)$ le nombre d'appels à la fonction, on a :</p>
<ul>
<li>l'appel proprement dit,</li>
<li>le nombre d'appel à <code class="language-">fibonacci_rec(n-1)</code></li>
<li>le nombre d'appel à <code class="language-">fibonacci_rec(n-2)</code></li>
</ul>
<p>Ce qui donne l'équation suivante :</p>
<div>
$$
A(n) = 1 + A(n-1) + A(n-2)
$$
</div>
<p>En notant $C(n)$ la complexité de la fonction, on a l'équation de récurrence suivante :</p>
<div>
$$
C(n) = \mathcal{O}(1) + C(n-1) + C(n-2)
$$
</div>
<p>La complexité étant croissante, on a que : $C(n-1) \geq C(n-2)$ et on a bien l'inégalité :</p>
<div>
$$
\mathcal{O}(1) + 2 \cdot C(n-2) \leq C(n) \leq \mathcal{O}(1) + 2 \cdot C(n-1)
$$
</div>
<div>
$$
\begin{array}{ccll}
C(n) &\leq & \mathcal{O}(1) + 2 \cdot C(n-1)&\\
     &\leq & \mathcal{O}(1) + 2 \cdot (\mathcal{O}(1) + 2 \cdot C(n-2)) & \text{en réapplicant l'inégalité pour } C(n-1)\\
     &\leq & \mathcal{O}(1)\cdot (1 + 2) + 4 \cdot C(n-2)&\\
     &\leq & \mathcal{O}(1)\cdot (1 + 2) + 4 \cdot (\mathcal{O}(1) + 2 \cdot C(n-3)) & \text{en réapplicant l'inégalité pour } C(n-2)\\
     &\leq & \mathcal{O}(1)\cdot (1 + 2 + 4) + 8 \cdot C(n-3)&\\
\end{array}
$$
</div>
<p>On peut reappliquer l'inégalité de récurrence autant de fois que l'on veut ce qui donne, en l'appliquant $K$ fois :</p>
<div>
$$
\begin{array}{ccll}
C(n) &\leq & \mathcal{O}(1)\cdot (\sum_{i=0}^{K-1}2^i) + 2^K \cdot C(n-K)&\\
\end{array}
$$
</div>
<p>Les seules valeurs de $C(n)$ connues sont celles pour $n=1$ ou $n=2$. Il faut donc appliquer notre formule pour $K=n-2$, ce qui donne l'inégalité :</p>
<div>
$$
\begin{array}{ccll}
C(n) &\leq & \mathcal{O}(1)\cdot (\sum_{i=0}^{n-3}2^i) + 2^{n-2} \cdot C(2)&\\
\end{array}
$$
</div>
<p>De même, en utilisant l'inégalité $\mathcal{O}(1) + 2 \cdot C(n-2) \leq C(n)$, on obtient :</p>
<div>
$$
\begin{array}{ccll}
C(n) &\geq & \mathcal{O}(1) + 2 \cdot C(n-2)&\\
     &\geq & \mathcal{O}(1) + 2 \cdot (\mathcal{O}(1) + 2 \cdot C(n-4)) & \text{en réapplicant l'inégalité pour } C(n-2)\\
     &\geq & \mathcal{O}(1)\cdot (1 + 2) + 4 \cdot C(n-4)&\\
     &\geq & \mathcal{O}(1)\cdot (1 + 2) + 4 \cdot (\mathcal{O}(1) + 2 \cdot C(n-6)) & \text{en réapplicant l'inégalité pour } C(n-4)\\
     &\geq & \mathcal{O}(1)\cdot (1 + 2 + 4) + 8 \cdot C(n-6)&\\
\end{array}
$$
</div>
<p>De même que précédemment, en applicant l'inégalité de récurrence $K$ fois :</p>
<div>
$$
\begin{array}{ccll}
C(n) &\geq & \mathcal{O}(1)\cdot (\sum_{i=0}^{K-1}2^i) + 2^K \cdot C(n-2\cdot K)&\\
\end{array}
$$
</div>
<p>Les seules valeurs de $C(n)$ connues sont celles pour $n=1$ ou $n=2$. Il faut donc appliquer notre formule pour $K=\frac{n-2}{2}$, ce qui donne l'inégalité :</p>
<div>
$$
\begin{array}{ccll}
C(n) &\geq & \mathcal{O}(1)\cdot (\sum_{i=0}^{(n-4)/2}2^i) + {(\sqrt{2})}^{n-2} \cdot C(2)&\\
\end{array}
$$
</div>
<p>La fin est facile en utilisant le fait que $\sum_{i=0}^{K}2^i = 2^{K+1} - 1$</p>
<h3>Valeur de $F(n)$</h3>
<p>On prouve la propriété par récurrence.</p>
<p>Initialisation :</p>
<ul>
<li>$F(1) = 1 = \frac{1}{\sqrt{5}}(\frac{1+\sqrt{5}}{2} - \frac{1-\sqrt{5}}{2}) = \frac{1}{\sqrt{5}}(\varphi - \frac{1}{-\varphi})$</li>
<li>$F(2) = \frac{1}{\sqrt{5}}(\varphi^2-\frac{1}{(-\varphi)^2}) = \frac{1}{\sqrt{5}}(\varphi + 1 -(\frac{1}{(-\varphi)} + 1) = \frac{1}{\sqrt{5}}(\varphi + \frac{1}{\varphi}) = F(1)$</li>
</ul>
<p>On suppose la propriété vrai jusqu'à $n-1$. Pour $n$ :</p>
<p>$F(n) = F(n-1) + F(n-2) = \frac{1}{\sqrt{5}}(\varphi^{n-1}-\frac{1}{(-\varphi)^{n-1}}) + \frac{1}{\sqrt{5}}(\varphi^{n-2}-\frac{1}{(-\varphi)^{n-2}}) = \frac{1}{\sqrt{5}}(\varphi^{n-2}(1 + \varphi) - \frac{1}{(-\varphi)^{n-2}}(1+ \frac{1}{\varphi}))$</p>
<p>Comme $\varphi$ et $-\frac{1}{\varphi}$ sont les racines du polynôme $P(X) = X^2 - X -1$ on a :</p>
<p>$F(n) = \frac{1}{\sqrt{5}}(\varphi^{n-2}(\varphi^2) - \frac{1}{(-\varphi)^{n-2}}(\frac{1}{\varphi^2})) = \frac{1}{\sqrt{5}}(\varphi^n-\frac{1}{(-\varphi)^n})$</p>
<h3>Itératif</h3>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fibo_iter</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    a <span class="token operator">=</span> <span class="token number">1</span>
    b <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> rang<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        a<span class="token punctuation">,</span> b <span class="token operator">=</span> a<span class="token operator">+</span>b<span class="token punctuation">,</span> a
    <span class="token keyword">return</span> a
</code></pre>
<h3>Récursif terminal</h3>
<p>La complexité étant terminale, il y a $\mathcal{O}(n)$ appels récursifs. Comme le reste de la fonction est en $\mathcal{O}(1)$ la complexité totale est en $\mathcal{O}(n)$.</p>
<p>Le fait que la fonction calcule bien la suite de Fibonacci se fait par récurrence. On va montrer par récurrence que <code>fibo_rec2(n, a, b)</code> rend la valeur de la suite pour $F(1) = b$ et $F(2) = a$.</p>
<ul>
<li>Initialisation : <code>fibo_rec2(1, a, b) = b</code> et <code>fibo_rec2(2, a, b) = a</code></li>
<li>On suppose la propriété vraie pour <code>fibo_rec2(n-1, a, b)</code>. Comme <code>fibo_rec2(n, a, b) = fibo_rec2(n-1,a+b , a)</code>, la propriété est vérifiée.</li>
</ul>
<h2>Noob trap</h2>
<p>C'est bien la troisième proposition qui est la bonne !</p>
<p>La troisième ligne de l'algorithme a pour complexité :</p>
<ul>
<li>le calcul de $f(n//2)$</li>
<li>le calcul de $f(n//4)$</li>
<li>la multiplication des deux valeurs obtenues</li>
</ul>
<p>En reprenant ce que l'on a fait pour Fibonacci, on a l'inégalité :</p>
<div>
$$
C(n) \leq \mathcal{O}(1) + 2 \cdot C(n/2)
$$
</div>
<p>Ce qui donne en réitérant cette inégalité :</p>
<div>
$$
C(n) \leq \mathcal{O}(1)(\sum_{i=0}^K2^i) + 2^K \cdot C(n/2^K)
$$
</div>
<p>Comme la seule complexité que l'on connait est $C(1) = \mathcal{O}(1)$, on doit prendre $K$ tel que $2^K \simeq n$, c'est à dire $k = \log_2(n)$. On a alors :</p>
<div>
$$
C(n) \leq \mathcal{O}(1)(\sum_{i=0}^{\log_2(n)}2^i) + 2^{\log_2(n)} \cdot C(1)
$$
</div>
<p>Et donc :</p>
<div>
$$
C(n) \leq \mathcal{O}(1)(2^{\log_2(n) +1}) + 2^{\log_2(n)} \cdot C(1)
$$
</div>
<p>Et comme $2^{\log_2(n)} = n$, on trouve bien $C(n) \leq \mathcal{O}(n)$.</p>
<h2>Tours de Hanoï</h2>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://fr.wikipedia.org/wiki/Tours_de_Hano%C3%AF">Tours de Hanoï sur Wikipédia</a></p>
</div>
</div>
<p>On suppose que l'on a les trois emplacements de tours A, B et C ; et que l'on veuille déplacer les disques de la tours A vers la tour C.</p>
<ol>
<li>pour pouvoir déplacer le plus grand disque de la tour A, il faut avoir déplacé tous les disques au-dessus de lui. Comme c'est le plus grand disque, il est de plus seul sur son emplacement</li>
<li>une fois le plus grand disque seul sur sa tour, il faut le déplacer en C. Ceci n'est possible que si tous les autres disques sont en B. Il donc de plus qu'ils forment une tour</li>
<li>une fois le plus grand disque à sa place, il convient de déplacer la tour formée des autres disques, en B, sur l'emplacement C.</li>
</ol>
<p>Donc si on possède un algorithme optimal, disons <code class="language-">hanoï(départ, arrivée, intermédiaire, n-1)</code> pour une tour de taille $n-1$, alors l'algorithme optimal pour déplacer une tour de taille $n$ de A à C sera :</p>
<ol>
<li><code class="language-">hanoï(A, B, C, n-1)</code></li>
<li>déplace le disque restant en A sur l'emplacement C</li>
<li><code class="language-">hanoï(B, C, A, n-1)</code></li>
</ol>
<p>On obtient alors l'algorithme optimal suivant, en considérant que les tours sont des listes :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">A <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
B <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
C <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token keyword">def</span> <span class="token function">hanoi</span><span class="token punctuation">(</span>départ<span class="token punctuation">,</span> arrivée<span class="token punctuation">,</span> intermédiaire<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    hanoi<span class="token punctuation">(</span>départ<span class="token punctuation">,</span> intermédiaire<span class="token punctuation">,</span> arrivée<span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    disque <span class="token operator">=</span> départ<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
    arrivée<span class="token punctuation">.</span>append<span class="token punctuation">(</span>disque<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span>
    hanoi<span class="token punctuation">(</span>intermédiaire<span class="token punctuation">,</span> arrivée<span class="token punctuation">,</span> départ<span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span>
hanoi<span class="token punctuation">(</span>A<span class="token punctuation">,</span> C<span class="token punctuation">,</span> B<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>On a montré que notre stratégie était optimale. Comptons le nombre d'appels récursif. Il suit l'équation de récurrence :</p>
<div>
$$
C(n) = 2 + C(n-1) + C(n-1) = 2 + 2\cdot C(n-1)
$$
</div>
<p>Et la terminaison : $C(0) = 0$</p>
<p>On obtient facilement l'expression, pour $n\geq 1$ :</p>
<div>
$$
C(n) = \sum_{i=1}^n2^i + 2\cdot C(0) = \sum_{i=1}^n2^i
$$
</div>
<p>La somme des $n&gt;0$ premières puissances de 2 est à savoir facilement retrouver (c'est <a href="https://fr.wikipedia.org/wiki/S%C3%A9rie_g%C3%A9om%C3%A9trique#Terme_g%C3%A9n%C3%A9ral">une série géométrique</a>) et vaut $2^{n+1}-2$.</p>
<h2>Suppression de valeurs</h2>
<p>La structure de donnée utilisée ici est la <strong><em>liste</em></strong>. On considérera que :</p>
<ul>
<li>la création d'une liste vide se fait en $\mathcal{O}(1)$ opérations,</li>
<li>l'ajout d'un élément en fin de liste se fait en $\mathcal{O}(1)$ opérations,</li>
<li>lire un élément d'une liste se fait en $\mathcal{O}(1)$ opérations.</li>
</ul>
<h3>Suppression d'une valeur</h3>
<pre class="language-text " style="counter-reset: linenumber 0"><code class="language-text">Nom : Algorithme-1
Entrées :
    val : une valeur
    L : une liste de n valeurs
Programme :
    création d’une liste L2 vide
    pour chaque élément x de L :
        si x ≠ val :
            ajoute x à la fin de L2
    Retour L2
</code></pre>
<h4>complexité de l'algorithme 1</h4>
<p>On considère que la création d'une liste et l'ajout d'un élément en fin de liste sont des opérations en $\mathcal{O}(1)$ opérations. De là, notre algorithme est en $\mathcal{O}(n)$ opérations où $n$ st la taille de la liste <code class="language-">L</code>.</p>
<h4>preuve de l'algorithme 1</h4>
<p>L'algorithme va parcourir la liste et ajouter un à un à <code class="language-">L2</code> tous les éléments de <code class="language-">L</code> différents de <code class="language-">val</code>. Notre invariant de boucle pourrait donc être : à la fin de l'itération $i$ <code class="language-">L2</code> est la restriction de <code class="language-">L[:i]</code> aux valeurs différentes de <code class="language-">val</code>.</p>
<ul>
<li><strong>initialisation</strong> : à la fin de la première itération ($i=1$), <code class="language-">L2</code> est vide si <code class="language-">x = L[0]</code> vaut <code class="language-">val</code> et vaut <code class="language-">[x]</code> sinon. Ok.</li>
<li><strong>récurrence</strong> : On suppose la propriété vraie à la fin de l'itération $i$. L'itération $i+1$ a considéré $x = L[i]$. Notons <code class="language-">L2'</code> la valeur de <code class="language-">L2</code> à la fin de l'itération $i+1$. Au début de l'itération $i+1$, par hypothèse de récurrence, <code class="language-">L2</code> est la restriction de <code class="language-">L[:i]</code> aux valeurs différentes de <code class="language-">val</code>. La restriction de <code class="language-">L[:i+1]</code> aux valeurs différentes de <code class="language-">val</code> est alors soit égal à <code class="language-">L2</code> si <code class="language-">L[i] = val</code> soit <code class="language-">L2 + L[i]</code> sinon. C'est exactement ce que vaut <code class="language-">L2'</code>.</li>
</ul>
<p>A la fin de la dernière itération, <code class="language-">L2</code> vaut donc la restriction de <code class="language-">L[:n]</code> (avec <code class="language-">n = len(L)</code>) aux valeurs différentes de val.</p>
<h3>Suppression d'une valeur in-place</h3>
<p>On échange l'élément à supprimer avec le dernier de la liste puis on pop.</p>
<pre class="language-text " style="counter-reset: linenumber 0"><code class="language-text">Nom : Algorithme-1'
Entrées :
    val : une valeur
    L : une liste de n valeurs
Programme :
    i = 0
    k = n - 1
    tant que i <= k:
    si L[i] == val
        échange L[i] et L[k]
        supprime le dernier élément de L
        k = k - 1
    sinon:
        i = i + 1
</code></pre>
<p>La preuve et la complexité de l'algorithme 1' est identique à celle de l'algorithme 1.</p>
<h2>Suppression de doublons</h2>
<p>Même structure que pour l'exercice précédent.</p>
<p>La structure de donnée utilisée ici est la <strong><em>liste</em></strong>. On considérera que :</p>
<ul>
<li>la création d'une liste vide se fait en $\mathcal{O}(1)$ opérations,</li>
<li>l'ajout d'un élément en fin de liste se fait en $\mathcal{O}(1)$ opérations,</li>
<li>lire un élément d'une liste se fait en $\mathcal{O}(1)$ opérations.</li>
</ul>
<h3>Suppression de doublon en conservant l'ordre</h3>
<pre class="language-text " style="counter-reset: linenumber 0"><code class="language-text">Nom : Algorithme-2
Entrées :
    L : une liste de n valeurs
Programme :
    création d’une liste L2 vide
    tant que L est non vide:
        x = L[0]
        ajoute x à la fin de L2
        L = algorithme-1(L, x)
    Retour L2
</code></pre>
<h4>complexité de l'algorithme 2</h4>
<p>Commençons par compter le nombre de fois où la boucle <code class="language-">tant que</code> sera exécutée. <code class="language-">L</code> est modifiée à chaque fin de boucle <code class="language-">L = algorithme-1(L, x)</code> avec <code class="language-">x = L[0]</code>. Comme l'algorithme de la question 1 rend la restriction de de <code class="language-">L</code> aux valeurs différentes de <code class="language-">x</code>, elle va forcément être strictement plus petite (puisque <code class="language-">x=L[0]</code> il est forcément dans la liste) : la longueur de la liste diminue strictement à chaque itération, on ne peut y rentrer que la longueur de <code class="language-">L</code> initiale fois.</p>
<p>La seule ligne de l'algorithme qui n'est pas de complexité $\mathcal{O}(1)$ est : <code class="language-">L = algorithme-1(L, x)</code>. Sa complexité est égale à une affectation ($\mathcal{O}(1)$) plus la complexité de l'algorithme de la question 1, qui vaut de l'ordre de la taille de la liste passée en entrée.</p>
<p>Cette taille diminue strictement à chaque itération : on peut utiliser l'astuce du cours pour ne garder que la complexité la plus importante, c'est à dire $\mathcal{O}(len(L))$ avec <code class="language-">L</code> la liste initiale.</p>
<p>Notre complexité est donc de l'ordre : $\mathcal{O}(1) + A * (\mathcal{O}(1) + B)$ où :</p>
<ul>
<li>A est le nombre de fois où l'on rentre dans la boucle tant que : $\mathcal{O}(len(L))$</li>
<li>B est la complexité maximale de l'algorithme de la question 1 : $\mathcal{O}(len(L))$</li>
</ul>
<p>Notre algorithme est de complexité : $\mathcal{O}(len(L)^2)$</p>
<h4>preuve algorithme 2</h4>
<p>La liste <code class="language-">L</code> contient $k$ valeurs différentes que l'on note $v_1, \dots v_k$ dans l'ordre de la liste (le 1er indice où l'on rencontre $v_i$ est strictement plus petit que le 1er indice où l'on rencontre $v_j$ si $i &lt; j$).</p>
<p>Notre invariant de boucle sera : au bout de la $i$ème itération :</p>
<ul>
<li>
<p>$L2 = [v_1, \dots, v_i]$.</p>
</li>
<li>
<p><code class="language-">L</code> vaut la restriction de <code class="language-">L</code> initiale aux valeurs différentes de $v_1$ jusqu'à $v_i$.</p>
</li>
<li>
<p><strong>initialisation</strong> : comme $v_1= L[0]$ notre invariant est vrai puisque l'algorithme 1 rendra la restriction de <code class="language-">L</code> initiale aux éléments différents de $v_1$.</p>
</li>
<li>
<p><strong>récurrence</strong> : On suppose la propriété vraie à la fin de l'itération $i$. Au début de l'itération $i+1$, on a par hypothèse de récurrence que $L2 = [v_1, \dots, v_i]$ et que <code class="language-">L</code> vaut la restriction de la liste <code class="language-">L</code> initiale aux valeurs différentes de $v_1$ jusqu'à $v_i$. Donc $L[0] = v_{i+1}$ et tout se passe comme à la 1ère itération.</p>
</li>
</ul>
<p>A la fin de l'algorithme, notre invariant est toujours juste : $L2 = [v_1, \dots, v_k]$</p>
<h3>Suppression de doublon d'une liste ordonnée</h3>
<p>Il suffit de parcourir tous les éléments de <code class="language-">L</code> dans l'ordre :</p>
<pre class="language-text " style="counter-reset: linenumber 0"><code class="language-text">Nom : Algorithme-2'
Entrées :
    L : une liste de n valeurs
Programme :
    création d’une liste L2 contenant le premier élément de L
    pour i allant de 1 à n-1:
        si L[i] != L[i-1]:
            ajoute L[i] à la fin de L2
    Retour L2
</code></pre>
<h4>complexité de l'algorithme 2'</h4>
<p>Clairement en $\mathcal{O}(n)$</p>
<h4>preuve de l'algorithme 2'</h4>
<p>L'invariant de boucle et sa preuve est identique à celle de la preuve de l'algorithme 2 en tenant compte du fait que <code class="language-">L</code> est trié.</p>
<h3>Suppression de doublon d'une liste sans ordre</h3>
<p>On commence par trier la liste on utilise l'algorithme de la question précédente. Ceci fait passer la complexité de $\mathcal{O}(len(L)^2)$ à $\mathcal{O}(len(L)\log(len(L)))$</p>
<h2>Triangle de Pascal</h2>
<h3>Coefficient binomiaux récursif</h3>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">comb_rec</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">if</span> p <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token keyword">or</span> n <span class="token operator">==</span>p <span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> comb_rec<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> comb_rec<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span>
</code></pre>
<h3>Coefficient binomiaux itératif et $\mathcal{O}(n^2)$ en mémoire</h3>
<p>On stocke une matrice triangulaire inférieure que l'on construit ligne à ligne.</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">comb_iter</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>
    C <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        C<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
            c_i_j <span class="token operator">=</span> C<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> C<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            C<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>c_i_j<span class="token punctuation">)</span>

    <span class="token keyword">return</span> C<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre>
<h3>Coefficient binomiaux itératif et $\mathcal{O}(n)$ en mémoire</h3>
<p>On remarque que seule la dernière ligne est importante dans le calcul.</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">comb_iter2</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>
    C <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        C<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        r <span class="token operator">=</span> C<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>
            tempo <span class="token operator">=</span> C<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            C<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> r
            r <span class="token operator">=</span> tempo

    <span class="token keyword">return</span> C<span class="token punctuation">[</span>p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre>
<h2>Compteur binaire</h2>
<p>La complexité va dépendre du nombre d'éléments dans la liste en entré. Notons $N = len(n)$.</p>
<p>On remarque (facilement) que cette complexité vaut $C(N) = K \cdot \mathcal{O}(1)$ où $K$ est le nombre de fois où l'on rentre dans la boucle.</p>
<ul>
<li>complexité max : parcourt toute la liste (pour une liste uniquement constituée): $\mathcal{O}(N)$</li>
<li>complexité min : parcourt 1 seul élément de la liste (pour une liste se terminant par un 0): $\mathcal{O}(1)$</li>
</ul>
<p>Séparons les $2^N$ nombres possibles en classes selon le nombre d'itérations dans la boucle :</p>
<ul>
<li>dernier élément vaut 0 : 0 itération. Vrai pour $2^N/2$ nombres. Probabilité de 1/2.</li>
<li>derniers éléments valent <code class="language-">[0, 1]</code> : 1 itération. Vrai pour $(2^N/2)/2 = 2^N/4$ nombres. Probabilité de 1/4.</li>
<li>derniers éléments valent <code class="language-">[0, 1, 1]</code> : 2 itérations. Vrai pour $(2^N/4)/2 = 2^N/8$ nombres. Probabilité de 1/8.</li>
<li>...</li>
<li>derniers éléments valent <code class="language-">[0] + i *[1]</code> : i itérations. Vrai pour $(2^N/4)/2 = 2^N/2^{i+1}$ nombres. Probabilité de 1/2^{i+1}.</li>
<li>le premier élément vaut 0 et tous les autres valent 1 : $N-1$ itérations Vrai pour 1 nombre. Probabilité de 1/2^{N}.</li>
</ul>
<p>Le nombre moyen d'itérations dans la boucle vaut alors :</p>
<div>
$$
W_\text{moy}(N) = \mathcal{O}(1) \cdot \sum_{i=0}^{N-1} i \cdot \frac{1}{2^{i+1}}
$$
</div>
<h3>Vérification expérimentale</h3>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">successeur</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    K <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token keyword">while</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token keyword">and</span> <span class="token punctuation">(</span>n<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        K <span class="token operator">+=</span> <span class="token number">1</span>

        n<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
        i <span class="token operator">-=</span> <span class="token number">1</span>

    <span class="token keyword">if</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">:</span>
        n<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>

    <span class="token keyword">return</span> K


<span class="token keyword">def</span> <span class="token function">tous</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>

    n <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> N
    total <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>
        total <span class="token operator">+=</span> successeur<span class="token punctuation">(</span>n<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>

    <span class="token keyword">return</span> total <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">**</span> N


x <span class="token operator">=</span> tous<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>

</code></pre>
<h2>Cols</h2>
<h3>Existence</h3>
<p>On donne trois preuves possibles</p>
<h4>En reprenant la définition</h4>
<p>Si la première condition ($i=0$) est vérifiée, le tableau contient un col. On la suppose donc non vérifiée : $T[0] &gt; T[1]$. De même, si la seconde condition ($i=n-1$) est vérifiée, le tableau contient également un col. Supposons la donc également non vérifiée : $T[n-2] &lt; T[n-1]$.</p>
<p>Les deux conditions précédentes montrent qu'il existe $n-1 &gt; i^\star &gt; 0$ le plus petit indice tel que $T[i^\star] \leq T[i^\star +1]$. On a alors : $T[i^\star -1] &gt; T[i^\star ] \leq T[i^\star +1]$ et $i^\star$ est un col.</p>
<h4>Une astuce</h4>
<p>Un tableau d'entier possède forcément un élément minimum. Il existe donc $i^\star$ tel que $T[i^\star] \leq T[i]$ pour tout $0 \leq i &lt; n$. De là :</p>
<ul>
<li>soit $i^\star = 0$ et $T[i^\star] \leq T[1]$</li>
<li>soit $i^\star = n-1$ et $T[i^\star] \leq T[n-2]$</li>
<li>soit $0 &lt; i^\star &lt; n-1$ et $T[i^\star] \leq \min(T[i^\star-1], T[i^\star+1])$</li>
</ul>
<p>Simple et efficace, non ?</p>
<h4>Par récurrence</h4>
<p>On montre par récurrence sur la taille $n$ du tableau qu'il existe toujours un col.</p>
<ol>
<li>Initialisation. Si $n=2$ soit $T[0] \leq T[1]$ soit $T[0] \geq T[1]$ (ce qui est équivalent pour $n=2$ à $T[n-1] \leq T[n-2]$). Ces deux cas correspondent aux deux premières possibilités pour un col</li>
<li>on suppose la propriété vrai pour $n \geq 2$. Et on se donne un tableau $T$ de taille $n+1$.</li>
<li>l'hypothèse de récurrence stipule que le tableau $T'$ constitué des $n$ premières cases de $T$ ($T'= T[:-1]$) possède un col, disons à l'indice $i^\star$. 3 cas sont possibles :
<ol>
<li>$i^\star = 0$ et $T'[0] \leq T'[1]$ ce qui implique $T[0] \leq T[1]$ : $i^\star$ est aussi un col pour $T$</li>
<li>$0 &lt; i^\star &lt; n-1$ et $T'[i^\star] \leq \min(T'[i-1], T'[i+1])$ ce qui implique $T[i^\star] \leq \min(T[i^\star-1], T[i^\star+1])$ : $i^\star$ est aussi un col pour $T$</li>
<li>$i^\star = n-1$ et $T'[n-1] \leq T'[n-2]$ ce qui implique $T[n-1] \leq T[n-2]$. On conclut en remarquant que :
<ol>
<li>soit $T[n] \geq T[n-1]$ et $T[i^\star] \leq \min(T[i^\star-1], T[i^\star+1])$ : $i^\star$ est aussi un col pour $T$</li>
<li>soit $T[n] &lt; T[n-1]$ et $n$ est un col pour $T$.</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3>Découverte</h3>
<p>La preuve de la 1ère question montrant qu'il existe forcément un col, l'algorithme suivant qui mime directement la définition (lignes 2-3 : 1ère condition, lignes 5-6 : 2ème condition et lignes 8-10 la troisième condition) trouvera forcément un col :</p>
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">trouve</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> T<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">0</span>

    <span class="token keyword">if</span> T<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> T<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>T<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> T<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> i

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Sa complexité dans le cas le pire a lieu pour les tableaux dont le premier et seul col se trouve à l'avant dernier indice (comme pour la liste $[5, 4, 3, 2, 1, 2]$ par exemple), forçant l'algorithme à :</p>
<ul>
<li>faire échouer le 1er test de la ligne 2 en $\mathcal{O}(1)$ opérations</li>
<li>faire échouer le 2er test de la ligne 5 en $\mathcal{O}(1)$ opérations</li>
<li>faire les $\mathcal{O}(n)$ itérations de la boucle for en :
<ul>
<li>faisant échouer tous les tests sauf le dernier $\mathcal{O}(1)$ opérations</li>
<li>réussissant le dernier test et en faisant un retour de fonction en $\mathcal{O}(1)$ opérations</li>
</ul>
</li>
</ul>
<p>La complexité totale maximale est alors :</p>
<p>$$<br>
C(n) = \mathcal{O}(1) + \mathcal{O}(1) + \mathcal{O}(n) \cdot (\mathcal{O}(1) + \mathcal{O}(1)) = \mathcal{O}(n)<br>
$$</p>
<p>On peut aussi utiliser la preuve précédente et <em>simplifier</em> la boucle <code class="language-">for</code> en gardant la même complexité :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">trouve</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> T<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">0</span>

    <span class="token keyword">if</span> T<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> T<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> T<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> i

</code></pre>
<h3>Rapidité</h3>
<p>La preuve d'existence du 1 montre que pour tout $i + 1 &lt; j$, si $T[i] &gt; T[i+1]$ et $T[j] &gt; T[j-1]$, alors il existe un indice $i &lt; k &lt; j$ tel que $k$ soit un col de la matrice.</p>
<p>L'invariant de boucle de la boucle <code class="language-">while</code> est alors :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>invariant</strong></p>
</div><div class="pl-8 mr-8">
<p>A la fin de chaque itération de la boucle <code class="language-">while</code>, soit :</p>
<ul>
<li><code class="language-">T[milieu]</code> est un col</li>
<li><code class="language-">T[milieu]</code> n'est pas un col et :
<ul>
<li><code class="language-">début + 1 &lt; fin</code></li>
<li><code class="language-">T[début] &gt; T[début+1]</code> et <code class="language-">T[fin] &gt; T[fin-1]</code></li>
</ul>
</li>
</ul>
</div>
</div>
<p>A la fin de la première itération, on a soit :</p>
<ul>
<li><code class="language-">T[milieu] &lt;= min(T[milieu - 1], T[milieu + 1])</code> et <code class="language-">milieu</code> est un col</li>
<li><code class="language-">fin' = milieu</code> et <code class="language-">début' = début</code> si <code class="language-">T[milieu] &gt; T[milieu -1]</code>. Comme initialement <code class="language-">0 = début + 1 &lt; fin = len(T) - 1</code> on a également <code class="language-">milieu - 1 &gt; début</code> puisque <code class="language-">T[0] &gt; T[1]</code> et l'invariant est vérifié.</li>
<li><code class="language-">fin' = fin</code> et <code class="language-">début' = milieu</code> si <code class="language-">T[milieu] &lt;= T[milieu -1]</code> et <code class="language-">T[milieu] &gt; T[milieu + 1]</code>. Comme <code class="language-">0 = début + 1 &lt; fin = len(T) - 1</code> on a également <code class="language-">milieu + 1 &lt; fin</code> puisque <code class="language-">T[-1] &gt; T[-2]</code> et l'invariant est vérifié.</li>
</ul>
<p>La même démonstration fonctionne à l'identique à la fin de l'itération $i+1$ si l'invariant est vrai à la fin de l'itération $i$.</p>
<p>Comme <code>fin - début &gt;= 0</code> et diminue strictement à chaque itération de la boucle <code class="language-">while</code>, il arrivera <strong>forcément</strong> un moment où <code class="language-">milieu</code> sera un col.</p>
<h3>Complexité</h3>
<p>La procédure de la boucle <code class="language-">while</code> est identique à la recherche dichotomique puisque l'on se place toujours au milieu de l'espace de recherche. Le cours nous indiquant que la complexité de la recherche dichotomique est $\mathcal{O}(\log_2(n)) = \mathcal{O}(\ln(n))$, on en conclut que l'algorithme <code class="language-">trouve_vite(T)</code> est également en $\mathcal{O}(\ln(n))$ opérations.</p>
<h3>Complexité du problème</h3>
<p>Il existe des tableaux ayant tous un unique col en position $i$ pour tout $0 \leq i &lt; n$ (prenez les tableaux $[0, -1, \dots, -i, -i+1, -i +2, \dots, -i + (n - i - 1)]$). Tout algorithme trouvant les col des tableaux doit donc pouvoir distinguer parmi $n$ cas : il est au moins de complexité $\mathcal{O}(\log_2(n)) = \mathcal{O}(\ln(n))$.</p>
<p>Comme l'algorithme <code class="language-">trouve_vite(T)</code> est de complexité $\mathcal{O}(\ln(n))$, c'est borne min est atteinte.</p>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>