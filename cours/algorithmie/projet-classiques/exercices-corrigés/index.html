<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Corrigé</title>

    <link href="/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet">
    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">

    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Corrigé</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/">Algorithmie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/projet-classiques/">Algorithmes classiques</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/projet-classiques/exercices-corrigés/">Corrigé</a>

</div>
</div>


    
  

  <h2>Récursion et complexité</h2>
<p>On considère le code suivant :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">ma_fonction</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">2</span>
    <span class="token keyword">return</span> ma_function<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> ma_fonction<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span>
</code></pre>
<h3>Complexité de l'algorithme</h3>
<p>En notant $C(n)$ la complexité de la fonction, on a l'équation de récurrence suivante :</p>
<div>
$$
C(n) = \mathcal{O}(1) + C(n-1) + C(n-4)
$$
</div>
<p>Et la condition limite : $C(n) = \mathcal{O}(1)$ pour $n &lt; 5$.</p>
<p>L'équation montre alors clairement que :</p>
<div>
$$
\mathcal{O}(1) + C(n-4) + C(n-4) \leq C(n) \leq \mathcal{O}(1) + C(n-1) + C(n-1)= \mathcal{O}(1) + 2 \cdot C(n-1)
$$
</div>
<p>Ce qui donne :</p>
<div>
$$
K \cdot \mathcal{O}(1) + 2^K \cdot C(n-4\cdot K) \leq C(n) \leq K \cdot \mathcal{O}(1) + 2^K \cdot C(n-K)
$$
</div>
<p>Et donc que $C(n) = \Omega(2^n)$.</p>
<h3>Version itérative</h3>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">ma_fonction</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    C <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        C <span class="token operator">=</span> <span class="token punctuation">[</span>C<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> C<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> C<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>

    <span class="token keyword">return</span> C<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
</code></pre>
<p>La complexité est en $\mathcal{O}(n)$ car elle ne recalcule jamais deux fois la même chose.</p>
<h2>Tours de Hanoï</h2>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://fr.wikipedia.org/wiki/Tours_de_Hano%C3%AF">Tours de Hanoï sur Wikipédia</a></p>
</div>
</div>
<p>On suppose que l'on a les trois emplacements de tours A, B et C ; et que l'on veuille déplacer les disques de la tours A vers la tour C.</p>
<ol>
<li>pour pouvoir déplacer le plus grand disque de la tour A, il faut avoir déplacé tous les disques au-dessus de lui. Comme c'est le plus grand disque, il est de plus seul sur son emplacement</li>
<li>une fois le plus grand disque seul sur sa tour, il faut le déplacer en C. Ceci n'est possible que si tous les autres disques sont en B. Il donc de plus qu'ils forment une tour</li>
<li>une fois le plus grand disque à sa place, il convient de déplacer la tour formée des autres disques, en B, sur l'emplacement C.</li>
</ol>
<p>Donc si on possède un algorithme optimal, disons <code class="language-">hanoï(départ, arrivée, intermédiaire, n-1)</code> pour une tour de taille $n-1$, alors l'algorithme optimal pour déplacer une tour de taille $n$ de A à C sera :</p>
<ol>
<li><code class="language-">hanoï(A, B, C, n-1)</code></li>
<li>déplace le disque restant en A sur l'emplacement C</li>
<li><code class="language-">hanoï(B, C, A, n-1)</code></li>
</ol>
<p>On obtient alors l'algorithme optimal suivant, en considérant que les tours sont des listes :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">A <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
B <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
C <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token keyword">def</span> <span class="token function">hanoi</span><span class="token punctuation">(</span>départ<span class="token punctuation">,</span> arrivée<span class="token punctuation">,</span> intermédiaire<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span>
    hanoi<span class="token punctuation">(</span>départ<span class="token punctuation">,</span> intermédiaire<span class="token punctuation">,</span> arrivée<span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    disque <span class="token operator">=</span> départ<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>
    arrivée<span class="token punctuation">.</span>append<span class="token punctuation">(</span>disque<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span>
    hanoi<span class="token punctuation">(</span>intermédiaire<span class="token punctuation">,</span> arrivée<span class="token punctuation">,</span> départ<span class="token punctuation">,</span> n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span>
hanoi<span class="token punctuation">(</span>A<span class="token punctuation">,</span> C<span class="token punctuation">,</span> B<span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>On a montré que notre stratégie était optimale. Comptons le nombre d'appels récursif. Il suit l'équation de récurrence :</p>
<div>
$$
C(n) = 2 + C(n-1) + C(n-1) = 2 + 2\cdot C(n-1)
$$
</div>
<p>Et la terminaison : $C(0) = 0$</p>
<p>On obtient facilement l'expression, pour $n\geq 1$ :</p>
<div>
$$
C(n) = \sum_{i=1}^n2^i + 2\cdot C(0) = \sum_{i=1}^n2^i
$$
</div>
<p>La somme des $n&gt;0$ premières puissances de 2 est à savoir facilement retrouver (c'est <a href="https://fr.wikipedia.org/wiki/S%C3%A9rie_g%C3%A9om%C3%A9trique#Terme_g%C3%A9n%C3%A9ral">une série géométrique</a>) et vaut $2^{n+1}-2$.</p>
<h2>Polynômes</h2>
<p>L'exercice portait sur la structure de <a href="https://fr.wikipedia.org/wiki/Polyn%C3%B4me">polynômes</a>.</p>
<p>Un polynôme est défini mathématiquement par la fonction :</p>
<p>$$<br>
P(x) = \sum_{i=0}^n a_i x^i<br>
$$</p>
<p>Et informatiquement par une liste à $n+1$ éléments.</p>
<p>$$<br>
[a_0, \dots, a_n]<br>
$$</p>
<h3>$P(x) + Q(x)$</h3>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">somme</span><span class="token punctuation">(</span>coefficients1<span class="token punctuation">,</span> coefficients2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    longueur1 <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>coefficients1<span class="token punctuation">)</span>
    longueur2 <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>coefficients2<span class="token punctuation">)</span>

    résultat <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">max</span><span class="token punctuation">(</span>longueur1<span class="token punctuation">,</span> longueur2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        résultat<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>longueur1<span class="token punctuation">)</span><span class="token punctuation">:</span>
        résultat<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> coefficients1<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>longueur2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        résultat<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> coefficients2<span class="token punctuation">[</span>i<span class="token punctuation">]</span>

    <span class="token keyword">return</span> résultat

</code></pre>
<h3>$P(x) \cdot Q(x)$</h3>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">produit</span><span class="token punctuation">(</span>coefficients1<span class="token punctuation">,</span> coefficients2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    longueur1 <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>coefficients1<span class="token punctuation">)</span>
    longueur2 <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>coefficients2<span class="token punctuation">)</span>

    résultat <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

    <span class="token keyword">for</span> k <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>longueur1 <span class="token operator">+</span> longueur2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        i <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>longueur1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span>
        j <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>k <span class="token operator">-</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>

        valeur_k <span class="token operator">=</span> <span class="token number">0</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> longueur2<span class="token punctuation">)</span><span class="token punctuation">:</span>
            valeur_k <span class="token operator">+=</span> coefficients1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> coefficients2<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            i <span class="token operator">-=</span> <span class="token number">1</span>
            j <span class="token operator">+=</span> <span class="token number">1</span>
        résultat<span class="token punctuation">.</span>append<span class="token punctuation">(</span>valeur_k<span class="token punctuation">)</span>

    <span class="token keyword">return</span> résultat

</code></pre>
<h3>$P(A)$</h3>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">valeur</span><span class="token punctuation">(</span>coefficients<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>
    résultat <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>coefficients<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        résultat <span class="token operator">+=</span> coefficients<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> x <span class="token operator">**</span> i
    <span class="token keyword">return</span> résultat

</code></pre>
<p>En utilisant l'exponentiation rapide, le calcul de $x^i$ prend $\log(i)$ multiplications. On effectue donc au total de l'ordre $n\log(n)$ multiplications pour calculer tous les $x^i$, $0 \leq i \leq n$.</p>
<h3>Méthode de Horner</h3>
<p>L'optimisation proposée est dite <a href="https://fr.wikipedia.org/wiki/M%C3%A9thode_de_Ruffini-Horner#Valeur_d'un_polyn%C3%B4me_en_un_point">de Horner</a>. Comme beaucoup d'optimisation, elle cherche à ne pas recalculer plein de fois la même chose, ici $x^i$ dans le calcul de $x^k$ lorsque $i &lt; j$.</p>
<p>En utilisant l'optimisation de Horner, on effectue au total de l'ordre $n$ multiplications pour calculer tous les $x^i$, $0 \leq i \leq n$.<br>
i</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">evaluation</span><span class="token punctuation">(</span>P<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token builtin">eval</span> <span class="token operator">=</span> P<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token builtin">eval</span> <span class="token operator">=</span> P<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> v <span class="token operator">*</span> <span class="token builtin">eval</span>

    <span class="token keyword">return</span> <span class="token builtin">eval</span>
</code></pre>
<h2>Suppression de valeurs</h2>
<p>La structure de donnée utilisée ici est la <strong><em>liste</em></strong>. On considérera que :</p>
<ul>
<li>la création d'une liste vide se fait en $\mathcal{O}(1)$ opérations,</li>
<li>l'ajout d'un élément en fin de liste se fait en $\mathcal{O}(1)$ opérations,</li>
<li>lire un élément d'une liste se fait en $\mathcal{O}(1)$ opérations.</li>
</ul>
<h3>Suppression d'une valeur</h3>
<pre class="language-text " style="counter-reset: linenumber 0"><code class="language-text">Nom : Algorithme-1
Entrées :
    val : une valeur
    L : une liste de n valeurs
Programme :
    création d’une liste L2 vide
    pour chaque élément x de L :
        si x ≠ val :
            ajoute x à la fin de L2
    Retour L2
</code></pre>
<h4>complexité</h4>
<p>On considère que la création d'une liste et l'ajout d'un élément en fin de liste sont des opérations en $\mathcal{O}(1)$ opérations. De là, notre algorithme est en $\mathcal{O}(n)$ opérations où $n$ st la taille de la liste <code class="language-">L</code>.</p>
<h4>preuve</h4>
<p>L'algorithme va parcourir la liste et ajouter un à un à L2 tous les éléments de <code class="language-">L</code> différents de <code class="language-">val</code>. Notre invariant de boucle pourrait donc être : à la fin de l'itération $i$ L2 est la restriction de <code class="language-">L[:i]</code> aux valeurs différentes de <code class="language-">val</code>.</p>
<ul>
<li><strong>initialisation</strong> : à la fin de la première itération ($i=1$), <code class="language-">L2</code> est vide si <code class="language-">x = L[0]</code> vaut <code class="language-">val</code> et vaut <code class="language-">[x]</code> sinon. Ok.</li>
<li><strong>récurrence</strong> : On suppose la propriété vraie à la fin de l'itération $i$. L'itération $i+1$ a considéré $x = L[i]$. Notons <code class="language-">L2'</code> la valeur de <code class="language-">L2</code> à la fin de l'itération $i+1$. Au début de l'itération $i+1$, par hypothèse de récurrence, <code class="language-">L2</code> est la restriction de <code class="language-">L[:i]</code> aux valeurs différentes de <code class="language-">val</code>. La restriction de <code class="language-">L[:i+1]</code> aux valeurs différentes de <code class="language-">val</code> est alors soit égal à <code class="language-">L2</code> si <code class="language-">L[i] = val</code> soit <code class="language-">L2 + L[i]</code> sinon. C'est exactement ce que vaut <code class="language-">L2'</code>.</li>
</ul>
<p>A la fin de la dernière itération, <code class="language-">L2</code> vaut donc la restriction de <code class="language-">L[:n]</code> (avec <code class="language-">n = len(L)</code>) aux valeurs différentes de val.</p>
<h3>Suppression d'une valeur in-place</h3>
<blockquote>
<p>TBD</p>
</blockquote>
<p>On échange l'élément à supprimer avec le dernier de la liste puis on pop.</p>
<h2>Suppression de doublons</h2>
<p>Même structure que pour l'exercice précédent.</p>
<p>La structure de donnée utilisée ici est la <strong><em>liste</em></strong>. On considérera que :</p>
<ul>
<li>la création d'une liste vide se fait en $\mathcal{O}(1)$ opérations,</li>
<li>l'ajout d'un élément en fin de liste se fait en $\mathcal{O}(1)$ opérations,</li>
<li>lire un élément d'une liste se fait en $\mathcal{O}(1)$ opérations.</li>
</ul>
<h3>Suppression de doublon en conservant l'ordre</h3>
<pre class="language-text " style="counter-reset: linenumber 0"><code class="language-text">Nom : Algorithme-2
Entrées :
    L : une liste de n valeurs
Programme :
    création d’une liste L2 vide
    tant que L est non vide:
        x = L[0]
        ajoute x à la fin de L2
        L = algorithme-1(L, x)
    Retour L2
</code></pre>
<h4>complexité algorithme 2</h4>
<p>Commençons par compter le nombre de fois où la boucle <code class="language-">tant que</code> sera exécutée. <code class="language-">L</code> est modifiée à chaque fin de boucle <code class="language-">L = algorithme-1(L, x)</code> avec <code class="language-">x = L[0]</code>. Comme l'algorithme de la question 1 rend la restriction de de <code class="language-">L</code> aux valeurs différentes de <code class="language-">x</code>, elle va forcément être strictement plus petite (puisque <code class="language-">x=L[0]</code> il est forcément dans la liste) : la longueur de la liste diminue strictement à chaque itération, on ne peut y rentrer que la longueur de <code class="language-">L</code> initiale fois.</p>
<p>La seule ligne de l'algorithme qui n'est pas de complexité $\mathcal{O}(1)$ est : <code class="language-">L = algorithme-1(L, x)</code>. Sa complexité est égale à une affectation ($\mathcal{O}(1)$) plus la complexité de l'algorithme de la question 1, qui vaut de l'ordre de la taille de la liste passée en entrée.</p>
<p>Cette taille diminue strictement à chaque itération : on peut utiliser l'astuce du cours pour ne garder que la complexité la plus importante, c'est à dire $\mathcal{O}(len(L))$ avec <code class="language-">L</code> la liste initiale.</p>
<p>Notre complexité est donc de l'ordre : $\mathcal{O}(1) + A * (\mathcal{O}(1) + B)$ où :</p>
<ul>
<li>A est le nombre de fois où l'on rentre dans la boucle tant que : $\mathcal{O}(len(L))$</li>
<li>B est la complexité maximale de l'algorithme de la question 1 : $\mathcal{O}(len(L))$</li>
</ul>
<p>Notre algorithme est de complexité : $\mathcal{O}(len(L)^2)$</p>
<h4>preuve algorithme 2</h4>
<p>La liste <code class="language-">L</code> contient $k$ valeurs différentes que l'on note $v_1, \dots v_k$ dans l'ordre de la liste (le 1er indice où l'on rencontre $v_i$ est strictement plus petit que le 1er indice où l'on rencontre $v_j$ si $i &lt; j$).</p>
<p>Notre invariant de boucle sera : au bout de la $i$ème itération :</p>
<ul>
<li>
<p>$L2 = [v_1, \dots, v_i]$.</p>
</li>
<li>
<p><code class="language-">L</code> vaut la restriction de <code class="language-">L</code> initiale aux valeurs différentes de $v_1$ jusqu'à $v_i$.</p>
</li>
<li>
<p><strong>initialisation</strong> : comme $v_1= L[0]$ notre invariant est vrai puisque l'algorithme 1 rendra la restriction de <code class="language-">L</code> initiale aux éléments différents de $v_1$.</p>
</li>
<li>
<p><strong>récurrence</strong> : On suppose la propriété vraie à la fin de l'itération $i$. Au début de l'itération $i+1$, on a par hypothèse de récurrence que $L2 = [v_1, \dots, v_i]$ et que <code class="language-">L</code> vaut la restriction de la liste <code class="language-">L</code> initiale aux valeurs différentes de $v_1$ jusqu'à $v_i$. Donc $L[0] = v_{i+1}$ et tout se passe comme à la 1ère itération.</p>
</li>
</ul>
<p>A la fin de l'algorithme, notre invariant est toujours juste : $L2 = [v_1, \dots, v_k]$</p>
<h3>Suppression de doublon d'une liste ordonnée</h3>
<blockquote>
<p>TBD : on ajoute l'élément que s'il est différent de celui d'avant</p>
</blockquote>
<h3>Suppression de doublon d'une liste sans ordre</h3>
<blockquote>
<p>TBD</p>
</blockquote>
<p>On commence par trier puis on supprime</p>
<h2>Min et max d'un tableau d'entiers</h2>
<blockquote>
<p>TBD</p>
</blockquote>
<p>Si on fait les deux à la suite on a 2n comparaisons.</p>
<p>On commence par trier les éléments $T[i]$ et $T[i+1]$ pour tout $i$ ($n/2$ comparaisons)</p>
<p>Puis on cherche le min sur les $T[[2i]$ ($n/2$ comparaisons) et le max sur les $T[[2i +1]$ ($n/2$ comparaisons)</p>
<h2>Suite de Fibonacci</h2>
<h3>Récursif</h3>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">
<span class="token keyword">def</span> <span class="token function">fibo_rec_1</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> fibo_rec<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> fibo_rec<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre>
<h3>Itératif</h3>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fibo_iter</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    a <span class="token operator">=</span> <span class="token number">1</span>
    b <span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> rang<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        a<span class="token punctuation">,</span> b <span class="token operator">=</span> a<span class="token operator">+</span>b<span class="token punctuation">,</span> a
    <span class="token keyword">return</span> a
</code></pre>
<h3>Récursif terminal</h3>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fibo_rec2</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> a
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> fibo_rec2<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> a<span class="token operator">+</span>b<span class="token punctuation">,</span> a<span class="token punctuation">)</span>
</code></pre>
<h2>Triangle de Pascal</h2>
<p>Pour $n &gt; p &gt; 0$ :</p>
<div>
$$
C(n, p) = C(n-1, p-1) + C(n-1, p)
$$
</div>
<p>et $C(n, 1) = C(n, n) = 1$</p>
<h3>Récursif</h3>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">comb_rec</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">if</span> p <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token keyword">or</span> n <span class="token operator">==</span>p <span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> comb_rec<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> comb_rec<span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span>
</code></pre>
<h3>Itératif et $\mathcal{O}(n^2)$ en mémoire</h3>
<p>On stocke une matrice triangulaire inférieure. C</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">comb_iter</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>
    C <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        C<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>
            c_i_j <span class="token operator">=</span> C<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> C<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            C<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>c_i_j<span class="token punctuation">)</span>

    <span class="token keyword">return</span> C<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre>
<h3>Itératif et $\mathcal{O}(n)$ en mémoire</h3>
<p>On remarque que seule la dernière ligne est importante dans le calcul.</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">comb_iter2</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">:</span>
    C <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        C<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
        r <span class="token operator">=</span> C<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>
            tempo <span class="token operator">=</span> C<span class="token punctuation">[</span>j<span class="token punctuation">]</span>
            C<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> r
            r <span class="token operator">=</span> tempo

    <span class="token keyword">return</span> C<span class="token punctuation">[</span>p<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
</code></pre>
<blockquote>
<p>TBD : un dessin</p>
</blockquote>
<h2>Ackermann</h2>
<p>La fonction d'Ackermann se définit de la manière suivante, pour tous entiers $m$ et $n$ positifs :</p>
<div>
$$
A(m,n) =
\left\{
\begin{array}{lll}
 & n + 1 &\mbox{ si } m = 0\\
& A(m - 1, 1) &\mbox{ si } n = 0, m>0\\
& A(m - 1, A(m, n - 1)) &\mbox{ sinon }\\
\end{array}
\right.
$$
</div>
<ul>
<li>Donnez un pseudo-code récursif et itératif de cette fonction.</li>
<li>Donnez le nombres d'appels récursif du calcul de A(n, n).</li>
</ul>
<blockquote>
<p>TBD calculs de A(m, n) avec les puissances itérées de Knuth.</p>
</blockquote>
<h2>Méthodes de tri</h2>
<h3>Tri par base</h3>
<p>Ce tri s'applique uniquement aux entiers positifs, que l'on considère écrits en base 2. Le principe de ce tri est très simple :</p>
<ul>
<li>On considère d'abord le bit de poids le plus faible (<em>ie.</em> le plus à droite) et on répartit l'ensemble à trier en deux sous ensembles :
<ul>
<li>les entiers dont le bit de poids le plus faible est 0</li>
<li>les entiers dont le bit de poids le plus faible est 1</li>
</ul>
</li>
<li>On concatène les deux sous-ensembles, en commençant par celui des bits à 0.</li>
<li>On recommence sur le bit à gauche de celui qu'on vient de traiter.</li>
<li>...</li>
</ul>
<p>Les parcours d'ensembles se font, toujours, de la gauche vers la droite.</p>
<p>Donnez le pseudo-code, la preuve et la complexité de cet algorithme (on supposera que l'on dispose d'une fonction qui, étant donnés deux entiers $n$ et $i$, donne le $i^{me}$ bit de $n$).</p>
<p>Rappelez la complexité minimale du tri (dans le cas le pire). Commentaires.</p>
<h3>Tri par monotonies</h3>
<p>Étant donné un tableau $T$, <strong><em>une monotonie</em></strong> est une suite croissante maximale d'éléments consécutifs de $T$. Par exemple :<br>
si $T = [2,6, 1,3, 3, 5,2,6, 4,0, 1,8,9,1,3, 2,0,1,0]$, alors $[2,6]$, $[1,3,3,5]$, $[2,6]$, $[4]$, $[0, 1,8,9]$, $[1,3]$, $[2]$, $[0,1]$ et $[0]$ sont les monotonies de $T$.</p>
<p>Donnez un algorithme qui, étant donné un tableau $T$ construit une liste (de listes) $L$, chaque élément de $L$ étant une monotonie de $T$ (et vice versa). À partir de notre exemple, on obtient :<br>
$L = [[2,6], [1,3,3,5],[2,6], [4], [0, 1,8,9], [1,3], [2] ,[0,1], [0]]$.</p>
<p>Donnez un algorithme qui fusionne deux monotonies ; par exemple, à partir de $[2,6]$ et $[1,3,3,5]$, on obtient $[1,2,3,3,5,6]$ (ceci est aussi une question de cours).</p>
<p>Donnez un algorithme qui, étant donnée une liste $L$ de monotonies, les fusionne deux-à-deux (en en laissant éventuellement une ``toute seule&quot; à la fin) et met le résultat dans une liste (de listes) $L'$. Par exemple, à partir de<br>
$L = [[2,6], [1,3,3,5],[2,6], [4], [0, 1,8,9], [1,3], [2] ,[0,1], [0]]$, on obtient $L' = [[1,2,3,3,5,6], [2,4,6],[0,1,1,3,8,9], [0,1,2], [0]]$.</p>
<p>En déduire un algorithme de tri. Donnez sa complexité dans le cas le meilleur et dans le cas<br>
le pire.</p>
<p>Cet algorithme est en fait une variante d'un algorithme vu en cours. Lequel ?</p>
<h2>Compteur binaire</h2>
<h3>Suivant</h3>
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">successeur</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>
    i <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span>N<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        N<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
        i <span class="token operator">-=</span> <span class="token number">1</span>

    <span class="token keyword">if</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">:</span>
        N<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3>Tous</h3>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">tous</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>

    N <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">**</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        successeur<span class="token punctuation">(</span>N<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span>
</code></pre>
<p>De façon naive $n\cdot 2^n$</p>
<p>On remarque que la complexité d'une exécution de <code class="language-">successeur(N)</code> est égale au nombre de bits qu'elle a modifié dans <code class="language-">N</code>. Comme les $2^n$ exécutions de <code class="language-">successeur(N)</code> vont parcourir une et une seule fois tous les nombre de 0 à $2^n$ on en conclut que :</p>
<ul>
<li>le dernier bit de $N$ est modifié à chaque appel</li>
<li>l'avant-dernier bit de $N$ est modifié que si le dernier bit de $N$ valait $1$ : il est modifié tous les 2 appels</li>
<li>l'avant-avant-dernier bit de $N$ est modifié que si les deux derniers bits de $N$ valaient $1$ : il est modifié tous les $2^2 = 4$ appels</li>
<li>...</li>
<li>le $i$ bit avant la fin de $N$ est modifié que si les $i-1$ derniers bits de $N$ valaient $1$ : il est modifié tous les $2^{i-1}$ appels</li>
<li>...</li>
<li>le premier bit de $N$ est modifié que si les $n-1$ derniers bits de $N$ valaient $1$ : il est modifié tous les $2^{n-1}$ appels</li>
</ul>
<p>La complexité totale des $2^n$ appels à <code class="language-">successeur(N)</code> vaut donc :</p>
<div>
$$
\begin{array}{rcl}
C &=& 2^n + \frac{2^n}{2} + \frac{2^n}{2^2} + \dots + \frac{2^n}{2^{n-1}}\\
&=& \sum_{i=0}^{n-1}(2^n \cdot \frac{1}{2^i})\\
&=& 2^n \cdot  \sum_{i=0}^{n-1}\frac{1}{2^i}\\
&=&2^{n+1} \cdot (1-\frac{1}{2^n})
\end{array}
$$
</div>
<h3>Complexité en moyenne</h3>
<p>La complexité totale est (on l'a calculée de deux façon différentes) :</p>
<p>$$<br>
C = 2^n \cdot  (2 - \frac{1}{2^{n-1}}) \leq 2^{n+1}<br>
$$</p>
<p>En supposant que les entrées de successeur sur prisent de façon uniforme, le nombre moyen d'opérations effectuée est alors :</p>
<p>$$<br>
\frac{C}{2^n} \leq 2<br>
$$</p>
<p>Le nombre moyen de modifications de bits est inférieur à deux.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
<div class="pl-8 mr-8">
<p>Vérifiez expérimentalement qu'en moyenne, sur tous les appels de <code class="language-">successeur(N)</code> pour l'algorithme <code class="language-">tous(n)</code>, le nombre de bits changé est inférieur à 2.</p>
</div>
</div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>solution</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">successeur</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>
    i <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>

    <span class="token keyword">while</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token keyword">and</span> <span class="token punctuation">(</span>N<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        N<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
        i <span class="token operator">-=</span> <span class="token number">1</span>

    <span class="token keyword">if</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">:</span>
        N<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>

    <span class="token keyword">return</span> <span class="token builtin">len</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token operator">-</span> i


<span class="token keyword">def</span> <span class="token function">tous</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>

    N <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n
    total <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">**</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        total <span class="token operator">+=</span> successeur<span class="token punctuation">(</span>N<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span>

    <span class="token keyword">return</span> total <span class="token operator">/</span> <span class="token number">2</span><span class="token operator">**</span>n


x <span class="token operator">=</span> tous<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>

</code></pre>
</div>
</details>     
</div>
<h2>Jets de dés</h2>
<ul>
<li>algorithme itératif (généralisation du compteur binaire)</li>
<li>algorithme récursif. Complexité en mémoire ?</li>
</ul>
<p>On considère l'algorithme suivant:</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">LaFonction</span> <span class="token punctuation">(</span>L<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            LaFonction<span class="token punctuation">(</span>L <span class="token operator">+</span> <span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> n <span class="token operator">-</span>  <span class="token number">1</span><span class="token punctuation">)</span>

</code></pre>
<p>On rappelle que, appliqué à des listes, le $+$ est la concaténation. On supposera que l'appel initial se fait avec la liste L vide. Que fait cet algorithme ? Quelle est sa complexité ? Quelle place mémoire consomme-t-il ?</p>
<h2>Chaînes de caractères</h2>
<h3>Sous-séquence</h3>
<p>Soient deux chaînes de caractères $S_1$ et $S_2$. On dit que $S_2$ est une {\em sous-séquence} de $S_1$ si il existe une fonction strictement croissante</p>
<p>$$<br>
f : {0,\ldots, len(S_2)-1} \longrightarrow {0,\ldots, len(S_1)-1}<br>
$$</p>
<p>Telle que $S_1[f(j)] = S_2[ j]$ pour tout $j$ de ${0,\ldots, len(S_2)-1}$.</p>
<p>Proposez, prouvez et donnez la complexité d'un algorithme qui détermine si $S_2$ est une sous-séquence de $S_1$.</p>
<h3>Sous-mot</h3>
<p>Soient deux chaînes de caractères $S_1$ et $S_2$. On dit que $S_2$ est un <strong><em>sous-mot</em></strong> de $S_1$ s'il existe un indice $i$ tel que $S_2[j] = S_1[i + j]$ pour tout $j$ de $0$ à $len(S_2) - 1$.</p>
<ul>
<li>Proposez, prouver et donner la complexité d'un algorithme qui détermine si $S_2$ est un sous-mot de $S_1$.</li>
<li>Si toutes les lettres de $S_2$ sont deux à deux différentes, donnez un algorithme en $\mathcal{O}(len(S_1))$ pour résoudre ce problème.</li>
</ul>
<h2>Algorithme mystère</h2>
<p>L'algorithme suivant, à partir d'une liste d'entiers positifs, rend une autre liste. On suppose pour cet exercice que la création des deux listes tempo et sortie est en $\mathcal{O}(1)$ opérations.</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> mystère<span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">:</span>
    k <span class="token operator">=</span> <span class="token builtin">max</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span>
    tempo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    sortie <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        tempo<span class="token punctuation">[</span>tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        tempo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> tempo<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        sortie<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tempo<span class="token punctuation">[</span>tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span>
        tempo<span class="token punctuation">[</span>tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>

    <span class="token keyword">return</span> sortie

</code></pre>
<ul>
<li>Donnez la complexité de cet algorithme.</li>
<li>Dites ce qu'il fait et prouvez le (<em>indication</em>: après chacune des deux premières boucles, que contient tempo ?).</li>
<li>Commentaires ?</li>
</ul>
<h2>Cols</h2>
<ul>
<li>d'une liste (max ou min local). Trouver un algorithme en log</li>
<li>d'une matrice (min ligne et max colonne) avec un algorithme linéaire en la taille de la matrice (pourquoi le log ne marche-t-il pas ?)</li>
</ul>
<h2>Permutation circulaire</h2>
<p>Étant donné un liste $L$ de longueur $n$ et un entier $k$, le problème est de transformer $L$ par permutation circulaire en décalant (circulairement) tous les éléments de $L$ de $k$ places. Par exemple, avec $L = \text{LongtempsJeMeSuisCouchéDeBonneHeure}$ et $k = 4$, on obtient $L' = \text{eureLongtempsJeMeSuisCouchéDeBonneH}$.</p>
<ul>
<li>Donnez un algorithme $\text{Permut}(L, k)$ qui, avec une liste $L$ et un entier $k$ en entrées, construit une nouvelle liste $L'$, permutation circulaire de $L$.</li>
<li>Si on veut transformer $L$ en $\text{Permut}(L,k)$, montrez que la place mémoire utilisée (en plus de celle des données du problème ($L$)) par votre algorithme est $O(n)$.</li>
</ul>
<p>On veut maintenant faire une permutation circulaire sur site, <em>ie.</em> sans utiliser plus que $O(1)$ place mémoire supplémentaire (il arrive (par exemple quand on étudie le génome) que $n$ soit très grand). Il faut pour cela<br>
remarquer que permuter circulairement $L$ revient à prendre les $k$ dernières lettres de $L$ et à les mettre en tête. On note $L^R$ la liste $L$ <strong><em>renversée</em></strong> (par exemple, si $L =\text{Couché}$, $L^R = \text{éhcuoC}$).</p>
<ul>
<li>Donnez un algorithme en $O(n)$ et utilisant $O(1)$ place mémoire supplémentaire, qui transforme $L$ en $L^R$.</li>
<li>Montrez que, si on note $L = AB$, où $B$ est de longueur $k$ (par exemple, avec $L = \text{LongtempsJeMeSuisCouchéDeBonneHeure}$ et $k = 4$, $A =\text{LongtempsJeMeSuisCouchéDeBonneH}$ et $B =\text{eure}), alors \text{Permut}(L, k) = (A^RB^R)^R$.</li>
<li>Déduisez-en un algorithme de complexité $O(n)$ qui permute une liste (de longueur $n$), <em>ie.</em> qui transforme $L$ en $\text{Permut}(L,k)$, en utilisant $O(1)$ espace mémoire supplémentaire.</li>
</ul>
<h2>Algorithmes arithmétique</h2>
<ul>
<li>addition de listes de chiffres</li>
<li>multiplications de listes de chiffres</li>
</ul>
<p>(- <a href="https://fr.wikipedia.org/wiki/Algorithme_de_Karatsuba">optimisation de Karastuba</a>)</p>
<h2>Matrices</h2>
<ul>
<li>structure</li>
<li>addition</li>
<li>produit par un scalaire</li>
<li>produit naïf</li>
</ul>
<p>(- <a href="https://fr.wikipedia.org/wiki/Algorithme_de_Strassen">produit de Strassen</a>}</p>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>