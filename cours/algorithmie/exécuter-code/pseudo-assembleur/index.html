<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Pseudo-assembleur</title>

    <link href="/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet">
    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">

    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Pseudo-assembleur</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/">Algorithmie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/exécuter-code/">Exécuter du Code</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithmie/exécuter-code/pseudo-assembleur/">Pseudo-assembleur</a>

</div>
</div>


    
  

  <p>Nous allons présenter une version <em>&quot;minimale&quot;</em> de pseudo-code que nous appellerons pseudo-assembleur. Cet assembleur idéal et théorique nous permettra de faire le lien entre pseudo-code et le langage machine qui est effectivement exécuté.</p>
<h2>Objet et variables</h2>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Les objets que peut manipuler le pseudo-assembleur sont les caractères <code>0</code> et <code>1</code> et les suites finies de ces caractères.</p>
</div>
</div>
<p>Par exemple l'objet de nom <code>o</code> :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">o <span class="token operator">=</span> <span class="token number">1011001</span>
</code></pre>
<p>Dans un pseudo-code, l'endroit où sont stockés les objets n'est pas défini, dans le pseudo-assembleur, on les stocke explicitement dans un tableau nommé <strong><em>mémoire</em></strong> :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>La <strong><em>mémoire</em></strong> est un tableau $M$ de taille $N$ où chaque case peut contenir soit le caractère <code>0</code>, soit le caractère <code>1</code>.</p>
</div>
</div>
<p>Chaque objet $o = o_0\dots o_{p-1}$, une suite finie de <code>0</code> et de <code>1</code>, est stocké dans des cases contiguës de la mémoire.</p>
<p>L'objet <code>o</code> de tout à l'heure sera alors rangé :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">    <span class="token number">01234567</span>
o <span class="token operator">=</span> <span class="token number">11010100</span>

M<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
M<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
M<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
M<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
M<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
M<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
M<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
M<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
</code></pre>
<p>Attention à la lecture, <strong><em>le bit de poids fort</em></strong> de l'objet, celui le plus à gauche, est d'indice le plus petit.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Les bits de l'objet sont numérotés dans l'ordre opposé de leur lecture. On appelle cette <strong>convention</strong> <a href="https://fr.wikipedia.org/wiki/Boutisme"><strong><em>big endian</em></strong> (ou gros boutisme en français)</a>.</p>
<p>Comme toute convention, certains prennent la convention opposée, dite <strong><em>little endian</em></strong> (ou petit boutisme en français).</p>
</div>
</div>
<p>Ce stockage permet de définir les références :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Une <em><strong>référence</strong></em> d'un objet est l'adresse du premier indice en mémoire le contenant.</p>
</div>
</div>
<p>Une variable est alors une référence nommée :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Une <em><strong>variable</strong></em> est un nom auquel est associé une référence à un objet.</p>
</div>
</div>
<p>La mémoire étant finie, la référence à un objet est toujours codée sur $S = \log_2(N)$ bits.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>La taille $N$ de la mémoire sera toujours une puissance de $2$. On notera $S = \log_2(N)$$, la taille (entière et en bit) du codage binaire d'une adresse.</p>
</div>
</div>
<p>Ceci permet de définir rigoureusement un tableau :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Un <em><strong>tableau</strong></em> de taille $n$ est suite finie et contiguë de $n \cdot S$ cases mémoire. Chaque $S$ bits successifs en mémoire contient la référence d'un objet.</p>
</div>
</div>
<blockquote>
<p>TBD : exemple avec mémoire, objet et tableau. Et variables nommées qui les références. Pour l'instant, les variables ne sont pas en mémoire (on le fera avec la pile et le modèle de von Neumann).</p>
</blockquote>
<h3>Objets entiers</h3>
<p>L'objet entier n'existe pas à proprement parler, mais on suppose qu'une suite finie de $S = \log_2(N)$ bits, qui correspond à une adresse, peut aussi être vue comme un entier. Pour cela, on on possède les deux fonctions suivantes :</p>
<ul>
<li>$u: \{0, 1\}^{S}\rightarrow \mathbb{N}$ qui rend l'entier associé à la suite considérée comme sa représentation binaire</li>
<li>$s: \{0, 1\}^{S}\rightarrow \mathbb{Z}$ qui rend l'entier associé à la suite considérée comme sa représentation binaire en <a href="https://fr.wikipedia.org/wiki/Compl%C3%A9ment_%C3%A0_deux">le complément à deux</a> sur $S$ bits.</li>
<li>$b: \mathbb{Z} \rightarrow  \{0, 1\}^{S}$ qui rend la représentation binaire en <a href="https://fr.wikipedia.org/wiki/Compl%C3%A9ment_%C3%A0_deux">le complément à deux</a> sur $S$ bits associé à l'entier.</li>
</ul>
<p>Pour l'objet <code>o = 1011001</code> précédent, on a :</p>
<ul>
<li><code>u(o) = 212</code></li>
<li><code>s(o) = -44</code></li>
</ul>
<p>Si <code>o</code> code un entier, c'est qu'une adresse mémoire est codée sur 8bits et donc que sa taille vaut $N = 2^8 = 256$.</p>
<h3>Équivalence avec le pseudo-code</h3>
<p>On l'a vu, <a href="../../bases-th%C3%A9oriques/d%C3%A9finition/#param%C3%A8tres-binaires" class="interne">un programme ne peut manipuler que des suites finies de <code>0</code> et de <code>1</code></a>. Le pseudo-code et le pseudo-assembleur manipulent les mêmes objets.</p>
<p>De plus, la finitude de la mémoire n'est pas un problème pour les algorithmes puisqu'ils finissent. On pourra donc toujours trouver une taille de mémoire permettant de l'exécuter. De là, si un programme en pseudo-assembleur atteint la limite de la mémoire, on peut toujours stopper son exécution et la recommencer avec une mémoire deux fois plus grande. L'algorithme en pseudo-assembleur finira toujours par s'arrêter. On a donc :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Pseudo-assembleur et pseudo-code sont équivalent pour la gestion des objets.</p>
</div>
</div>
<h2>Fonctions et appel de fonctions</h2>
<p>En pseudo-code, on appelle les fonctions via des paramètres :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">ma_fonction<span class="token punctuation">(</span>p1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> pn<span class="token punctuation">)</span>
</code></pre>
<p>En pseudo-assembleur, une fonction est appelée avec un unique paramètre $p$ qui correspond à une adresse mémoire d'un tableau $t$ à $n$ adresses telle que :</p>
<ol>
<li>$M[p]$ soit l'adresse du début d'un objet tableau $t$ de taille $n$</li>
<li>$t[i]$ corresponde à l'adresse du paramètre $p_i$</li>
<li>si $k = \log_2(N)$ vaut le nombre de bits pour stocker une adresse, alors aucun objet n'est pour l'instant stocké à une adresse supérieure à $k \cdot n$ : le tableau $t$ est le dernier objet stocké en mémoire par l'algorithme.</li>
</ol>
<p>Les deux premières conditions permettent de ne pas faire de différence entre paramètre de fonctions et objet de l'algorithme et la troisième permet d'appeler facilement des fonction de manière récursive !</p>
<p>Par exemple la fonction de Fibonacci que l'on pourrait écrire en pseudo-code :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fibo</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
  si n ≤ <span class="token number">1</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> a
  sinon<span class="token punctuation">:</span>
    <span class="token keyword">return</span> fibo<span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">,</span> a<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>

affiche à l'écran fibo<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
</code></pre>
<p>Deviendrait en pseudo-assembleur :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fibo</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>
  a <span class="token operator">=</span> u<span class="token punctuation">(</span>M<span class="token punctuation">[</span>p<span class="token punctuation">:</span>p<span class="token operator">+</span>S<span class="token punctuation">]</span><span class="token punctuation">)</span>
  b <span class="token operator">=</span> u<span class="token punctuation">(</span>M<span class="token punctuation">[</span>p <span class="token operator">+</span> S<span class="token punctuation">:</span>p <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> S<span class="token punctuation">]</span><span class="token punctuation">)</span>
  n <span class="token operator">=</span> u<span class="token punctuation">(</span>M<span class="token punctuation">[</span>p <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> S<span class="token punctuation">:</span>p <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">*</span> S<span class="token punctuation">]</span><span class="token punctuation">)</span>

  si n ≤ <span class="token number">1</span><span class="token punctuation">:</span>
    stocke a dans les cases M<span class="token punctuation">[</span>p <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">*</span> S<span class="token punctuation">:</span>p <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">*</span> S<span class="token punctuation">]</span>
    <span class="token keyword">return</span> p <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">*</span> S
  sinon<span class="token punctuation">:</span>
    stocke l'entier a <span class="token operator">+</span> b dans les cases M<span class="token punctuation">[</span>p <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">*</span> S<span class="token punctuation">:</span>p <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">*</span> S<span class="token punctuation">]</span>
    stocke l'entier a dans les cases M<span class="token punctuation">[</span>p <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">*</span> S<span class="token punctuation">:</span>p <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">*</span> S<span class="token punctuation">]</span>
    stocke l'entier n<span class="token operator">-</span><span class="token number">1</span> dans les cases M<span class="token punctuation">[</span>p <span class="token operator">+</span> <span class="token number">5</span> <span class="token operator">*</span> S<span class="token punctuation">:</span>p <span class="token operator">+</span> <span class="token number">6</span> <span class="token operator">*</span> S<span class="token punctuation">]</span>

    <span class="token keyword">return</span> fibo<span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">*</span> S<span class="token punctuation">)</span>

  affiche à l'écran u<span class="token punctuation">(</span>M<span class="token punctuation">[</span>fibo<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre>
<p>La fonction <code>fibo</code> retourne l'adresse d'un entier en mémoire et est correcte puisque l'on sait qu'aucun objet n'est stocké après le tableau de paramètre : l'appel récursif ne peut pas faire planter l'algorithme.</p>
<blockquote>
<p>TBD dérouler l'exemple (avec la mémoire représentée à chaque exécution de ligne)</p>
</blockquote>
<p>L'utilisation de ce tableau de paramètre en mémoire permet d'avoir :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Pseudo-assembleur et pseudo-code sont équivalent pour la gestion des fonctions.</p>
</div>
</div>
<h2>Structures de contrôles</h2>
<p>On associe à chaque ligne du programme en pseudo-assembleur un <strong><em>label</em></strong>, qui correspond à son numéro de ligne. Cet ajout va permettre de gérer les structures de contrôles et les tests sans blocs : uniquement avec des sauts.</p>
<h3>Saut</h3>
<p>On ajoute au pseudo-assembleur une instruction de saut :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">GOTO label
</code></pre>
<p>L'instruction <code>GOTO</code> (&quot;go to&quot; : &quot;aller à&quot;) <em>saute</em> à l'instruction de label <code>label</code>. Par exemple le programme suivant qui est une version itérative (et infinie) de la suite de Fibonacci :</p>
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python">a <span class="token operator">=</span> M<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>S<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
b <span class="token operator">=</span> M<span class="token punctuation">[</span>S<span class="token punctuation">:</span>2S<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
n <span class="token operator">=</span> M<span class="token punctuation">[</span>2S<span class="token punctuation">:</span>3S<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

affiche à l'écran n<span class="token punctuation">,</span> a

n <span class="token operator">=</span> n <span class="token operator">+</span> <span class="token number">1</span>
a<span class="token punctuation">,</span> b <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">,</span> a

GOTO <span class="token number">8</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>TBD : dérouler l'exemple (avec la mémoire représentée à chaque exécution de ligne)<br>
dire qu'on a assimiler variable et case mémoire.</p>
</blockquote>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mr-8">
<p>L'utilisation de saut était très répandu dans les débuts de la programmation (des langages comme <a href="https://koor.fr/C/Statements/goto.wp#google_vignette">le C en possède une instruction de saut</a>), mais son usage a été banni pour être remplacé par des blocs car il rendait le code très difficile à lire.</p>
</div>
</div>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-fuchsia-500 bg-fuchsia-100">
  <svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-fuchsia-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
    <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z"></path>
  </svg>
<div class="pl-8 mr-8">
<p><a href="https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf">Célèbre article de Dijkstra contre l'utilisation des sauts en programmation</a>.</p>
</div>
</div>
<p>Notez que les sauts peuvent être utilisés pour des appels de fonctions ! Il suffit de permettre le saut à partir d'une variable. Le code suivant utilise la variable <code>I</code> pour stocker l'endroit où sauter après l'exécution de la fonction :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">GOTO <span class="token number">6</span>

affiche à l'écran n<span class="token punctuation">,</span> a
GOTO I

a <span class="token operator">=</span> M<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>S<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
b <span class="token operator">=</span> M<span class="token punctuation">[</span>S<span class="token punctuation">:</span>2S<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
n <span class="token operator">=</span> M<span class="token punctuation">[</span>2S<span class="token punctuation">:</span>3S<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

I <span class="token operator">=</span> <span class="token number">12</span>
GOTO <span class="token number">3</span>

n <span class="token operator">=</span> n <span class="token operator">+</span> <span class="token number">1</span>
a<span class="token punctuation">,</span> b <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">,</span> a

I <span class="token operator">=</span> <span class="token number">18</span>
GOTO <span class="token number">3</span>

GOTO <span class="token number">5</span>
</code></pre>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>L'appel de fonction en pseudo-assembleur se fait avec des instruction de saut et une variable contenant la ligne de retour.</p>
</div>
</div>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Dans ce cas là, le nombre de ligne de code est borné par l'adressage possible en mémoire. Ce n'est pas gênant en pratique, un adressage sur 64bit permet d'écrire $2^{64}$ lignes de code...</p>
</div>
</div>
<h3>Test</h3>
<p>Les tests en pseudo-code sont de deux types :</p>
<ul>
<li>arithmétiques, comme $a &lt; b$</li>
<li>logique, comme $(A OU B) ET C$</li>
</ul>
<p>Ils n'existent pas à proprement parler en pseudo-assembleur, mais ils peuvent être simulé grâce aux <strong><em>drapeaux</em></strong>.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Un <strong><em>drapeau</em></strong> (<strong><em>flag</em></strong>)  est une variable binaire affectée automatiquement après une opération.</p>
</div>
</div>
<p>En particulier, on considère que le pseudo-assembleur possède les deux drapeaux suivant, qui permettent de faire tous les tests du pseudo-code :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Le pseudo-assembleur possède les deux drapeaux :</p>
<ul>
<li><code>NÉGATIF</code> qui vaut <code>1</code> si la dernière opération arithmétique a donné un résultat négatif, et <code>0</code> sinon.</li>
<li><code>ZÉRO</code> qui vaut <code>1</code> si la dernière opération arithmétique ou logique a donné un résultat de zéro, et <code>0</code> sinon.</li>
</ul>
</div>
</div>
<p>Ainsi :</p>
<ul>
<li>$a \leq b$ pourra être effectué en regardant la valeur du drapeau <code>NÉGATIF</code> après l'opération $b-a$.</li>
<li>$(A OU B) ET C$ pourra être effectué en regardant la valeur du drapeau <code>ZÉRO</code> (s'il vaut <code>0</code>, c'est vrai)</li>
</ul>
<p>On a donc :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>On peut créer les mêmes tests en pseudo-assembleur et en pseudo-code.</p>
</div>
</div>
<h3>Saut conditionnel</h3>
<p>Enfin, pour permettre de construire les structures de contrôle du pseudo-code, on ajoute les <strong><em>sauts conditionnels</em></strong> :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Un saut conditionnel est de la forme :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">IFGOTO drapeau label
</code></pre>
<p>La prochaine instruction exécutée sera celle de la ligne <code>label</code> si le drapeau de nom <code>drapeau</code> vaut <code>1</code>.</p>
<p>De même :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">IFNOTGOTO drapeau label
</code></pre>
<p>La prochaine instruction exécutée sera celle de la ligne <code>label</code> si le drapeau de nom <code>drapeau</code> vaut <code>0</code>.</p>
</div>
</div>
<p>Le code ci-après utilise le saut conditionnel pour afficher les 11 premières valeurs de la suite de Fibonacci.</p>
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python">a <span class="token operator">=</span> M<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>S<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
b <span class="token operator">=</span> M<span class="token punctuation">[</span>S<span class="token punctuation">:</span>2S<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
n <span class="token operator">=</span> M<span class="token punctuation">[</span>2S<span class="token punctuation">:</span>3S<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

affiche à l'écran n<span class="token punctuation">,</span> a

n <span class="token operator">=</span> n <span class="token operator">+</span> <span class="token number">1</span>
a<span class="token punctuation">,</span> b <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">,</span> a

n<span class="token operator">-</span><span class="token number">10</span>
IFNOTGOTO NÉGATIF <span class="token number">5</span>

affiche à l'écran <span class="token string">"FIN"</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> a
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Comme on le voit, il est facile de remplacer les structures de contrôles et les répétitions du pseudo-code par une utilisation combinée des labels et des sauts conditionnels :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>On peut créer les mêmes structure de contrôles et les boucles en pseudo-assembleur et en pseudo-code.</p>
</div>
</div>
<h2>Opérations</h2>
<p>Les opérations autorisées en pseudo-code sont de deux ordres : logique et arithmétiques. Les autres opérations (concaténation de chaines de caractères, manipulation d'approximation de réels, ...) se déduisent de ces deux catégories. Les opérations logiques et arithmétiques fonctionnent toutes de la même manière :</p>
<ul>
<li>elles prennent au plus 2 paramètres</li>
<li>elles rendent au plus 1 objet</li>
</ul>
<p>Par exemple l'addition (2 paramètres et une sortie) ou la négation (1 paramètre et une sortie). Notez que les opérations qui rendent plus que une sortie (comme la division euclidienne par exemple) peuvent être décomposées en plusieurs opérations rendant chacune une unique sortie (division entière et modulo pour la division euclidienne).</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Le schéma général d'une <strong><em>opération</em></strong> en pseudo-assembleur est :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">OP <span class="token comment">#1 #2 #3 </span>
</code></pre>
<p>Où :</p>
<ul>
<li><code>OP</code> est le <a href="https://fr.wikipedia.org/wiki/Code_mn%C3%A9monique">code mnémonique</a> associée (le nom) à l'opération</li>
<li><code>#1</code>, <code>#2</code> et <code>#3</code> représentent les paramètres de l'opération et peuvent représenter soit des entrées soit une sortie selon l'opération.</li>
</ul>
</div>
</div>
<p>Les paramètres d'entrées et la sortie sont stockés dans des <a href="https://fr.wikipedia.org/wiki/Registre_de_processeur">registres</a> qui sont des variables spéciales.</p>
<h3>Registres</h3>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Un <strong><em>registre</em></strong> est une mémoire de taille $S$ (donc suffisante pour stocker une adresse). Il en existe deux types :</p>
<ul>
<li>les registres génériques qui peuvent indépendamment être utilisé comme entrée et sortie d'une opération. Ils sont désignés par un numéro <code>$1</code>, <code>$2</code>, etc.</li>
<li>les registres spécifiques qui véhiculent des informations précisent et sont souvent en lecture seule (les drapeaux sont des registres spécifiques par exemple).</li>
</ul>
</div>
</div>
<p>Les registres permettent de faire fonctionner le pseudo-assembleur et forment les liens entre opérations et mémoire. Les opérations permettant de déplacer les valeurs des registres à la mémoire et inversement sont :</p>
<ul>
<li><code>LOAD $X $Y</code> qui place la valeur en mémoire <code>M[u($Y):u($Y)+S]</code>  (<code>u($Y)</code> est la valeur du registre de numéro <code>Y</code> prise comme une adresse) dans le registre de numéro <code>X</code></li>
<li><code>STORE $X $Y</code> qui place la valeur du registre <code>X</code> dans les cases mémoires <code>M[u($Y):u($Y)+S]</code></li>
<li><code>SET $X Y</code> qui place la constante <code>Y</code> (une suite de 0 et de 1 de taille $S$) dans le registre de numéro <code>X</code></li>
</ul>
<blockquote>
<p>TBD exemple avec image de la mémoire et de 2 registres.</p>
</blockquote>
<h3>Types d'opérations</h3>
<p>Les opérations d'un pseudo-assembleur, comme pour un pseudo-code sont essentiellement arithmétique</p>
<h4>Logiques</h4>
<p>Les opérations logiques sont des fonctions de $\{0, 1\}^p \rightarrow \{0, 1\}$, avec $p$ valant 0 ou 1. On les représentent via leurs <a href="https://fr.wikipedia.org/wiki/Table_de_v%C3%A9rit%C3%A9">tables de vérité</a>.</p>
<p>Si $p$ vaut, il n'y a qu'une seule opération différente de l'identité :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>La fonction $\text{NOT}(x) = \bar{x}$ est définie selon la table de vérité suivante :</p>
<table>
<thead>
<tr>
<th>x</th>
<th>NOT</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>Elle <em>inverse</em> son paramètre.</p>
</div>
</div>
<p>Si $p$ vaut 2, on a coutume d'utiliser les deux fonctions suivantes :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>La fonction $\text{AND}(x, y) = x \land y$ est définie selon la table de vérité suivante :</p>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>AND</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Elle est vraie si $x$ et $y$ sont vrais.</p>
</div>
</div>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>La fonction $\text{OR}(x, y) = x \lor y$ est définie selon la table de vérité suivante :</p>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>AND</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>Elle est vraie si $x$ ou $y$ est vrai.</p>
</div>
</div>
<p>Ces trois fonctions sont fondamentales :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Toute fonction de $\{0, 1\}^2 \rightarrow \{0, 1\}$ peut s'écrire comme combinaison des fonctions $\text{NOT}(x)$, $\text{AND}(x, y)$, et $\text{OR}(x, y)$.</p>
</div>
</div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Il y a 16 possibilités de fonctions :</p>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>01</th>
<th>02</th>
<th>03</th>
<th>04</th>
<th>05</th>
<th>06</th>
<th>07</th>
<th>08</th>
<th>09</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
<th>16</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>On a :</p>
<ul>
<li>la fonction $f_i = \overline{f_{i+8}}$ pour $1\leq i \leq 8$</li>
<li>$f_1$ est la fonction constante valant 0</li>
<li>$f_{2+8}(x, y)$ est la fonction $x \lor y$</li>
<li>$f_{3}(x, y) = f_{4}(y, x)$ et $f_{3+8}$ est la fonction $\bar{x} \lor y$</li>
<li>$f_{5}(x, y)$ est la fonction $x \land y$</li>
<li>$f_{6}(x, y)$ est la fonction $\bar{y}$</li>
<li>$f_{7 + 8}(x, y)$ est la fonction $x$</li>
<li>$f_{8 + 8}(x, y)$ est la fonction $(x \land \bar{y}) \lor (\bar{x} \land y)$</li>
</ul>
</div>
</details>     
</div>
<p>Le résultat précédent se généralise pour tout $p$. Pour cela, commençons par définir un concept fondamental en logique la <em><strong>conjonction de clauses</strong></em> :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Soient $x_1, \dots, x_n$, $n$ variables binaires. On définit :</p>
<ul>
<li>un <strong><em>littéral</em></strong> $l$ comme étant soit une variable $l = x_i$, soit sa négation $l = \overline{x_i}$</li>
<li>une <strong><em>clause</em></strong> comme étant une disjonction de littéraux $c = l_1 \lor \dots \lor l_k$ (avec $l_1, \dots l_k$ littéraux)</li>
<li>une <strong><em>conjonction de clauses</em></strong> comme étant $c = c_1 \land \dots \land c_m$ (avec $c_1, \dots c_m$ des clauses)</li>
</ul>
</div>
</div>
<p>Toute fonction $f: \{0, 1\}^n \rightarrow \{0, 1\}$ peut alors s'écrire comme une conjonction de clauses :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Toute fonction de $\{0, 1\}^n$ dans $\{0, 1\}$ peut s'écrire comme une conjonction de clauses.</p>
</div>
</div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Soit $f(x_1, \dots, x_n)$ une fonction de $\{0, 1\}^n$ dans $\{0, 1\}$.</p>
<p>À tout élément $x=(x_1, \dots, x_n)$ de $\{0, 1\}^n$ on peut associer la fonction $l^x(y_1, \dots, y_n) = l^x_1 \land \dots \land l^x_i \land \dots \land l^x_n$ où $l^x_i = y_i$ si $x_i = 1$ et $l^x_i = \overline{y_i}$ sinon. La fonction $f$ est alors égale à :</p>
<p>$$<br>
f(x) = \lor \{l^y(x) | f(y) = 1\}<br>
$$</p>
<p>Comme $(a \land b)\lor c = (a \lor c)\land (b \lor c)$, $f$ peut se récrire en conjonction de clauses ce qui conclut la preuve.</p>
</div>
</details>     
</div>
<p>On voit qu'il suffit que le pseudo-assembleur définisse les fonctions $\text{NOT}(x)$, $\text{OR}(x, y)$ et $\text{AND}(x, y)$ pour des variables $x$ et $y$ binaires pour pouvoir générer toutes les fonctions de $\{0, 1\}^n$ dans $\{0, 1\}$, quelque soit l'entier $n$. On peut aller encore plus loin grâce à la proposition suivante :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Les fonctions $\text{NOT}(x)$, $\text{OR}(x, y)$ et $\text{AND}(x, y)$ pour des variables $x$ et $y$ binaires peuvent s'écrire comme compositions de fonctions $\text{NAND}(x, y) = \text{NOT}(\text{AND}(x, y))$</p>
</div>
</div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group" open="">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7"></path>
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7"></path>
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z"></path>
</svg>
</summary>
<div class="mx-8 pb-2">
<blockquote>
<p>TBD</p>
</blockquote>
</div>
</details>     
</div>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<blockquote>
<p>TBD cela marche aussi avec XOR.</p>
</blockquote>
</div>
</div>
<p>Son pendant en<br>
L'opération <code>NOT $1 $2</code>, ou<br>
, dont la table de vérité est :</p>
<p>Si</p>
<blockquote>
<p>bit à bit<br>
peut se généraliser sur tout un registre<br>
peut se généraliser à aussi long qu'on veut : on peut découper</p>
</blockquote>
<blockquote>
<p>TBD faire une partie arithmétique booléenne ?</p>
</blockquote>
<p>On peut tout faire avec une combinaison de not, and et or : c'est une clause.</p>
<h4>Arithmétiques</h4>
<blockquote>
<p>addition dans 0,1 est une fonction sur 0, 1, donc logique. Elle est de plus découpable avec une retenue (registre)</p>
<p>avec complément à deux parce que soustraction = addition</p>
</blockquote>
<blockquote>
<p>a priori opération aussi grande qu'on veut mais on peut découper. Exemple sur logique et 1 seul bit. Ou addition et retenue.<br>
deux catégories</p>
</blockquote>
<p>On verra que l'on peut même se restreindre à une seule opération pour construire toutes les autres, mais commençons par formaliser comment le pseudo-assembleur utilise les opérations.</p>
<blockquote>
<p>TBD parler des additions/soustraction etc par bout de taille fixe. plus drapeau retenue pour permettre de faire sur taille pas fixe si besoin.<br>
On peut tout faire avec add et on peut faire add avec XOR.<br>
Opérations logiques avec NANDm donc juste NAND pour tout faire.</p>
</blockquote>
<p>Le pseudo-code doit permettre de faire les opérations arithmétiques courantes sur les objets :</p>
<ul>
<li>plus, moins, fois et divisé pour les entiers relatifs et les approximations des réels</li>
<li>plus, moins, fois et divisé pour les approximations de réels</li>
<li>concaténation des chaines de caractères</li>
</ul>
<p>L'intérêt d'utiliser des suites binaires est que toutes les opérations arithmétiques peuvent se réaliser avec les deux opérations logiques suivantes :</p>
<ul>
<li><code>copie(x)</code></li>
<li><code>SHIFT(x, y)</code> rend un objet contenant la concaténation de y0...0 ajout de s(x) 0 à droite de y si s(x) &gt; 0 et de -s(x) 0 à gauche si s(x) &lt; 0</li>
<li><code>NAND(x, y)</code> : opérateur logique NON ET.</li>
</ul>
<p>En effet, il est possible d'<a href="https://en.wikipedia.org/wiki/NAND_logic">obtenir toutes les opérations logiques avec NAND</a> et l'opération SHIFT permet d'ajouter des bits à gauche ou à droite d'un objet (si on veut ajouter des 1 on peut fait NOT(SHIFT(x, NOT(y))))</p>
<p>Ou 1 ou 2 paramètre et une sortie.</p>
<h3>Équivalences</h3>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<blockquote>
<p>TBD que NAND sur 1 bit</p>
</blockquote>
</div>
</div>
<h2>I/O</h2>
<blockquote>
<p>TBD pas core (il suffit de regarder la mémoire), mais utile</p>
</blockquote>
<ul>
<li>afficher à l'écran</li>
<li>fichier et clavier ?</li>
</ul>
<h2>MMIX</h2>
<p>Nous n'avons montré que le principe d'un pseudo-assembleur, juste assez pour nous convaincre que les notions de pseudo-code et pseudo-assembleurs sont équivalentes.</p>
<p>Donald Knuth a formellement décrit un pseudo-assembleur complet, nommée <a href="https://fr.wikipedia.org/wiki/MMIX">MMIX</a>. Je ne saurais trop vous conseiller d'aller jeter un coup d'œil au site qui explique son fonctionnement, comme toujours avec Knuth, de façon claire et précise :</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p><a href="https://mmix.cs.hm.edu/">https://mmix.cs.hm.edu/</a></p>
</div>
</div>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>