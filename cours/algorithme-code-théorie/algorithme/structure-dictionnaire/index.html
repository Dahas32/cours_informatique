<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <title>Structure : dictionnaire</title>

    <link href=/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css rel="stylesheet">
    <link href=/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css rel="stylesheet">

    <link href=/cours_informatique/assets/stylesheets/main.css rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
  src=/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js></script>
  
    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1000px] mx-auto px-4">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
          <a class="mx-2" href="/cours_informatique/about">About</a>
        </div>
      </div>
    </header>

    <main class="max-w-[1000px] mx-auto px-4">
      
<article>

  <h1  >Structure : dictionnaire</h1>
  <div >
    

    
  </div>

  
    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z" />
</svg>
<div class="pl-8 mr-8">

<a href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a href="/cours_informatique/cours/algorithme-code-théorie/">Algorithme, code et théorie</a><span class="px-1">/</span><a href="/cours_informatique/cours/algorithme-code-théorie/algorithme/">Algorithme</a><span class="px-1">/</span><a href="/cours_informatique/cours/algorithme-code-théorie/algorithme/structure-dictionnaire/">Structure : dictionnaire</a>

</div></div>

  

  <div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-pink-500 bg-pink-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-pink-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Prérequis</strong> :</p>
</div><div class="pl-8 mr-8">
<ul>
<li><a href="../../th%C3%A9orie/fonctions-hash">fonctions de hash</a></li>
<li><a href="../complexit%C3%A9-moyenne">complexité en moyenne</a></li>
</ul>
</div></div>
<!-- début résumé -->
<p>Mise en œuvre de la structure de dictionnaire, qui est une structure fondamentale en code.</p>
<!-- end résumé -->
<p>Un dictionnaire, ou encore <a href="https://fr.wikipedia.org/wiki/Tableau_associatif">tableau associatif</a> est une structure de donnée permettant d'indexer des objets par leur nom plutôt que par un nombre.</p>
<h2>Motivation</h2>
<p>Les tableaux associatifs répondent à deux grandes problématiques :</p>
<ul>
<li>la gestion des ensembles</li>
<li>l'indexation par des objets</li>
</ul>
<h3>Ensembles</h3>
<p>Les structure ensemblistes permettent de répondre facilement à des problématiques du genre :</p>
<ul>
<li>est-ce un de mes contact qui appelle ?</li>
<li>est-ce que cette lettre est une majuscule ?</li>
<li>est-ce un mot que j'ai déjà vu ?</li>
</ul>
<p>Gérer des ensembles rapidement et avec peu de place en mémoire :</p>
<ul>
<li>ajouter un élément à un ensemble (on ne rajoute pas un élément qui y est déjà)</li>
<li>supprimer un élément à un ensemble</li>
<li>savoir si un élément est déjà dans un ensemble</li>
</ul>
<h3>Tableau associatif</h3>
<p>Un tableau associatif associe une clé à une valeur. On peut voir les listes comme un tableau associatif où les clés sont des entiers allant de 0 à la longueur de la liste moins 1.</p>
<p>Mais cela peut être bien plus général que ça :</p>
<ul>
<li>les clés peuvent être de mots et les valeur un nombre. Cela permet par exemple de compter le nombre de fois où un chaque mot d'un texte apparaît.</li>
<li>associer un nom (valeur) à un numéro de téléphone (clé) sans avoir besoin d'une liste allant de 0 à numéro max de téléphone.</li>
</ul>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>Un ensemble peut être codé en utilisant la structure de tableau associatif en considérant que les valeurs sont toutes les mêmes. n ne considère que les clés qui représentent les éléments de l'ensemble.</p>
</div></div>
<h2>En python</h2>
<p>ce que c'est :</p>
<ul>
<li>ensemble : <a href="https://docs.python.org/fr/3/tutorial/datastructures.html#sets"><code>set</code></a></li>
<li>dictionnaires : <a href="https://docs.python.org/fr/3/tutorial/datastructures.html#dictionaries"><code>dict</code></a></li>
</ul>
<p>Les éléments pouvant être stockés dans des ensemble ou les clés des dictionnaires doivent être des objets <strong>non modifiables</strong>. Comme par exemple :</p>
<ul>
<li>des entiers</li>
<li>des réels</li>
<li>des chaines de caractères</li>
<li>des tuples</li>
<li>...</li>
</ul>
<p>Les éléments modifiables ne peuvent <strong>pas</strong> être des clés. Par exemple :</p>
<ul>
<li>des listes</li>
<li>des ensembles</li>
<li>des dictionnaires</li>
</ul>
<h3>Ensemble</h3>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z" />
</svg>
<div class="pl-8 mr-8">
<p><a href="https://realpython.com/python-sets/">https://realpython.com/python-sets/</a></p>
</div></div>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> S <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> S<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> S<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token string">"une chaîne de caractères"</span><span class="token punctuation">)</span>
<span class="token operator">>></span><span class="token operator">></span> S
<span class="token punctuation">{</span><span class="token string">'une chaîne de caractères'</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">}</span>
</code></pre>
<p>N'hésitez pas à regarder les méthodes associées aux ensembles et à les utiliser dans vos programmes. Ils sont très pratiques !</p>
<p>Il existe de ensemble non modifiable, nommé <a href="https://docs.python.org/fr/3/library/stdtypes.html#frozenset"><code class="language-">frozenset</code></a> (on place les éléments directement à la création et ils ne peuvent plus être modifiés ensuite). Les ensembles non modifiables peuvent alors être placés dans des ensemble ou être des clés de dictionnaires.</p>
<h3>Dictionnaire</h3>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z" />
</svg>
<div class="pl-8 mr-8">
<p><a href="https://realpython.com/python-dicts/">https://realpython.com/python-dicts/</a></p>
</div></div>
<p>Les clés ne doivent pas changer une fois créées, sinon la serrure fabriquée dans le dictionnaire ne fonctionne plus. On ne doit donc utiliser que des objets <strong>non modifiable</strong> pour créer des clés d'un dictionnaire python.</p>
<h4>Création</h4>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">#identique à d = dict()</span>
d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"un"</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"deux"</span><span class="token punctuation">:</span><span class="token number">2</span><span class="token punctuation">}</span> <span class="token comment">#identique à d = dict([("un", 1), ("deux", 2)])</span>
</code></pre>
<h4>Obtention, modification, ajout et suppression d'un élément</h4>
<p>Identique à une liste, mais on utilise les clés plutôt que les indices :</p>
<p>avec <code class="language-">d = {&quot;un&quot;:1, &quot;deux&quot;:2}</code> :</p>
<ul>
<li><code class="language-">d[&quot;un&quot;]</code>  retourne 1</li>
<li><code class="language-">d[&quot;trois&quot;]</code> retourne une erreur : la clé &quot;trois&quot; n'existe pas.</li>
<li>Ajout d'un élément :  <code class="language-">d[&quot;trois&quot;] = 3</code></li>
<li>Suppression d'un élément :  <code class="language-">del d[&quot;deux&quot;]</code></li>
</ul>
<h4>itération</h4>
<p>supposons que l'on ait le dictionnaire :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">d <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token string">"a"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token string">"b"</span><span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre>
<p>Le code suivant :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">for</span> x <span class="token keyword">in</span> d<span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment"># affichera les clés</span>
</code></pre>
<p>Affichera les clés du dictionnaires. On affichera donc :</p>
<ul>
<li>peut être 'a' puis 'b'</li>
<li>peut être 'b' puis 'a'</li>
</ul>
<p>L'ordre d'itération des clés n'est <strong>PAS</strong> connu à l'avance : il peut changer d'une ordinateur à l'autre, et même d'une exécution à l'autre. Un dictionnaire  contient des éléments stockés sans ordre particulier.</p>
<p>On peut aussi itérer sur les clés en utilisant la méthode <code class="language-">keys</code> :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">for</span> x <span class="token keyword">in</span> d<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment"># affichera les clés</span>
</code></pre>
<p>On peut aussi itérer sur les valeurs en utilisant la méthode <code class="language-">values</code> :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">for</span> x <span class="token keyword">in</span> d<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment"># affichera les valeurs</span>
</code></pre>
<p>Ou encore itérer sur les couples (clé, valeur) avec la méthode <code class="language-">items</code> :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">for</span> x <span class="token keyword">in</span> d<span class="token punctuation">.</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment"># affichera les couples (clé, valeur)</span>
     
</code></pre>
<h3>Exercices</h3>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
<div class="pl-8 mr-8">
<p>Combien de mots différents contient le texte <code class="language-">&quot;coucou les gars coucou les filles&quot;</code> ?</p>
<p>Vous pourrez utiliser la méthode <a href="https://docs.python.org/fr/3/library/stdtypes.html#str.split">split des ``str`</a></p>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>solution</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">texte <span class="token operator">=</span> <span class="token string">"coucou les gars coucou les filles"</span>

mots <span class="token operator">=</span> <span class="token builtin">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> x <span class="token keyword">in</span> texte<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    mots<span class="token punctuation">.</span>add<span class="token punctuation">(</span>x<span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>mots<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
<p>Attention cependant aux caractères de ponctuation lors du <code class="language-">split</code>. <code>&quot;x, x. x ?&quot;.split()</code> donne  <code class="language-">['x,', 'x.', 'x', '?']</code>)</p>
</div>
</details>     
</div>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
<div class="pl-8 mr-8">
<p>Comptez les occurrences de chaque mot du texte <code class="language-">&quot;coucou les gars coucou les filles&quot;</code> ?</p>
<p>Vous pourrez utiliser la méthode <a href="https://docs.python.org/fr/3/library/stdtypes.html#str.split">split des ``str`</a></p>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>solution</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">texte <span class="token operator">=</span> <span class="token string">"coucou les gars coucou les filles"</span>

mots <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> x <span class="token keyword">in</span> texte<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> x <span class="token keyword">in</span> mots<span class="token punctuation">:</span>
        mots<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        mots<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>mots<span class="token punctuation">)</span>
</code></pre>
</div>
</details>     
</div>
<h2>Structure de donnée</h2>
<p>Pour créer efficacement une structure de dictionnaire, on utilise des [fonctions de hachage](../../théorie/fonctions-hash.md %}).</p>
<p>Supposons que l'on ait une fonction de hachage $f$ qui a tout objet associe un nombre entre 0 et $m$.</p>
<p>On peut de plus supposer que le hash est calculé en $\mathcal{O}$ de la taille de l'objet à hacher. Par exemple en $\mathcal{O}(len(s))$ pour une chaîne de caractères <code>s</code> par exemple.</p>
<p>Si la fonction $f$ est injective, il suffit de stocker nos valeurs dans une liste $L$ à $m+1$ éléments à l'indice égal au hash de sa clé. Ainsi si je veux associer la valeur $v$ à la clé $c$, on effectuera l'opération : <code>L[f(c)] = v</code>.</p>
<p>Si la fonction n'est pas injective, chaque élément de la liste $L$ est une liste qui stockera les différentes clés ayant même hash. De là :</p>
<ul>
<li>pour associer $v$ à la clé $c$, on effectue les opérations suivantes :
<ol>
<li>on cherche le hash <code>f(c)</code> qui sera un nombre entre $0$ et $m$.</li>
<li>Soit $L'= L[f(c)]$. $L'$ est une liste composée de couple $(a, b)$. On a alors 2 cas :
<ol>
<li>S'il existe $(c, b)$ dans $L'$ on remplace $b$ par v</li>
<li>S'il n'existe pas de couple $(c, b)$ dans $L'$ on ajoute à la fin de la liste $L'$ le couple $(c, v)$</li>
</ol>
</li>
</ol>
</li>
<li>pour retrouver la valeur $v$ associée la clé $c$, on effectue les opérations suivantes :
<ol>
<li>on cherche le hash <code>f(c)</code> qui sera un nombre entre $0$ et $m$.</li>
<li>Soit $L'= L[f(c)]$. $L'$ est une liste composée de couple $(a, b)$. On a alors 2 cas :
<ol>
<li>S'il existe $(c, b)$ dans $L'$ on rend $b$</li>
<li>S'il n'existe pas de couple $(c, b)$ $f(c)$ n'est pas une clé du dictionnaire et on rend une erreur.</li>
</ol>
</li>
</ol>
</li>
</ul>
<p>Pour ces deux opérations, la complexité est alors la somme des complexités :</p>
<ul>
<li>du calcul du hash de l'objet <code>c</code> : <code>f(c)</code></li>
<li>du nombre d'éléments de <code>L[f(c)]</code></li>
<li>du temps pour vérifier l'égalité entre 2 objets.</li>
</ul>
<p>Comme les clés sont associés à des objets non modifiables, leur hash peut être connu à la création des objets donc le calcul de <code>f(c)</code> se fait en $\mathcal{O}(1)$. La complexité vient donc de la comparaison de l'objet <code>c</code> à tous les premiers éléments de <code>L[f(c)]</code>, ce qui correspond à la complexité $K(c)$ de l'opérateur <code>==</code> de l'objet <code>c</code> multiplié par la longueur de <code>L[f(c)]</code>.</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
</svg>
<div class="pl-8 mr-8">
<p>La complexité $K(c)$ dépend de l'objet <code>c</code>. Pour comparer deux réels, cela se fait en $\mathcal{O}(1)$, mais pour une liste par exemple cela va dépendre des éléments contenus dans la liste (comparer deux listes revient à comparer tous les éléments des deux listes 2 à 2).</p>
</div></div>
<p>Si la taille maximale des objets est connues, on a coutume de considérer que $K(c) = \mathcal{O}(1)$ pour tout objet $c$.</p>
<h3>Taille de la structure</h3>
<p>Comme la liste principale où stocker les éléments est de taille $m+1$, il est impossible d'utiliser la fonction de hachage directement. En effet, si l'on utilise sha-1 pour fonction de hachage il faudrait une taille de liste de $2^{160}$ ce qui est impossible...</p>
<p>C'est pourquoi, en réalité on n'utilise une fonction supplémentaire appelée <strong>fonction d'adressage</strong> qui est une deuxième fonction de hash dont on peut maîtriser la taille :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>Une fonction d'adressage $f_m$ est une fonction : de $\mathbb{N}$ dans $[0\mathrel{ {.},{.} } m-1]$.</p>
</div></div>
<p>Une structure de dictionnaire est alors un couple :</p>
<ul>
<li>$L$ : la liste principale de taille $m$</li>
<li>$f_m$ une fonction d'adressage.</li>
</ul>
<p>Pour associer et rechercher une valeur on procède alors comme suit :</p>
<ul>
<li>pour associer $v$ à la clé $c$, on effectue les opérations suivantes :
<ol>
<li>on cherche le hash <code>f(c)</code> de la clé $c$.</li>
<li>on note $i_c = f_m(f(c))$ qui sera un nombre entre 0 et $m-1$</li>
<li>Soit $L'= L[i_c]$. $L'$ est une liste composée de couple $(a, b)$. On a alors 2 cas :
<ol>
<li>S'il existe $(c, b)$ dans $L'$ on remplace $b$ par v</li>
<li>S'il n'existe pas de couple $(c, b)$ dans $L'$ on ajoute à la fin de la liste $L'$ le couple $(c, v)$</li>
</ol>
</li>
</ol>
</li>
<li>pour retrouver la valeur $v$ associée la clé $c$, on effectue les opérations suivantes :
<ol>
<li>on cherche le hash <code>f(c)</code> de la clé $c$.</li>
<li>on note $i_c = f_m(f(c))$ qui sera un nombre entre 0 et $m-1$</li>
<li>Soit $L'= L[f(c)]$. $L'$ est une liste composée de couple $(a, b)$. On a alors 2 cas :
<ol>
<li>S'il existe $(c, b)$ dans $L'$ on rend $b$</li>
<li>S'il n'existe pas de couple $(c, b)$ $f(c)$ 'est pas une clé du dictionnaire et on rend une erreur.</li>
</ol>
</li>
</ol>
</li>
</ul>
<p>La fonction d'adressage permet de choisir $m$ pas trop grand. De plus, on peut considérer que son calcul est toujours en $\mathcal{O}(1)$ car elle sera toujours utilisée avec un nombre de taille fixe qui est le hash d'un objet.</p>
<h3>Complexités</h3>
<p>On va estimer la complexité des opérations suivantes :</p>
<ul>
<li>création de la structure</li>
<li>suppression de la structure (liste de liste)</li>
<li>ajout d'un élément à la structure</li>
<li>recherche d'un élément à la structure</li>
<li>suppression d'un élément à la structure</li>
</ul>
<p>On le rappelle, une structure de dictionnaire est constitué d'une liste de $m$ éléments, chaque élément étant lui-même une liste.  L'accès aux données dépend du nombre d'éléments stockés $n$ et de la taille de la liste principale $m$. Si on cherche si la clé <code>c</code> est dans un dictionnaire, il faut regarder chaque élément de la liste stockée à l'indice  $L[f_m(f(c))]$.</p>
<h4>Création de la structure</h4>
<p>La création de la structure est en $\mathcal{O}(m)$ puisqu'il faut créer une liste de $m$ éléments chaque élément étant une liste vide.</p>
<p>Initialement, $m$ est une constante, on a donc :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>La création d'une structure de dictionnaire prend $\mathcal{O}(1)$ opérations.</p>
</div></div>
<h4>Suppression de la structure</h4>
<p>La suppression de la structure en $\mathcal{O}(m)$ (il faut supprimer toutes les listes stockées).</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>La création d'une structure de dictionnaire prend $\mathcal{O}(m)$ opérations, où $m$ est la taille de la liste principale.</p>
</div></div>
<h4>Ajout/recherche et suppression d'un élément</h4>
<p>Les complexités sont identiques car cela revient à chercher si la clé $c$ est déjà stockée ou non dans la structure.</p>
<p>Cette complexité peut aller de :</p>
<ul>
<li>cas le meilleurs : $\mathcal{O}(1)$. Ceci arrive lorsque la liste $L[f_m(f(c))]$ est vide</li>
<li>cas le pire : $\mathcal{O}(n \times K(c)) = \mathcal{O}(n)$ (en considérant que $K(c) = mathcal{O}(1)$). Ceci arrive lorsque tous les éléments de la liste ont même hash, le nombre d'élément de $L[f_m(f(c))]$ sera $n$</li>
<li>cas moyen : $\mathcal{O}(\frac{n}{m})$. Si les clés sont uniformément distribuées, il y aura de l'ordre de $\frac{n}{m}$ éléments dans la liste $L[f_m(f(c))]$.</li>
</ul>
<p>Une astuce permet de diminuer la complexité moyenne.</p>
<h3>Modification de la taille</h3>
<p>Le choix de <code>m</code> détermine la complexité en moyenne. La complexité en moyenne de l'ajout/recherche et suppression d'un élément étant de l'ordre de  $\mathcal{O}(\frac{n}{m})$, si l'on maintient ce ratio à une constante la complexité moyenne sera de $\mathcal{O}(1)$.</p>
<p>C'est pourquoi, lorsque le nombre d'objet stocké augmente et que le ratio augmente, on va de temps en temps recréer un nouveau dictionnaire en doublant la taille allouée pour faire diminuer ce ratio.</p>
<p>Cette technique, identique à celle utilisée dans les <a href="../structure-liste">listes</a> permet de maintenant un ratio à <em>peut prêt constant</em> et donc :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>Le temps moyen de recherche, d'ajout et de suppression d'un élément dans un dictionnaire est de  $\mathcal{O}(1)$ opération.</p>
</div></div>
<p>La structure de dictionnaire est donc une structure très efficace ! N'hésitez pas à l'utiliser car son temps moyen d'exécution est très rapide.</p>
<h2>Exercice</h2>
<ul>
<li>données :
<ul>
<li>une liste de $n$ prix : $p_i$ ($0 \leq i &lt; n$)</li>
<li>un crédit : $C$</li>
</ul>
</li>
<li>Question : donner deux indices $i$ et $j$ tels que $p_i + p_j = C$ ou `None si cela n'existe pas.</li>
</ul>
<p>On va essayer de répondre à cet exercice de trois façons différentes, toutes avec des complexités différentes.</p>
<h3>Deux boucles for imbriquées</h3>
<p>Comme il faut trouver deux indices différents dans la liste $p$ (à $n$ éléments), deux boucles imbriquées allant de $0$ à $n-1$ permettent de balayer tous les couples $(i, j)$ avec $0 \leq i, j &lt; n$.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
<div class="pl-8 mr-8">
<p>Créer cet algorithme et calculez-en sa complexité.</p>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>solution</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">recherche</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">for</span>  <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> C<span class="token punctuation">:</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token boolean">None</span>
</code></pre>
<p>Deux boucles imbriquées et le reste en $\mathcal{O}(1)$ : la complexité totale est en $\mathcal{O}(n^2)$.</p>
</div>
</details>     
</div>
<h3>Une boucle et un tri</h3>
<p>Solution en $\mathcal{O}(n\cdot log(n))$</p>
<p>On trie la liste (ce qui donne la complexité de la solution) puis :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">recherche</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>
    p<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>

    i <span class="token operator">=</span> <span class="token number">0</span>
    j <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span>
    <span class="token keyword">while</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> C<span class="token punctuation">:</span>
        <span class="token keyword">if</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> C<span class="token punctuation">:</span>
            i <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            j <span class="token operator">-=</span> <span class="token number">1</span>
        
        <span class="token keyword">if</span> i <span class="token operator">></span> j<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">None</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span>
</code></pre>
<p>Notez que cette solution est aussi en $\mathcal{O}(n\cdot log(n))$ en moyenne car le tri utilisé par python est de complexité $\mathcal{O}(n\cdot log(n))$ en moyenne.</p>
<h3>Avec un dictionnaire</h3>
<p>solution en $\mathcal{O}(n)$ en moyenne et complexité maximale $\mathcal{O}(n\cdot log(n))$</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">recherche</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">:</span>
    d <span class="token operator">=</span> <span class="token builtin">dict</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> C <span class="token operator">-</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">in</span> d<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span>d<span class="token punctuation">[</span>C<span class="token operator">-</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>
        d<span class="token punctuation">[</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i
    <span class="token keyword">return</span> <span class="token boolean">None</span>
</code></pre>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1000px] mx-auto px-4">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
      </div>
    </footer>

  <script>
    MathJax.startup.document.getMathItemsWithin(document.body);
  </script>

  </body>
</html>