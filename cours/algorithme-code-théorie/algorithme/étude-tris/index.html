<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <title>Etude : algorithmes de tri</title>

    <link href=/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css rel="stylesheet">
    <link href=/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css rel="stylesheet">

    <link href=/cours_informatique/assets/stylesheets/main.css rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" 
  src=/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1000px] mx-auto px-4">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
          <a class="mx-2" href="/cours_informatique/about">About</a>
        </div>
      </div>
    </header>

    <main class="max-w-[1000px] mx-auto px-4">
      
<article>

  <h1  >Etude : algorithmes de tri</h1>
  <div >
    

    
  </div>

  
    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z" />
</svg>
<div class="pl-8 mr-8">

<a href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a href="/cours_informatique/cours/algorithme-code-théorie/">Algorithme, code et théorie</a><span class="px-1">/</span><a href="/cours_informatique/cours/algorithme-code-théorie/algorithme/">Algorithme</a><span class="px-1">/</span><a href="/cours_informatique/cours/algorithme-code-théorie/algorithme/étude-tris/">Etude : algorithmes de tri</a>

</div></div>

  

  <div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-pink-500 bg-pink-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-pink-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Prérequis</strong> :</p>
</div><div class="pl-8 mr-8">
<ul>
<li><a href="../complexit%C3%A9-moyenne">complexité moyenne</a></li>
<li><a href="../../th%C3%A9orie/complexit%C3%A9-probl%C3%A8me">Complexité d'un problème</a></li>
</ul>
</div></div>
<!-- début résumé -->
<p>Etude du problème du tri puis analyse de complexité de quelques algorithmes de tris paradigmatiques.</p>
<!-- end résumé -->
<p>Les informaticiens adorent les <a href="https://fr.wikipedia.org/wiki/">algorithmes de tris</a>. Pas parce qu'ils aiment l'ordre — loin de là — mais parce qu'il existe des millions de façons différentes de trier. Commençons par définir le problème :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Problème :</strong></p>
</div><div class="pl-8 mr-8">
<ul>
<li><strong>nom</strong> : tri</li>
<li><strong>données</strong> : un tableau d'entiers</li>
<li><strong>réponse</strong> : un tableau contenant les valeurs du tableau en entrée triées selon l'ordre croissant</li>
</ul>
</div></div>
<h2>Problème de reconnaissance</h2>
<p>Commençons par travailler sur un problème connexe au problème du tri, celui de la reconnaissance :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Problème :</strong></p>
</div><div class="pl-8 mr-8">
<ul>
<li><strong>nom</strong> : est trié ?</li>
<li><strong>données</strong> : un tableau $T$ d'entiers</li>
<li><strong>réponse</strong> : $T$ est-il trié de façon croissante ?</li>
<li><strong>réponse</strong> : OUI ou NON.</li>
</ul>
</div></div>
<h3 id="algo-est-trie">Algorithme</h3>
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">est_trie</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>

    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> T<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4>Fonctionnement</h4>
<p>L'algorithme rend bien :</p>
<ul>
<li><code class="language-">True</code> pour <code class="language-">est_trie([42])</code></li>
<li><code class="language-">False</code> pour <code class="language-">est_trie([4, 2])</code></li>
<li><code class="language-">True</code> pour <code class="language-">est_trie([2, 4])</code></li>
</ul>
<h4>Preuve</h4>
<p>La finitude de l'algorithme est claire puisqu'il n'y a qu'une boucle for avec autant d'itérations que la taille du tableau passé en entrée.</p>
<p>Le preuve en démontrant l'invariant de boucle : à la fin d'un itération, les $i + 1$ premiers éléments du tableau sont triés.</p>
<ol>
<li>à la fin de la première itération, si l'on est pas sorti de la boucle c'est que $T[i] \geq T[i-1]$ pour $i=1$ : les 2 premiers éléments du tableau sont bien triés.</li>
<li>Si l'invariant est vrai à la fin de l'itération $i-1$, à la fin de l'itération $i$ on à $T[i] \geq T[i-1]$ et comme les $i + 1$ premiers éléments du tableau sont triés : les $i + 1$ premiers éléments du tableau sont triés.</li>
</ol>
<p>Au final :</p>
<ul>
<li>L'invariant prouve que : si on arrive à la ligne 6 de l'algorithme c'est que les $n$ premiers éléments du tableau sont triés.</li>
<li>si on utilise le retour de la ligne 5 c'est qu'il existe $i$ avec $T[i] &lt; T[i-1]$, donc $T$ ne peut être trié.</li>
</ul>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>L'algorithme <code class="language-">est_trie</code> est une solution au problème <em>&quot;est trié ?&quot;</em></p>
</div></div>
<h4>Complexité de l'algorithme</h4>
<p>Ligne à ligne :</p>
<ol>
<li>définition de la fonction $\mathcal{O}(1)$</li>
<li>—</li>
<li>une boucle for de $k$ itérations</li>
<li>un tests de deux valeurs dans un tableau : $\mathcal{O}(1)$</li>
<li>un retour de fonction $\mathcal{O}(1)$</li>
<li>un retour de fonction $\mathcal{O}(1)$</li>
</ol>
<p>Que l'on sorte par le retour de la ligne 5 ou 6, le complexité est : $\mathcal{O}(k)$. Dans le cas le pire, on parcourt tout le tableau, donc :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>La complexité de l'algorithme <code class="language-">est_trie</code> est $\mathcal{O}(n)$ avec $n$ la taille du tableau en entrée.</p>
</div></div>
<h3>Complexité du problème</h3>
<p>Comme toute case du tableau peut rendre le tableau non trié, on utilise l'argument de <a href="../../th%C3%A9orie/complexit%C3%A9-probl%C3%A8me#complexit%C3%A9-recherche">complexité du problème de la <em>&quot;recherche&quot;</em></a>, un algorithme résolvant ce problème doit considérer toutes les cases du tableau et donc une borne min du problème <em>&quot;est trié ?&quot;</em> est $\mathcal{O}(n)$ où $n$ est la taille du tableau en entrée. Comme la complexité de <code class="language-">est_trie</code>  est également de $\mathcal{O}(n)$. On en conclut :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>La complexité du problème <em>&quot;est trié ?&quot;</em> est de $\mathcal{O}(n)$ où $n$ est la taille du tableau en entrée.</p>
</div></div>
<h2>Bornes du problème</h2>
<h3 id="borne-max">Borne maximum</h3>
<p>Étant donné un tableau $T$ de taille $n$, on peut utiliser l'algorithme <code class="language-">permutations(T)</code> de l'<a href="../%C3%A9tude-m%C3%A9lange#algo-toutes-permutations">étude sur les mélanges</a> qui rend toutes les permutations d'un tableau donné en $\mathcal{O}((n+2)!)$ opérations.</p>
<p>Par exemple, l'algorithme <code class="language-">permutations([1, 3, 2])</code> rendra :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre>
<p>C'est une complexité énorme, mais cela nous permet de résoudre notre problème puisque l'algorithme <code class="language-">est_trie</code> permet de savoir si un tableau est trié en $\mathcal{O}(n)$ opérations : on peut résoudre le problème <em>&quot;trie&quot;</em> en énumérant toutes les permutations du tableau passé en paramètre et en vérifiant pour chacune d'entre elle s'il est trié ou non.</p>
<p>Un proposition d'algorithme peut alors être :</p>
<pre class="language-text " style="counter-reset: linenumber 0"><code class="language-text">def trie_long(T):
    possibles = permutations(T)
    pour chaque tableau de possibles:
        si est_trie(tableau):
            rendre tableau
</code></pre>
<p>La complexité de <code class="language-">trie_long</code> est égale à la complexité de <code class="language-">permutations</code>  ($\mathcal{O}(n+2)!$) plus la complexité de  <code class="language-">est_trie</code> ($\mathcal{O}(n)$) multiplié par le nombre de permutations ($n!$) : ce qui donne une complexité finale de $\mathcal{O}(n+2)!$.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>Une borne maximum du problème <em>&quot;tri&quot;</em> existe, et est de complexité $\mathcal{O}((n+2)!)$ où $n$ est la taille du tableau passé en entrée.</p>
</div></div>
<p>Comme <a href="../complexit%C3%A9-max-min#n_factoriel">n! est trop gros</a>, ce n'est vraiment pas un algorithme à utiliser si on peut faire mieux... Mais il nous permet d'énoncer la propriété :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>Pour tout problème algorithmique, s'il existe :</p>
<ul>
<li>un algorithme énumérant tous les cas possibles</li>
<li>un algorithme permettant de vérifier si un cas donné est une solution</li>
</ul>
<p>Alors la combinaison des deux algorithmes est une solution au problème initial.</p>
</div></div>
<p>Souvent les algorithmes produits par la remarque précédente ne sont pas optimaux car on explore bien trop de cas.</p>
<h3>Borne minimum</h3>
<p>Si les éléments du tableau à trier sont tous différents, les permutations de celui-ci sont toutes différentes et une seule est la solution au problème &quot;tri&quot;.</p>
<p>Par exemple, pour un tableau à trois éléments :</p>
<ol>
<li>$[1, 2, 3]$</li>
<li>$[1, 3, 2]$</li>
<li>$[2, 1, 3]$</li>
<li>$[2, 3, 1]$</li>
<li>$[3, 1, 2]$</li>
<li>$[3, 2, 1]$</li>
</ol>
<p>Quelque soit la forme de l'entrée (de 1 à 6), l'algorithme de tri doit rendre la forme 1 : un algorithme de tri doit pouvoir distinguer parmi toutes les permutations du tableau. Comme il y a $n!$  permutations différentes pour un tableau de taille $n$ dont les éléments sont deux à deux différents, tout algorithme de tri doit pouvoir distinguer parmi $n!$ choix, en utilisant la propriété de <a href="../../th%C3%A9orie/complexit%C3%A9-probl%C3%A8me#n-test-2n">nombre de cas à distinguer</a> vue dans la complexité du problème de la <em>&quot;recherche ordonnée&quot;</em>, on en déduit que :</p>
<p>Tout algorithme de tri d'un tableau à $n$ élément doit distinguer parmi $n!$ cas, il est donc au minimum de complexité $\mathcal{O}(\ln(n!))$. On rend cette borne min un peu plus jolie en utilisant le fait que ;</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>Toute fonction en $\mathcal{O}(\ln(n!))$ est également une fonction en $\mathcal{O}(n\ln(n))$ et réciproquement.</p>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<p>On a :</p>
<p>$$ (\frac{n}{2})^{\frac{n}{2}} \leq n \cdot (n-1) \cdot \ ...\ \cdot \frac{n}{2} \leq n! = n \cdot (n-1) \ ... \ \cdot 1 \leq n \cdot \ ...\  \cdot n = n ^n$$</p>
<p>Donc, en passant au $\ln$ :</p>
<p>$$<br>
\ln((\frac{n}{2})^{\frac{n}{2}}) \leq \ln(n!) \leq \ln(n^n)<br>
$$</p>
<p>Et donc, pour $n \geq 4$, on a l'encadrement suivant :</p>
<p>$$<br>
\frac{n}{2}\ln(\frac{n}{2}) \leq \ln(n!) \leq n\ln(n)<br>
$$</p>
<p>Poursuivons en triturant $\ln(\frac{n}{2})$ :</p>
<div>
$$
\begin{array}{lclr}
\ln(\frac{n}{2}) &= &\frac{1}{2}\ln(\frac{n}{2}) + \frac{1}{2}\ln(\frac{n}{2})&\\
\ln(\frac{n}{2}) &\geq& \frac{1}{2}\ln(\frac{4}{2}) + \frac{1}{2}\ln(\frac{n}{2}) & (\mbox{pour } n \geq 4)\\
\ln(\frac{n}{2}) &\geq& \frac{1}{2}(\ln(2) + \ln(\frac{n}{2})) & (\mbox{pour } n \geq 4)\\
\ln(\frac{n}{2}) &\geq& \frac{1}{2}(\ln(2\cdot \frac{n}{2})) & (\mbox{pour } n \geq 4)\\
\ln(\frac{n}{2}) &\geq& \frac{1}{2}(\ln(n)) & (\mbox{pour } n \geq 4)\\
\end{array}
$$
</div>
<p>On combine cette inégalité à notre encadrement précédent pour trouver :</p>
<p>$$<br>
\frac{n}{2}(\frac{1}{2}(\ln(n))) \leq \ln(n!) \leq n\ln(n)<br>
$$</p>
<p>Ce qui se dérive directement, pour $n \geq 4$, en :</p>
<p>$$\frac{1}{4} \leq \frac{\ln(n!)}{n\ln(n)} \leq 1$$</p>
<p>Enfin, on peut montrer les équivalences de $\mathcal{O}$ :</p>
<ul>
<li>si $g(n)$ est en $\mathcal{O}(\ln(n!))$ il existe $N_0$ et $C$ tel que : $g(n) &lt; C \cdot \ln(n!)$ pour n &gt; $N_0$. Pour $N_1 = \max(N_0, 4)$ on a donc $g(n) &lt; C \cdot \ln(n!) &lt; C \cdot n\ln(n)$ : $g(n)$ est en $\mathcal{O}(n\ln(n))$.</li>
<li>si $g(n)$ est en $\mathcal{O}(n\ln(n))$ il existe $N_0$ et $C$ tel que : $g(n) &lt; C \cdot n\ln(n)$ pour n &gt; $N_0$. Pour $N_1 = \max(N_0, 4)$ on a donc $g(n) &lt; C \cdot \ln_2(n!) &lt; C \cdot 4 \cdot \ln(n!)$ : $g(n)$ est en $\mathcal{O}(\ln(n!))$.</li>
</ul>
</div>
</details>     
</div>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Tout algorithme de tri d'une liste à $n$ éléments a au moins une complexité de $\mathcal{O}(n\ln(n))$ opérations.</p>
</div></div>
<p>Une borne min du problème du <em>&quot;tri&quot;</em> est donc $\mathcal{O}(n\ln(n))$ où $n$ est la taille du tableau en entrée, mais on ne sait pas encore si un tel algorithme existe.</p>
<h2>Tris <em>simples</em></h2>
<p>Notre algorithme pour trier un tableau est un monstre de complexité. Il en existe de très simples et de complexité bien plus faible. Nous en montrons 2, classiques.</p>
<h3 id="tri-sélection">Tri par sélection</h3>
<p>L'algorithme procède alors ainsi : à chaque itération de l'algorithme, on place à l'indice $i$ du tableau son $i$-ème plus petit élément.</p>
<p>On en déduit l'algorithme en pseudo-code suivant :</p>
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> sélection<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        min_index <span class="token operator">=</span> i
        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">if</span> T<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> T<span class="token punctuation">[</span>min_index<span class="token punctuation">]</span><span class="token punctuation">:</span>
                min_index <span class="token operator">=</span> j
        T<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> T<span class="token punctuation">[</span>min_index<span class="token punctuation">]</span> <span class="token operator">=</span> T<span class="token punctuation">[</span>min_index<span class="token punctuation">]</span><span class="token punctuation">,</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>L'algorithme <code class="language-">sélection</code> <strong>modifie</strong> le tableau passé en paramètre. On appelle ces algorithmes <a href="https://en.wikipedia.org/wiki/In-place_algorithm">in place</a> car ils ne rendent rien, mais modifient les données en entrées.</p>
<h4 id="fonctionnement-sélection">Fonctionnement</h4>
<p>On vérifie que l'algorithme fonctionne pour :</p>
<ul>
<li>un petit tableau trié : <code class="language-">[1, 2, 3]</code></li>
<li>un petit tableau non trié où le plus petit est en dernière place : <code class="language-">[3, 2, 1]</code></li>
</ul>
<h4 id="preuve-sélection">Preuve</h4>
<p>Le principe de fonctionnement est clair. Il reste à prouver que c'est bien ce que l'algorithme <code class="language-">sélection</code> fait.</p>
<ol>
<li>la boucle <code class="language-">for</code> de la ligne 4 trouve l'indice du plus petit élément du tableau <code class="language-">T[i:]</code>.</li>
<li>la ligne 7 échange le minimum du tableau <code class="language-">T[i:]</code> avec <code class="language-">T[i]</code></li>
<li>comme la boucle <code class="language-">for</code> de la ligne 2 incrémente $i$, on a l'invariant de boucle : <em>&quot;à la fin de chaque étape $i$ de l'algorithme les $i$ plus petites valeurs du tableau sont triées aux $i$ premiers indices du tableau&quot;</em></li>
</ol>
<h4 id="complexités-sélection">Complexités</h4>
<p>On suppose que la taille du tableau est $n$.</p>
<p>Ligne à ligne :</p>
<ol>
<li>début de fonction : $\mathcal{O}(1)$</li>
<li>une boucle de $n-1$ itérations</li>
<li>une affectation $\mathcal{O}(1)$</li>
<li>une boucle de $n-i-1$ itérations ($i$ est la variable définie ligne 2)</li>
<li>un test et deux valeurs d'un tableau : $\mathcal{O}(1)$</li>
<li>une affectation : $\mathcal{O}(1)$</li>
<li>deux affectation et quatre valeurs d'un tableau : $\mathcal{O}(1)$</li>
</ol>
<p>Le nombre d'itérations de la boucle for de la ligne 4 n'est pas constant, mais il décroît puisque $i$ augmente à chaque itération de la boucle <code>for</code>de la ligne 2. On peut alors utiliser la <a href="../complexit%C3%A9-max-min#r%C3%A8gle-croissance">règle de croissance</a> pour utiliser le maximum, $n-1$, pour le calcul de la complexité.</p>
<p>Ce qui donne une complexité de :</p>
<div>
$$
\begin{array}{lcl}
C & = & \mathcal{O}(1) + \\
&& (n-1) \cdot (\\
&& \mathcal{O}(1) + \\
&& (n-1) \cdot ( \\
&& \mathcal{O}(1) + \\
&& \mathcal{O}(1)) + \\
&& \mathcal{O}(1)) \\
& = & \mathcal{O}(1) + (n-1) \cdot (\mathcal{O}(1) + (n-1) \cdot (\mathcal{O}(1))\\
& = & \mathcal{O}(n^2) \\
\end{array}
$$
</div>
<p>Le nombre d'itérations est constant quelque soit le tableau, on a donc :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>La complexité de l'algorithme <code class="language-">sélection</code> est ($n$ est la taille du tableau passé en entrée) :</p>
<ul>
<li>la <strong>complexité min</strong> vaut $\mathcal{O}(n^2)$</li>
<li>la <strong>complexité (max)</strong> vaut $\mathcal{O}(n^2)$</li>
<li>la <strong>complexité en moyenne</strong> vaut également $\mathcal{O}(n^2)$ (car les complexités min et max sont égales)</li>
</ul>
</div></div>
<h3 id="tri-insertion">Tri par insertion</h3>
<p>Le tri par insertion est une extension de l'<a href="./#algorithme-algo-est-trie">algorithme <code>est_trie</code></a>. Plutôt que de rendre <code class="language-">False</code> il répare. L'algorithme <code class="language-">est_trie</code> répond <code class="language-">False</code> au plus petit <code class="language-">i</code> tel que <code class="language-">T[i] &lt; T[i-1]</code>. On est alors dans le cas où :</p>
<ul>
<li><code class="language-">T[:i]</code> est trié</li>
<li>et <code class="language-">T[i] &lt; T[i-1]</code></li>
</ul>
<p>Pour que l'on puisse continuer, il faut s'arranger pour que <code class="language-">T[:i+1]</code> soit trié. Pour cela, on peut utiliser le fait que <code class="language-">T[:i+1]</code> est trié si et seulement si :</p>
<ul>
<li><code class="language-">T[1] &gt;= T[0]</code></li>
<li><code class="language-">T[2] &gt;= T[1]</code></li>
<li>...</li>
<li><code class="language-">T[i] &gt;= T[i-1]</code></li>
</ul>
<p>Dans notre cas, toutes les conditions sont vérifiées sauf la dernière. Si l'on échange <code class="language-">T[i]</code> et <code class="language-">T[i-1]</code> toutes les conditions seront vérifiées sauf peut-être l'avant-dernière. Si elle n'est pas vérifiée on peut échanger <code class="language-">T[i-1]</code> et <code class="language-">T[i-1]</code> et alors toutes les conditions seront vérifiées sauf peut-être l'avant-avant-dernière, que l'on peut à nouveau échanger, et ainsi de suite jusqu'à ce que toutes les conditions soient vérifiées.</p>
<p>Cette analyse (ce n'est pas encore une preuve formelle) nous permet de dégager le principe suivant :</p>
<p>On vérifie itérativement que <code class="language-">T[i] &gt;= T[i-1]</code> et si ce n'est pas le cas on fait <em>remonter</em> <code class="language-">T[i]</code> par échanges successifs à la première place où il sera plus grand que le précédent.</p>
<p>Ce qui se traduit en pseudo-code :</p>
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">insertion</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        courant <span class="token operator">=</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        j <span class="token operator">=</span> i
        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">and</span> <span class="token punctuation">(</span>courant <span class="token operator">&lt;</span> T<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
            T<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> T<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>
            j <span class="token operator">-=</span> <span class="token number">1</span>
        T<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> courant
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>L'algorithme <code class="language-">insertion</code>, comme l'algorithme <code class="language-">sélection</code>, <strong>modifie</strong> le tableau passé en paramètre.</p>
<p>Pour garantir que <code class="language-">T[j - 1]</code> soit toujours valide (il faut que $j-1 \geq 0$), on place en tête de la condition <code class="language-">(courant &lt; T[j - 1])</code> de la ligne 5 la <a href="https://en.wikipedia.org/wiki/Sentinel_value">sentinelle</a> <code class="language-">(j &gt; 0)</code>. Les deux conditions étant liées par un <code class="language-">and</code>, python (et tout autre langage de programmation) n'évaluera la seconde condition <strong>que si la première est vérifiée</strong> (un <code class="language-">and</code> ne peut être vrai que si les deux conditions sont vraies. Si la première condition est fausse, il est impossible que le <code class="language-">and</code> soit vrai il est donc inutile de vérifier la seconde condition). Cette technique est très utile, ça vaut le coup de la connaître.</p>
<h4 id="fonctionnement-insertion">Fonctionnement</h4>
<p>Tout comme pour l'algorithme de tri par sélection, on vérifie que l'algorithme fonctionne pour :</p>
<ul>
<li>un petit tableau trié : <code class="language-">[1, 2, 3]</code></li>
<li>un petit tableau non trié où le plus petit est en dernière place : <code class="language-">[3, 2, 1]</code></li>
</ul>
<h4 id="preuve-insertion">Preuve</h4>
<p>Le principe de programmation du tri par insertion est correct puisque <code class="language-">est_trie</code> est prouvé. Mais il faut vérifier qu'il est bien mis en œuvre dans l'algorithme. On utilise ici celui donné en solution.</p>
<p>Tout d'abord, comme la condition de la boucle <code class="language-">while</code> de la ligne 5 contient <code class="language-">(j &gt; 0)</code> et que <code class="language-">j</code> décroît strictement à chaque itération (ligne 7), notre algorithme va bien s'arrêter.</p>
<p>A chaque itération $i$ de la boucle <code class="language-">for</code> (ligne 2), l'algorithme fonctionne ainsi :</p>
<ul>
<li>ligne 3 : on a : <code class="language-">T[:i+1] = T[:i] + [courant]</code></li>
<li>à la sortie de la boucle <code class="language-">while</code>, juste avant la ligne 8. En notant <code class="language-">T</code> le tableau avant la boucle <code class="language-">while</code> et <code class="language-">T'</code> le tableau en fin de <code class="language-">while</code>, on a :
<ul>
<li><code class="language-">T'[:i+1] = T[:j] + [T[j]] + T[j:i]</code></li>
<li><code class="language-">T[:j]</code> trié et <code class="language-">courant &gt;= T[j-1]</code></li>
<li><code class="language-">T[j:i]</code> trié <code class="language-">courant &lt; T[j]</code></li>
</ul>
</li>
<li>après la ligne 8, juste avant de faire une nouvelle itération de la boucle <code class="language-">for</code>. En notant <code class="language-">T</code> le tableau avant le début de l'itération et <code class="language-">T</code> le tableau en fin d'itération', on a : <code class="language-">T'[:i+1] = T[:j] + [T[i]] + T[j:i]</code></li>
</ul>
<p>Notre invariant de boucle est donc : <em>&quot;à la fin de l'itération i, les i premiers éléments du tableau sont triés&quot;</em></p>
<h4 id="complexités-insertion">Complexités</h4>
<p>Ligne à ligne :</p>
<ol>
<li>appel de fonction : $\mathcal{O}(1)$</li>
<li>$n-1$ itérations, avec $n$ la taille du tableau</li>
<li>affectation d'une variable et récupération d'un élément d'un tableau : $\mathcal{O}(1)$</li>
<li>affectation d'une variable : $\mathcal{O}(1)$</li>
<li>$k$ itérations et deux tests en $\mathcal{O}(1)$ pour chaque itération</li>
<li>affectation d'une variable et récupération d'un élément d'un tableau : $\mathcal{O}(1)$</li>
<li>une soustraction et une affectation : $\mathcal{O}(1)$</li>
<li>affectation d'une variable et récupération d'un élément d'un tableau : $\mathcal{O}(1)$</li>
</ol>
<p>Comme $k$ n'est pas constant pour chaque itération de la boucle <code class="language-">for</code> il faut regarder les valeurs extrêmes que peut prendre $k$ :</p>
<ul>
<li>si le tableau est déjà trié : on ne rentre jamais dans la boucle <code class="language-">while</code> : $k = 0$ pour chaque itération.</li>
<li>si le tableau est trié à l'envers : pour la $i$-ème itération de la boucle <code class="language-">for</code>, on aura $k=i$. C'est de plus le maximum théorique possible ($j=i$ initialement et j décroît de 1 à chaque itération de la boucle <code>while</code>).</li>
</ul>
<p>On a donc 2 cas extrêmes pour le calcul :</p>
<ol>
<li>$k = 0$ à chaque itération</li>
<li>$k$ croit de $1$ à $n-1$ à chaque itération : la <a href="../complexit%C3%A9-max-min#r%C3%A8gle-croissance">règle de croissance</a> nous indique qu'on peut considérer que $k=n-1$ pour le calcul de la complexité</li>
</ol>
<p>Ce qui donne une complexité de :</p>
<div>
$$
\begin{array}{lcl}
C & = & \mathcal{O}(1) + \\
&& (n-1) \cdot (\\
&& \mathcal{O}(1) + \\
&& \mathcal{O}(1) + \\
&& k \cdot (\mathcal{O}(1) + \\
&& \mathcal{O}(1) + \\
&& \mathcal{O}(1)) + \\
&& \mathcal{O}(1)) \\
& = & \mathcal{O}(1) + (n-1) \cdot (\mathcal{O}(1) + k \cdot (\mathcal{O}(1))\\
& = & \mathcal{O}(n \cdot (k + 1)) \\
\end{array}
$$
</div>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>La complexité de l'algorithme <code class="language-">insertion</code> est ($n$ est la taille du tableau passé en entrée) :</p>
<ul>
<li>la <strong>complexité min</strong> est atteinte pour $k=0$, c'est à dire lorsque le tableau est déjà trié, et vaut $\mathcal{O}(n)$</li>
<li>la <strong>complexité (max)</strong> est atteinte pour $k=n-1$, c'est à dire lorsque le tableau est trié par ordre décroissant, et vaut $\mathcal{O}(n^2)$</li>
</ul>
</div></div>
<p>La complexité min est différente de la complexité maximale. On va donc calculer la complexité en moyenne pour connaître la complexité pour des données <em>standard</em>.<br>
Pour savoir ce que veut dire <em>standard</em>, il faut déterminer le modèle de données : prenons le équiprobable.</p>
<p>Cela signifie que pour chaque itération $i$ :</p>
<ul>
<li><code class="language-">T[i]</code> sera bien placé pour une proportion de $\frac{1}{i + 1}$ tableaux</li>
<li><code class="language-">T[i]</code> devra être positionné en $i-1$ pour une proportion de $\frac{1}{i + 1}$ tableaux,</li>
<li>...</li>
<li><code class="language-">T[i]</code> devra être positionné en $i-j$ pour une proportion de $\frac{1}{i + 1}$ tableaux,</li>
<li>...</li>
<li><code class="language-">T[i]</code> devra être positionné en $0$ pour une proportion de $\frac{1}{i + 1}$ tableaux.</li>
</ul>
<p>La complexité en moyenne sera donc égale à :</p>
<div>
$$
\begin{array}{lcl}
C_m &=& \mbox{complexité hors boucle for} + \sum_{i=1}^{n-1}(\mbox{complexité hors boucle while} + i \cdot (\mbox{complexité boucle while}))\\
&=& \mathcal{O}(1) + \sum_{i=1}^{n-1} (\mathcal{O}(1) + i \cdot \mathcal{O}(1))\\
&=& \mathcal{O}(1) \cdot \sum_{i=1}^{n-1} i \\
&=& \mathcal{O}(1) \cdot \frac{n(n-1)}{2} \\
&=& \mathcal{O}(n^2)\\
\end{array}
$$
</div>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>La <strong>complexité en moyenne</strong> de l'algorithme <code class="language-">insertion</code> est $\mathcal{O}(n^2)$ où $n$ est la taille du tableau passé en entrée.</p>
</div></div>
<p>Le cas le meilleur arrive très rarement par rapport au cas le pire (parmi les $n!$ ordres possibles, il y en a très peu qui sont presque triés).</p>
<p>Si l'on change le modèle de données et que l'on considère des tableaux <em>presque triées</em>, la complexité en moyenne va être de l'ordre de la complexité minimale, à savoir : $\mathcal{O}(n)$</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>On utilise le tri par insertion lorsque nos données seront presque toujours déjà triées ou très peu en désordre.</p>
</div></div>
<p>Ce calcul de complexité nous permet d'utiliser la règle suivante, qui va se révéler très utile :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>Soit $A$ un ensemble de $n$ nombres aléatoires, et $x$ un nombre également aléatoire.<br>
Pour tout $ y \in A$, il y a 50% de chances que $x \leq y$. Il y a donc en moyenne $\frac{n}{2}$ éléments de $A$ qui sont plus grand que $x$.</p>
</div></div>
<h2>Tri fusion</h2>
<p>Le <a href="https://fr.wikipedia.org/wiki/Tri_fusion">tri fusion</a> est un tri de complexité $\mathcal{O}(n\ln(n))$ opérations où $n$ est la taille de la liste en entrée. Il fonctionne selon principe algorithme de <a href="https://fr.wikipedia.org/wiki/Diviser_pour_r%C3%A9gner_(informatique)">diviser pour régner</a> :</p>
<p><span id="diviser-pour-régner"></span></p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>Un algorithme de la forme <em><strong>diviser pour régner</strong></em> fonctionne en deux parties :</p>
<ol>
<li><strong>résoudre</strong> $k$ sous-problèmes du problème initial</li>
<li><strong>combiner</strong> les $k$ solutions des sous-problèmes en une solution du problème initial</li>
</ol>
<p>Puisqu'il suffit de s'utiliser lui-pour résoudre les sous-problèmes sa forme générale est :</p>
<pre class="language-text " style="counter-reset: linenumber 0"><code class="language-text">def algorithme(données):
    A partir de données créer $k$ données_partielles_i (1 ≤ i ≤ k)
    pour chaque i allant de 1 à k:
        solution_i = algorithme(données_partielles_i)
    
    solution = combiner(solution_1, ..., solution_k)

    rendre solution
</code></pre>
</div></div>
<p>L'intérêt de ces programme est que si la complexité de la fonction <code class="language-">combiner</code> est faible, la complexité de l'<code class="language-">algorithme</code> également.</p>
<h3>Combiner</h3>
<p>Pour un tri, si on scinde le tableau le tableau en tableau plus petit que l'on tri, le but de la fonction <code class="language-">combiner</code> est de créer un tableau trié à partir de tableaux <strong>triés</strong>.</p>
<p>L'algorithme ci-après le fait de façon optimale, en $\mathcal{O}(\vert T1 \vert + \vert T2 \vert)$ :</p>
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">combiner</span><span class="token punctuation">(</span>T1<span class="token punctuation">,</span> T2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    i1 <span class="token operator">=</span> i2 <span class="token operator">=</span> <span class="token number">0</span>
    T <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">while</span> i1 <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T1<span class="token punctuation">)</span> <span class="token keyword">or</span> i2 <span class="token operator">&lt;</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> i2 <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T2<span class="token punctuation">)</span><span class="token punctuation">:</span>
            T<span class="token punctuation">.</span>append<span class="token punctuation">(</span>T1<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token punctuation">)</span>
            i1 <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">elif</span> i1 <span class="token operator">==</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T1<span class="token punctuation">)</span><span class="token punctuation">:</span>
            T<span class="token punctuation">.</span>append<span class="token punctuation">(</span>T2<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">)</span>
            i2 <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">elif</span> T1<span class="token punctuation">[</span>i1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> T2<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">:</span>
            T<span class="token punctuation">.</span>append<span class="token punctuation">(</span>T1<span class="token punctuation">[</span>i1<span class="token punctuation">]</span><span class="token punctuation">)</span>
            i1 <span class="token operator">+=</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            T<span class="token punctuation">.</span>append<span class="token punctuation">(</span>T2<span class="token punctuation">[</span>i2<span class="token punctuation">]</span><span class="token punctuation">)</span>
            i2 <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">return</span> T
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="fonctionnement-colle">Fonctionnement</h4>
<p>On vérifie pour deux petits tableaux <strong>triés</strong>. Par exemple pour <code class="language-">T1=[1, 4, 7]</code> et <code class="language-">T2=[0, 2, 3, 98]</code>. <code class="language-">T</code> vaudra :</p>
<ol>
<li><code class="language-">[0]</code> après la 1ère itération (<code class="language-">i1=0</code> et <code class="language-">i2=1</code>)</li>
<li><code class="language-">[0, 1]</code> après la 2nde itération (<code class="language-">i1=1</code> et <code class="language-">i2=1</code>)</li>
<li><code class="language-">[0, 1, 2]</code> après la 3ème itération (<code class="language-">i1=1</code> et <code class="language-">i2=2</code>)</li>
<li><code class="language-">[0, 1, 2, 3]</code> après la 4ème itération (<code class="language-">i1=1</code> et <code class="language-">i2=3</code>)</li>
<li><code class="language-">[0, 1, 2, 3, 4]</code> après la 5ème itération (<code class="language-">i1=2</code> et <code class="language-">i2=3</code>)</li>
<li><code class="language-">[0, 1, 2, 3, 4, 7]</code> après la 6ème itération (<code class="language-">i1=3</code> et <code class="language-">i2=3</code>)</li>
<li><code class="language-">[0, 1, 2, 3, 4, 7, 98]</code> après la 7ème itération (<code class="language-">i1=3</code> et <code class="language-">i2=4</code>)</li>
</ol>
<h4 id="preuve-colle">Preuve</h4>
<p>L'algorithme se finit bien puisqu'à chaque itération de la boucle while soit <code class="language-">i1</code> soit <code class="language-">i2</code> augmente. Au bout de <code class="language-">len(T1) + len(T2)</code> itération on aura <code class="language-">i1</code> = <code class="language-">len(T1)</code> et <code class="language-">i2</code> = <code class="language-">len(T1)</code>, donc la condition <code class="language-">i1 &lt; len(T1) or i2 &lt; len(T2)</code> ne sera plus vérifiée.</p>
<p>L'invariant de boucle que l'on peut facilement prouver est :</p>
<blockquote>
<p>à la fin de chaque itération, <code class="language-">T[:i1 +i2]</code> est trié et contient les <code class="language-">i1</code> premiers éléments de <code class="language-">T1</code> et les <code class="language-">i2</code> premiers éléments de <code class="language-">T2</code></p>
</blockquote>
<h4 id="complexités-colle">Complexités</h4>
<p>Allons un peu plus vite :</p>
<ul>
<li>on a une boucle <code class="language-">while</code> de <code class="language-">len(T1) + len(T2)</code> itérations</li>
<li>chaque ligne de l'algorithme est en $\mathcal{O}(1)$</li>
</ul>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>La complexité max et min de <code class="language-">colle</code> est $\mathcal{O}(n_1 + n_2)$ avec $n_1$ et $n_2$ les tailles des tableaux <code class="language-">T1</code> et <code class="language-">T2</code> respectivement.</p>
</div></div>
<h3>Pseudo-code</h3>
<p>Avec notre fonction <code class="language-">combiner(T1, T2)</code> le pseudo code de l'algorithme fusion est :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">
<span class="token keyword">def</span> <span class="token function">fusion</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> T
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        milieu <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>
        T1 <span class="token operator">=</span> T<span class="token punctuation">[</span><span class="token punctuation">:</span>milieu<span class="token punctuation">]</span>
        T2 <span class="token operator">=</span> T<span class="token punctuation">[</span>milieu<span class="token punctuation">:</span><span class="token punctuation">]</span>

        T1_trié <span class="token operator">=</span> fusion<span class="token punctuation">(</span>T1<span class="token punctuation">)</span>
        T2_trié <span class="token operator">=</span> fusion<span class="token punctuation">(</span>T2<span class="token punctuation">)</span>
        T_trié <span class="token operator">=</span> combiner<span class="token punctuation">(</span>T1_trié<span class="token punctuation">,</span> T2_trié<span class="token punctuation">)</span>
    
        <span class="token keyword">return</span> T_trié 

</code></pre>
<h3 id="preuve-fusion">Preuve</h3>
<p>Comme  <code class="language-">milieu &lt; len(T)</code> si <code class="language-">len(T) &gt; 1</code>, l'algorithme va bien converger. De plus, comme l'algorithme <code class="language-">combiner</code> est démontré, <code class="language-">fusion</code> est bien un algorithme de tri.</p>
<h3 id="complexités-fusion">Complexités</h3>
<p>La complexité de l'algorithme <code class="language-">fusion</code> est (avec $n$ la taille du tableau passé en entrée) :</p>
<p>$$C(n) = 2 \cdot C(\frac{n}{2}) + D(n)$$</p>
<p>Où :</p>
<ul>
<li>$C(n)$ est la complexité de l'algorithme fusion pour une liste à $n$ éléments (algorithme <code>fusion</code>)</li>
<li>$D(n)$ est la complexité de fusionner deux listes triées en une unique liste triées (algorithme <code class="language-">combiner</code>).</li>
</ul>
<p>Comme l'algorithme <code class="language-">combiner</code> est en $\mathcal{O}(n)$, l'équation de récurrence de la complexité est :</p>
<p>$$C(n) = 2 \cdot C(\frac{n}{2}) + \mathcal{O}(n)$$</p>
<p>Pour connaître la valeur de la complexité on utilise le <a href="https://fr.wikipedia.org/wiki/Master_theorem">master theorem</a> qui est <strong>LE</strong> théorème des complexités pour les algorithmes récursifs. Son énoncé nous permet de déterminer aisément la complexité de nombreux algorithmes récursifs :</p>
<p><span id="master-theorem"></span></p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><a href="https://fr.wikipedia.org/wiki/Master_theorem"><strong>Master Theorem</strong></a> :</p>
</div><div class="pl-8 mr-8">
<p>Si la complexité est de la forme :</p>
<div>
$$
C(n) = a \cdot C(\frac{n}{b}) + \mathcal{O}(n^d)
$$
</div>
<p>Alors :</p>
<ul>
<li>$C(n)  = \mathcal{O}(n^d \cdot \ln(n))$ si $a=b^d$</li>
<li>$C(n)  = \mathcal{O}(n^{\log_b(a)})$ si $a&gt;b^d$</li>
<li>$C(n)  = \mathcal{O}(n^d)$ si si $a&lt;b^d$</li>
</ul>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<p>La forme de $C(n)$ est $C(n) = a \cdot C(\frac{n}{b}) + f(n)$  où $f(n)$ est une fonction en $\mathcal{O}(n^d)$. Ceci signifie qu'il existe $N_0$ tel que pour tout $n \geq N_0$, on a $f(n) \leq  n^d$. De là, pour $n \geq n_0$ on a :</p>
<div>
$$
C(n) \leq a \cdot C(\frac{n}{b}) + n^d
$$
</div>
<p>On en conclut que si la complexité de la fonction $C'(n) = a \cdot C'(\frac{n}{b}) + n^d$ est en $\mathcal{O}(g(n))$, alors $C(n)$ le sera aussi.</p>
<div>
$$
\begin{array}{lcl}
C'(n) &=&a \cdot C'(\frac{n}{b}) + n^d \\
&=& a\cdot (a \cdot C'(\frac{n}{b^2}) + (\frac{n}{b})^d) + n^d\\
&=& a^2 \cdot C'(\frac{n}{b^2}) + n^d \cdot (1 + \frac{a}{b^d})\\
&=& a^2 \cdot (a \cdot C'(\frac{n}{b^3}) + (\frac{n}{b^2})^d) + n^d \cdot (1 + \frac{a}{b^d})\\
&=& a^3 \cdot C'(\frac{n}{b^3}) + n^d \cdot (1 + \frac{a}{b^d} + (\frac{a}{b^d})^2)\\
&=& \dots \\
&=& n^d \cdot \sum_{i=0}^{\log_b(n)}(\frac{a}{b^d})^i) + a^{\log_b(n)}(C'(1))\\
&=& n^d \cdot \sum_{i=0}^{\log_b(n)}(\frac{a}{b^d})^i + a^{\log_b(n)}\\
\end{array}
$$
</div>
<p>Comme $a^{\log_b(n)} = \exp(\ln(a) \cdot \frac{\ln(n)}{\ln(b)} ) = \exp(\ln(n) \cdot \frac{\ln(a)}{\ln(b)} ) = n^{\log_b(a)}$ on en conclut que :</p>
<div>
$$
C'(n) = n^d \cdot \sum_{i=0}^{\log_b(n)}(\frac{a}{b^d})^i + n^{\log_b(a)}
$$
</div>
<p>Il y a alors plusieurs cas. Commençons par étudier le cas où $\frac{a}{b^d} = 1$. On a alors :</p>
<div>
$$
C'(n) = n^d \cdot \sum_{i=0}^{\log_b(n)}1 + n^d = n^d(\log_b(n) +1)
$$
</div>
<p>On a alors que $C'(n) = \mathcal{O}(n^d \cdot \ln(n))$ si $d = \log_b(a)$.</p>
<p>Si $\frac{a}{b^d} \neq 1$, on peut utiliser le fait que $\sum_{i=0}^k(x^k) = \frac{x^{k+1} -1}{x-1}$ pour obtenir :</p>
<div>
$$
C'(n) = n^d \cdot \frac{(\frac{a}{b^d})^{\log_b(n) +1} -1}{\frac{a}{b^d}-1} + n^{\log_b(a)} = n^d \cdot \frac{\frac{a}{b^d}\cdot\frac{n^{\log_b(a)}}{n^d} -1}{\frac{a}{b^d}-1} + n^{\log_b(a)} = \frac{\frac{a}{b^d}\cdot n^{\log_b(a)} - n^d}{\frac{a}{b^d}-1} + n^{\log_b(a)}
$$
</div>
<p>On en déduit facilement que si :</p>
<ul>
<li>$\frac{a}{b^d} &lt; 1$ alors $C'(n) = \mathcal{O}(n^d)$</li>
<li>$\frac{a}{b^d} &gt; 1$ alors $C'(n) = \mathcal{O}(n^{\log_b(a)})$</li>
</ul>
</div>
</details>     
</div>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
</svg>
<div class="pl-8 mr-8">
<p>On voit parfois le master theorem exprimé en fonction de $d$ et $\log_b(a)$, ce qui est équivalent puisque $a = b^d$ est équivalent à $d = \log_b(a)$</p>
</div></div>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
</svg>
<div class="pl-8 mr-8">
<p>Le master theorem est la raison pour laquelle vous verrez parfois des complexités avec des exposants non entiers</p>
</div></div>
<p>Dans notre cas on a $a = 2$, $b = 2$  et $d = 1$ donc $a=b^d$ :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>La complexité de l'algorithme <code class="language-">fusion</code> est $\mathcal{O}(n\ln(n))$ où $n$ est la taille de la liste en entrée</p>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>Calcul de la complexité sans utiliser le master theorem</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<div>
$$
\begin{array}{lcl}
C(n) &=& 2 \cdot C(\frac{n}{2}) + \mathcal{O}(n)\\
&=& 2 \cdot (2 \cdot (C(\frac{n}{4}) + \mathcal{O}(\frac{n}{2})) + \mathcal{O}(n)\\
&=& 2^2 \cdot C(\frac{n}{2^2}) + 2 \cdot \mathcal{O}(\frac{n}{2}) + \mathcal{O}(n)\\
&=& 2^2 \cdot C(\frac{n}{2^2}) + 2 \cdot \mathcal{O}(n)\\
&=& ...\\
&=& 2^k \cdot C(\frac{n}{2^k}) + k \cdot \mathcal{O}(n)\\
&=& ...\\
&=& 2^{\log_2(n)} \cdot C(1) + \log_2(n) \cdot \mathcal{O}(n)\\
&=& n \cdot C(1) + \log_2(n) \cdot \mathcal{O}(n)\\
&=& \mathcal{O}(n) + \log_2(n) \cdot \mathcal{O}(n)\\
&=& \mathcal{O}(n\log_2(n))\\
&=& \mathcal{O}(n\ln(n))
\end{array}
$$
</div>
</div>
</details>     
</div>
<p>Tout comme le tri par sélection, le tri fusion a la particularité d'avoir toujours le même nombre d'opérations quelque soit la liste en entrée.</p>
<h2>Tri de python</h2>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">
T <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
T<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span>

</code></pre>
<p>Le tri de python est <strong>in place</strong>. L'algorithme utilisé est <a href="https://en.wikipedia.org/wiki/Timsort">timsort</a>, mix entre le tri fusion et le tri par insertion. C'est un tri très efficace puisque :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>Pour un tableau de taille $n$ :</p>
<ul>
<li>La complexité de l'algorithme timsort est $\mathcal{O}(n\ln(n))$</li>
<li>La complexité min de l'algorithme timsort est $\mathcal{O}(n)$</li>
<li>La complexité en moyenne de l'algorithme timsort est $\mathcal{O}(n\ln(n))$</li>
</ul>
</div></div>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
</svg>
<div class="pl-8 mr-8">
<p>Ne perdez donc pas de temps à recoder un algorithme de tri : utilisez celui de python !</p>
</div></div>
<h2 id="tri-rapide">Tri rapide</h2>
<p>Le tri rapide est un algorithme qui a été très utilisé par le passé. On le montre encore maintenant car c'est un exemple de <a href="./#diviser-pour-r%C3%A9gner">diviser pour régner</a> et, surtout, le calcul des complexités est très intéressant.</p>
<p>Le principe est ici de séparer le tableau en entrée <code class="language-">T</code> en 2 tableaux <code class="language-">T1</code> et <code class="language-">T2</code> et une valeur nommé <code class="language-">pivot</code> de tel sorte que :</p>
<ul>
<li>toutes les valeurs de <code class="language-">T1</code> soient plus petites que <code class="language-">pivot</code></li>
<li>toutes les valeurs de <code class="language-">T2</code> soient strictement plus grande que <code class="language-">pivot</code></li>
</ul>
<p>On a coutume de prendre pivot comme étant <code class="language-">T[0]</code>.</p>
<p>Une fois ce découpage des données fait, la fonction <code class="language-">combiner</code> est triviale puisqu'il suffit de concaténer <code class="language-">T1</code> trié à <code class="language-">[T[0]]</code> puis à <code class="language-">T2</code> trié.</p>
<p>En pseudo-code cela donne :</p>
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">rapide</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> T

    pivot <span class="token operator">=</span> T<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>

    T1 <span class="token operator">=</span> <span class="token punctuation">[</span>T<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">]</span>
    T2 <span class="token operator">=</span> <span class="token punctuation">[</span>T<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> pivot<span class="token punctuation">]</span>

    <span class="token keyword">return</span> rapide<span class="token punctuation">(</span>T1<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">[</span>pivot<span class="token punctuation">]</span> <span class="token operator">+</span> rapide<span class="token punctuation">(</span>T2<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
</svg>
<div class="pl-8 mr-8">
<p>On a utilisé les <a href="https://python.doctor/page-comprehension-list-listes-python-cours-debutants">list comprehension</a> de python. C'est un moyen clair et efficace de générer des listes. Utilisez-les, ça rend le code plus clair et facile à écrire.</p>
</div></div>
<h3 id="preuve-rapide">Preuve</h3>
<p>Comme <code class="language-">rapide</code> est une implémentation de la méthode diviser pour régner, son fonctionnement est assuré <strong>si</strong> les récursions s'arrêtent.</p>
<p>C'est effectivement le cas ici puisque les tableaux  <code class="language-">T1</code> et  <code class="language-">T2</code> sont strictement plus petit que  <code class="language-">T</code> et qu'il y a une condition d'arrêt sur la taille du tableau.</p>
<h3 id="complexités-rapide">Complexités</h3>
<p>En notant $n$ la taille de la liste on a comme équation de récurrence pour la complexité $C(n)$ :</p>
<div>
$${
C(n) = \underbracket{\mathcal{O}(n)}_{\mbox{cr\'eation des tableaux}}{} + \underbracket{C(n_1) + C(n_2)}_{\mbox{r\'ecursions}}{}
}$$
</div>
<p>Où $n_1$ est la taille du tableau de gauche et $n_2$ celle de droite ($n_1 + n_2 = n-1$). Pour trouver $n_1$ et $n_2$, il faut résoudre l'équation :</p>
<p>$${<br>
C(n) = \mathcal{O}(n) + \max_{0 \leq i &lt; n}(C(i) + C(n-i-1))<br>
}$$</p>
<p>Le <a href="./#master-th%C3%A9or%C3%A8me">master theorem</a> ne nous aide malheureusement pas car les tailles des sous-problèmes ne sont pas fixe.</p>
<p>On va montrer que :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p>Complexités du tri rapide :</p>
</div><div class="pl-8 mr-8">
<p>Pour trier un tableau de longueur $n$, les complexités de <code class="language-">rapide</code> sont :</p>
<ul>
<li>la complexité (maximale) est $C_{\max}(n) = \mathcal{O}(n^2)$,</li>
<li>la complexité en moyenne est $C_{\mbox{moy}} =  \mathcal{O}(n\ln (n))$,</li>
<li>la complexité minimale est $C_{\min}(n) = \mathcal{O}(n\ln (n))$,</li>
</ul>
</div></div>
<p>Retenez les complexités ci-dessus et les raisons intuitives de leurs calculs. Si vous voulez aller plus loin, vous pouvez étudier les preuves formelles, surtout qu'elles sont jolies et vous apprendront à calculer des complexités dans des cas non triviaux.</p>
<h4>Complexité (maximale) du tri rapide</h4>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Intuitivement :</strong></p>
</div><div class="pl-8 mr-8">
<p>La complexité maximale va arriver si un des deux tableaux est toujours vide. Par exemple lorsque le tableau est déjà trié.</p>
<p>Pour des tableaux triés, <code class="language-">T1</code> ou <code class="language-">T2</code> est vide et l'autre tableau est de taille $n-1$, ce qui donne une complexité de :</p>
<div>
$$
\begin{array}{lcl}
C_{\mbox{tri\'e}}(n) &=& \mathcal{O}(n) + C_{\mbox{tri\'e}}(0) +  C_{\mbox{tri\'e}}(n-1)\\
&=&\mathcal{O}(n) + C_{\mbox{tri\'e}}(n-1)\\
&=& \mathcal{O}(n) + \mathcal{O}(n-1) + C_{\mbox{tri\'e}}(n-2)\\
&=& ...\\
&=& \sum_{i=1}^{n}\mathcal{O}(i) + C_{\mbox{tri\'e}}(0)\\
&=& \mathcal{O}(\sum_{i=1}^{n}i)\\
&=& \mathcal{O}(n^2)\\
\end{array}
$$
</div>
<p>Et donc :</p>
<p>$$<br>
C_{\max}(n) = \mathcal{O}(n^2)<br>
$$</p>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve formelle</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Formellement, nous ne venons que de montrer que $\mathcal{O}(n^2) \leq C_{\max}(n)$. Pour conclure la preuve, il nous reste à montrer la réciproque, c'est à dire $\mathcal{O}(n^2) \geq C_{\max}(n)$.</p>
<p>Faisons-le par récurrence. Notre hypothèse de récurrence est : il existe $k$ tel que $C(n) \leq k \cdot n^2$<br>
Cette hypothèse est trivialement vraie pour $n=1$ et supposons la vraie pour $n-1$. Examinons le cas $n$ :</p>
<div>
$$
\begin{array}{lcll}
C_{\max}(n) & = & \mathcal{O}(n) + \max_{0 \leq i < n}(C_{\max}(i) + C_{\max}(n-i-1))&\\
& \leq & \mathcal{O}(n) + \max_{0 \leq i < n}(k\cdot i^2 + k\cdot(n-i-1)^2)&\mbox{par hypoth\`ese de récurrence}\\
& \leq & \mathcal{O}(n) + \max_{0 \leq i < n}(k\cdot(i + n-i-1)^2)&\mbox{car } a^2+b^2 \leq (a+b)^2\\
& \leq & \mathcal{O}(n) + \max_{0 \leq i < n}(k\cdot(n-1)^2)&\\
& \leq & \mathcal{O}(n) + k\cdot(n-1)^2&\\
& \leq & \mathcal{O}(n) + k\cdot n^2 -k(2n-1)&\\
& \leq & \mathcal{O}(n^2)&\\
\end{array}
$$
</div>
<p>Notre hypothèse est démontrée.</p>
<p>On a finalement l'encadrement : $\mathcal{O}(n^2) \leq C_{\max}(n) \leq \mathcal{O}(n^2)$, ce qui nous permet d'énoncer :</p>
<p>La complexité (maximale) du tri rapide pour un tableau de taille $n$ est $\mathcal{O}(n^2)$</p>
</div>
</details>     
</div>
<h4>Complexité minimale du tri rapide</h4>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Intuitivement :</strong></p>
</div><div class="pl-8 mr-8">
<p>On a que $C(n) \geq \mathcal{O}(n)$, la complexité de l'algorithme croit donc de façon linéaire ou plus. Si la forme de $C(n)$ est sans point d'inflexion par exemple, ceci signifie que (au moins asymptotiquement) la courbe de complexité est au-dessus de sa tangente : c'est une fonction concave</p>
<p><img src="%C3%A9tude-tris-4.png" alt="croissance concave"></p>
<p>On a alors $C_{\min}(\frac{n}{k}) + C_{\min}(\frac{(k-1)n}{k}) \geq 2\cdot C_{\min}(\frac{n}{2})$. Il sera donc <strong>toujours</strong> plus intéressant de couper notre tableau en 2 exactement. Dans ce cas là, on a l'équation de récurrence : $C_\min(n) = \mathcal{O}(n) + 2 \cdot C_\min(\frac{n}{2})$ et le <a href="#master-theorem">master theorem</a> nous permet de conclure que :</p>
<p>$$<br>
C_{\min(n)} = \mathcal{O}(n\ln(n))<br>
$$</p>
</div></div>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
</svg>
<div class="pl-8 mr-8">
<p>De façon générale, les courbes de complexités sont sans points d'inflexions. Les complexités plus grande que $\mathcal{O}(n)$ sont donc quasiment toutes concaves.</p>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve formelle</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Faisons la preuve de complexité rigoureusement.</p>
<p>Pour chaque exécution de l'algorithme, le nombre d'opérations hors récursion est proportionnelle au nombre d'élément du tableau en paramètre. La complexité totale est donc de l'ordre de la somme des tailles des tableaux pour chaque récursion.</p>
<p>En réordonnant les récursions par <em>étage</em>, on obtient alors un schéma suivant :</p>
<p><img src="%C3%A9tude-tris-1.png" alt="récursions"></p>
<p>où :</p>
<ol>
<li>le premier étage a $k_0 = 1$ algorithme qui produit 2 récursions</li>
<li>le deuxième étage a au plus $k_1 = 2$ algorithmes qui produit chacun 2 récursions au maximums</li>
<li>...</li>
<li>la $i+1$ ème étage a au plus $k_i = 2^i$ algorithmes qui produisent chacun 2 récursions au maximum.</li>
<li>...</li>
</ol>
<p>La complexité totale de l'algorithme est alors égale à :</p>
<p>$$<br>
C(n) = n + n_{1} + n_{2} + n_{1, 1} + n_{1, 2} + n_{2, 1} + n_{2, 2} + \dots<br>
$$</p>
<p>avec la relation : $n_{i, \cdot} = n_{i+1, 1} + n_{i+1, 2} + 1$ si les deux récurrences existent et $n_{i, \cdot} = n_{i+1, 1 \mbox{ ou } 2} + 1$ sinon.</p>
<p>Supposons maintenant que dans cet arbre il y ait un nœud $n_{i,\cdot} &gt; 2$ qui n'ait qu'une seule récurrence. On se retrouve alors dans le cas ci-dessous :</p>
<p><img src="arbre-1-fils.png" alt="un seul fils"></p>
<p>Ce qui peut mener à deux cas (à gauche le fils n'a aussi qu'un fils, à droite il en a deux):</p>
<p><img src="arbre-1-fils-2.png" alt="cas pour les fils"></p>
<p>Ces deux arbres ne sont pas minimaux, on peux en effet les modifier localement. Pour l'arbre de gauche :</p>
<p><img src="arbre-1-fils-3-1.png" alt="mieux pour le fils gauche"></p>
<p>Et on a gagné : $n_{i, \cdot} + n_{i+1, 1} + n_{i+2, 1} - (n_{i, \cdot} + 1 + n_{i+2, 1}) = n_{i+1, \cdot} - 1 &gt; 0$</p>
<p>Pour l'arbre de droite :</p>
<p><img src="arbre-1-fils-3-2.png" alt="mieux pour le fils droit"></p>
<p>Et on a gagné : $n_{i, \cdot} + n_{i+1, 1} + n_{i+2, 1} + n_{i+2, 2} - (n_{i, \cdot} + 1 + n_{i+2, 1} + n_{i+2, 1} n_{i+2, 2}) = n_{i+1, \cdot} - n_{i+2, 1} - 1 &gt; n_{i+1, \cdot} - n_{i+2, 1} - n_{i+2, 2} = 1 &gt; 0$</p>
<p>La complexité minimale va donc arriver pour des arbres où les seuls nœud ayant un seul fils sont ceux de taille 2 : $k_i = 2^i$ pour tous les étages sauf le dernier où il vaut au pire $k_{i-1} = 2^{i-1}$.</p>
<p>Comme à chaque récursion on supprime un élément du tableau, le nombre d’opérations pour le $i+1$ème étage est égal à $N_i = N_{i-1} - k_{i-1}$.</p>
<p><img src="%C3%A9tude-tris-2.png" alt="récursions et Ni"></p>
<p>On a alors, s’il y a étages :</p>
<div>
$$
\begin{array}{lcl}
C(n) &=& (n - 0) + (n - k_0) + (n - k_0 - k_1) + \dots + (n-\sum_{j=0}^i k_j) + dots \\
&=& \sum_{i=0}^h(n-\sum_{j=0}^ik_j)\\
&=& h \cdot n - \sum_{i=0}^h(\sum_{j=0}^ik_j)\\
\end{array}
$$
</div>
<p>Dans le cas minimum on a montré que $k_j = 2^j$ si $j &lt; h$ et $k_h \geq 2^{h-1}$. Donc :</p>
<div>
$$
\begin{array}{lcl}
C(n) &\geq& h \cdot n - \sum_{i=0}^{h-1}\sum_{j=0}^i 2^j - \sum_{j=0}^{h-1} 2^j - 2^{h-1}\\
\end{array}
$$
</div>
<p>Comme $\sum_{j=0}^i(2^j) = 2^{i+1}-1$ on a :</p>
<div>
$$
\begin{array}{lcl}
C(n) &\geq& h \cdot n - \sum_{i=0}^{h-1}(2^{i+1} -1) - (2^h - 2^{h-1})\\
 &\geq& h \cdot n - \sum_{i=0}^{h-1}(2^{i+1}) - h - 2^{h-1})\\
 &\geq& h \cdot n - \sum_{i=1}^{h}(2^{i}) - h - 2^{h-1})\\
 &\geq& h \cdot n - \sum_{i=0}^{h}(2^{i}) - (h-1) - 2^{h-1})\\
 &\geq& h \cdot n - 2^{h+1} - 1 - (h-1) - 2^{h-1})\\
&\geq& h \cdot n - 2^{h+1} - h - 2^{h-1})\\
&\geq& h \cdot (n-1) - 3 \cdot 2^{h-1} \\
\end{array}
$$
</div>
<p>Enfin :</p>
<ul>
<li>comme à chaque étage on jusqu'à l'étage $h-2$ tous les éléments ont 2 fils on a $2^{h-1}$ tableaux à l'étage $h-1$ de tailles au moins 1 et au plus 2. On a donc que $n \leq $2^{h-1}$,</li>
<li>l'inégalité suivante est vérifiée par définition : $n \leq h \leq \log_2(n)$</li>
</ul>
<p>Les deux remarques précédentes nous permettent de conclure que :</p>
<div>
$$
\begin{array}{lcl}
C(n) &\geq& h \cdot (n-1) - 3 \cdot 2^{h-1} \\
     &\geq& \log_2(n) \cdot (n-1) - 3 \cdot n \\
     &\geq& \mathcal{O}(n\ln(n)) \\
\end{array}
$$
</div>
<p>La complexité minimale du tri rapide pour un tableau de taille $n$ est donc de $\mathcal{O}(n\ln(n))$</p>
</div>
</details>     
</div>
<h4>Complexité en moyenne du tri rapide</h4>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Intuitivement :</strong></p>
</div><div class="pl-8 mr-8">
<p>on utilise l'argument utilisé pour calculer la complexité en moyenne du <a href="./#complexit%C3%A9s-insertion">tri par insertion</a>. Si les données sont aléatoires la moitié de <code class="language-">T[1:]</code> est plus grande que <code class="language-">T[0]</code>. De là, en moyenne, on va toujours couper le tableau en 2 parties (plus ou moins) égales.</p>
<p>Si l'on coupe toujours au milieu on a alors la même équation que pour la complexité minimale : $C(n) = \mathcal{O}(n) + 2 \cdot C(\frac{n}{2})$, ce qui donne une complexité de $\mathcal{O}(n\ln(n))$.</p>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve formelle</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Il faut résoudre l'équation :</p>
<p>$${<br>
C_{\mbox{moy}}(n) = \mathcal{O}(n) + \sum_{0 \leq i &lt; n}p_i(C_{\mbox{moy}}(i) + C_{\mbox{moy}}(n-i-1))<br>
}$$</p>
<p>où $p_i$ est la probabilité que le pivot soit le $i+1$ plus petit élément du tableau.</p>
<p>Pour éviter de nous trimballer des $\mathcal{O}(n)$ partout, on va considérer que l'on y effectue $K\cdot n$ opérations où $K$ est une constante. On peut alors écrire :</p>
<p>$${<br>
C_{\mbox{moy}}(n) = K\cdot n + \sum_{0 \leq i &lt; n}p_i(C_{\mbox{moy}}(i) + C_{\mbox{moy}}(n-i-1))<br>
}$$</p>
<p>De plus on va considérer que nos données sont équiprobables, c'est à dire que le pivot a la même probabilité d'être le $i$ ou le $j$ ème plus petit élément du tableau : $p_i = \frac{1}{n}$. On a alors à résoudre :</p>
<p>$${<br>
C_{\mbox{moy}}(n) = K\cdot n + \frac{1}{n}\sum_{0 \leq i &lt; n}(C_{\mbox{moy}}(i) + C_{\mbox{moy}}(n-i-1))<br>
}$$</p>
<p>Comme :</p>
<ul>
<li>$\sum_{0 \leq i &lt; n}C_{\mbox{moy}}(i) = \sum_{1 \leq i \leq n}C_{\mbox{moy}}(i-1)$</li>
<li>$\sum_{0 \leq i &lt; n}C_{\mbox{moy}}(n-i-1) = \sum_{1 \leq i \leq n}C_{\mbox{moy}}(i-1)$</li>
</ul>
<p>On a :</p>
<p>$${<br>
C_{\mbox{moy}}(n) = K\cdot n + \frac{2}{n}\sum_{1 \leq i \leq n}C_{\mbox{moy}}(i-1)<br>
}$$</p>
<p>Il va maintenant y avoir 2 astuces coup sur coup. La première astuce est de considérer l'équation $n\cdot C_{\mbox{moy}}(n) - (n-1)\cdot C_{\mbox{moy}}(n-1)$ qui va nous permettre d'éliminer la somme :</p>
<div>
$$
\begin{array}{lcl}
n\cdot C_{\mbox{moy}}(n) - (n-1)\cdot C_{\mbox{moy}}(n-1) & = & K\cdot n^2 +2\sum_{1 \leq i \leq n}C_{\mbox{moy}}(i-1)\\
&&- K\cdot (n-1)^2 - 2\sum_{1 \leq i \leq n-1}C_{\mbox{moy}}(i-1)\\
&=& K(n^2 - (n-1)^2) + 2\cdot C_{\mbox{moy}}(n-1)\\
&=& K(2n - 1) + 2\cdot C_{\mbox{moy}}(n-1)\\
\end{array}
$$
</div>
<p>On en déduit :</p>
<p>$$<br>
n\cdot C_{\mbox{moy}}(n) = K(2n - 1) + (n+1)\cdot C_{\mbox{moy}}(n-1)<br>
$$</p>
<p>Et maintenant la seconde astuce : on divise l'équation ci-dessus par $n(n+1)$ pour obtenir un terme générique identique des deux côtés de l'équation :</p>
<p>$$<br>
\frac{C_{\mbox{moy}}(n)}{n+1}=\frac{C_{\mbox{moy}}(n-1)}{n} + K\cdot\frac{2n - 1}{n(n+1)}<br>
$$</p>
<p>On peut alors poser $A(n) = \frac{1}{n+1} \cdot C_{\mbox{moy}}(n)$ et on doit maintenant résoudre :</p>
<p>$$<br>
A(n) = A(n-1) + K\cdot\frac{2n - 1}{n(n+1)}<br>
$$</p>
<p>Ce qui donne :</p>
<div>
$$
\begin{array}{lcl}
A(n) &=& A(n-1) + K\cdot\frac{2n - 1}{n(n+1)}\\
&=& A(n-2) + K\cdot\frac{2(n-1) - 1}{(n-1)(n)} +  K\cdot\frac{2n - 1}{n(n+1)}\\
&=& \dots \\
&=&K \sum_{i=1}^{n}\frac{2i-1}{i(i+1)} + A(0)\\
&=&K \sum_{i=1}^{n}\frac{2}{(i+1)} - K \sum_{i=1}^{n}\frac{1}{i(i+1)} + A(0)\\
\end{array}
$$
</div>
<p>On peut facilement montrer (par récurrence) que $\sum_{i=1}^{n}\frac{1}{i(i+1)} = \frac{n}{n+1} \leq 1$ et donc que :</p>
<div>
$$
\begin{array}{lcl}
A(n) &=& 2K\sum_{i=1}^{n}\frac{1}{(i+1)} + \mathcal{O}(1)\\
&=& 2K\sum_{i=1}^{n}\frac{1}{i} - 2K + \mathcal{O}(1)\\
&=& 2K\sum_{i=1}^{n}\frac{1}{i} + \mathcal{O}(1)\\
&=& \mathcal{O}(\sum_{i=1}^{n}\frac{1}{i})\\
\end{array}
$$
</div>
<p>La suite $A(n)$ se comporte comme un $\mathcal{O}(H(n))$ où $H(n) = \sum_{i=1}^{n}\frac{1}{i}$.</p>
<p>Cette fonction est connue, elle s'appelle la <a href="https://fr.wikipedia.org/wiki/S%C3%A9rie_harmonique">série harmonique</a>,<br>
et est <a href="https://fr.wikipedia.org/wiki/%C3%89quivalent">équivalente</a> à $\ln(n)$ lorsque $n$ tend vers $+\infty$.  On a alors que $\mathcal{O}(H(n)) = \mathcal{O}(\ln(n))$, et de là :</p>
<p>$$<br>
A(n) = \mathcal{O}(\ln(n))<br>
$$</p>
<p>En revenant aux $C_{\mbox{moy}}(n) = n\cdot A(n)$ :</p>
<p>$$<br>
C_{\mbox{moy}}(n) = \mathcal{O}(n\ln(n))<br>
$$</p>
<p>ouf.</p>
<p>La complexité en moyenne du tri rapide pour un tableau de taille $n$ est $\mathcal{O}(n\ln(n))$</p>
</div>
</details>     
</div>
<h3>Conclusion</h3>
<p>Le tri rapide a :</p>
<ul>
<li>une complexité moyenne qui vaut sa complexité minimale et qui est $\mathcal{O}(n \ln(n))$, donc la meilleur possible</li>
<li>il très rapide pour les tableaux en désordre et très lent pour les tableaux déjà triés.</li>
</ul>
<p>C'est donc <em>rigolo</em> :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>Commencer par mélanger un tableau pour le trier avec <code class="language-">rapide</code> ensuite est plus rapide en moyenne que de le trier directement.</p>
</div></div>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1000px] mx-auto px-4">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>