<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <title>Structure : liste</title>

    <link href=/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css rel="stylesheet">
    <link href=/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css rel="stylesheet">

    <link href=/cours_informatique/assets/stylesheets/main.css rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" 
  src=/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1000px] mx-auto px-4">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
          <a class="mx-2" href="/cours_informatique/about">About</a>
        </div>
      </div>
    </header>

    <main class="max-w-[1000px] mx-auto px-4">
      
<article>

  <h1  >Structure : liste</h1>
  <div >
    

    
  </div>

  
    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z" />
</svg>
<div class="pl-8 mr-8">

<a href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a href="/cours_informatique/cours/algorithme-code-théorie/">Algorithme, code et théorie</a><span class="px-1">/</span><a href="/cours_informatique/cours/algorithme-code-théorie/algorithme/">Algorithme</a><span class="px-1">/</span><a href="/cours_informatique/cours/algorithme-code-théorie/algorithme/structure-liste/">Structure : liste</a>

</div>
</div>

  

  
  
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-pink-500 bg-pink-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-pink-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
</svg>
<div class="pl-8  mb-2 mr-8">

<b>Prérequis :</b>

</div><div class="pl-8 mr-8">


  <ul>

    <li><a href='/cours_informatique/cours/algorithme-code-théorie/algorithme/complexité-moyenne/'>Complexité en moyenne</a></li></ul>
  

</div>
</div>

  

  <!-- début résumé -->
<p>Mise en œuvre de la structure de liste, qui est une amélioration du de la structure de tableau.</p>
<!-- end résumé -->
<h2>Tableau</h2>
<p>On l'a vu, pour un tableau on a les complexité suivantes :</p>
<ul>
<li>La complexité dans le cas le pire de la création de la structure : $\mathcal{O}(1)$</li>
<li>La complexité dans le cas le pire pour trouver l'élément d'indice $i$ : $\mathcal{O}(1)$</li>
<li>La complexité dans le cas le pire de l'ajout d'un élément à la structure : $\mathcal{O}(1)$ en fin de structure s'il reste de la place, sinon ajout impossible. $\mathcal{O}(n - i) = \mathcal{O}(n)$ à l'emplacement $i$.</li>
<li>La complexité dans le cas le pire de la suppression d'un élément de la structure :  Pour un tableau $\mathcal{O}(1)$ en fin de structure. $\mathcal{O}(n - i) = \mathcal{O}(n)$ à l'emplacement $i$</li>
<li>La complexité dans le cas le pire de la suppression de la structure : $\mathcal{O}(1)$</li>
</ul>
<p>Cette structure est adaptée lorsque l'on ne doit pas supprimer/ajouter des éléments en milieu de structures. Cependant, on doit connaître <em>a priori</em> le nombre maximum d'éléments.</p>
<h2>Liste</h2>
<p>Les listes de python se comportent de manières différentes. Tout comme les tableaux ce sont des objets pouvant contenir une succession d'autres objets auxquels on peut accéder par un <em>indice</em>*, mais on peut facilement ajouter/supprimer un nombre infini d'éléments en fin de liste.</p>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
</svg>
<div class="pl-8 mr-8">
<p>Vous devriez savoir manipuler des listes comme personne. Mais si vous avez besoin d'une piqûre de rappel, n'hésitez pas à consulter la partie <a href="/cours_informatique/cours/base-code/listes">listes</a> du cours sur les bases du code.</p>
</div>
</div>
<h2>Structure d'un liste</h2>
<p>Une liste peut être implémentée de cette façon :</p>
<ul>
<li>on commence par créer un tableau de taille $t = k$, le nombre initial d'éléments étant $n = 0$.</li>
<li>à chaque ajout d'éléments :
<ol>
<li>test si $n &lt; t$ :
<ul>
<li>si oui :
<ul>
<li>$n = n + 1$.</li>
</ul>
</li>
<li>sinon :
<ul>
<li>on alloue un tableau $2 \times t$ éléments et $t = 2 \times t$</li>
<li>on copie les $n$ premiers éléments du tableau initial dans le nouveau tableau et on supprime le tableau initial.</li>
<li>$n = n + 1$.</li>
</ul>
</li>
</ul>
</li>
<li>décalage de tous les éléments d'indice supérieur au rang de l'ajout et insertion de l'élément.</li>
</ol>
</li>
</ul>
<h2>Complexités</h2>
<ul>
<li>La complexité dans le cas le pire de la création de la structure : $\mathcal{O}(1)$</li>
<li>La complexité dans le cas le pire pour trouver l'élément d'indice $i$ : $\mathcal{O}(1)$</li>
<li>La complexité dans le cas le pire de l'ajout d'un élément à la structure : $\mathcal{O}(n)$</li>
<li>La complexité dans le cas le pire de la suppression d'un élément de la structure : $\mathcal{O}(1)$</li>
<li>La complexité dans le cas le pire de la suppression de la structure : $\mathcal{O}(1)$</li>
</ul>
<h3>complexité d'ajout de $n$ éléments</h3>
<p>Ajouter un élément à la structure peut très mal tomber. Cela peut être juste au moment où l'on doit doubler la taille de la structure. C'est donc de complexité $\mathcal{O}(n)$ opération s'il y avait $n$ élément dans la liste au moment de l'ajout.. Mais ensuite, les $n-1$ suivants ajout vont <strong>forcément</strong> bien se passer et auront tous une complexité de $\mathcal{O}(1)$ opérations.</p>
<p>On a même le résultat suivant :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>L'ajout de $n$ éléments à une liste originellement vide prend $\mathcal{O}(n)$ opérations au maximum</p>
</div>
</div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>preuve</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<p>Complexité d'ajout de $n$ éléments à une liste :</p>
<ul>
<li>Dans le cas le pire le dernier ajout entraîne un doublement de la taille de la structure : un nouveau tableau est créé en $\mathcal{O}(1)$ puis les $n$ éléments de l'ancien tableau sont copiés dans le nouveau en $\mathcal{O}(n)$ opérations</li>
<li>Le précédent tableau  était de taille $n-1$ et a nécessité $\mathcal{O}(n)$ opérations pour être créé puis rempli (recopie de $n/2$ anciens éléments puis insertion de $n/2$ nouveaux éléments).</li>
<li>Le tableau encore d'avant d'avant était de taille $n/2$ et son remplissage a pris $\mathcal{O}(n/2)$ opérations (recopie de $n/4$ anciens éléments puis insertion de $n/4$ nouveaux éléments)</li>
<li>Le tableau encore encore d'avant d'avant était de taille $n/4$ et son remplissage a pris $\mathcal{O}(n/4)$ opérations</li>
<li>...</li>
<li>le $i$ème tableau précédent était de taille $n / {2^i}$ et son remplissage a pris $\mathcal{O}(n/{2^i})$ opérations</li>
<li>...</li>
<li>le $\log_2(n)$ tableau précédent était de taille $n / {2^{\log_2(n}} = 1$ et son remplissage a pris un nombre d'opérations de $\mathcal{O}(n / {2^{\log_2(n}}) = \mathcal{O}(1)$ opérations</li>
</ul>
<p>La complexité totale est donc de :</p>
<p>$$<br>
C(n) = \mathcal{O}(n + n + \frac{n}{2} + \frac{n}{4} + \frac{n}{8} + \dots + 1) = \mathcal{O}(n + \sum_{i=0}^{\log_2(n)}\frac{n}{2^i}) = \mathcal{O}(n(1+\sum_{i=0}^{\log_2(n)}\frac{1}{2^i}))<br>
$$</p>
<p><a href="https://fr.wikipedia.org/wiki/1/2_%2B_1/4_%2B_1/8_%2B_1/16_%2B_%E2%8B%AF">Comme</a> $\sum_{i=0}^{+\infty}\frac{1}{2^i} = 1$, on a :</p>
<p>$$<br>
(1+\sum_{i=0}^{\log_2(n)}\frac{1}{2^i})) \leq (1+\sum_{i=0}^{+\infty}\frac{1}{2^i})) \leq 2<br>
$$</p>
<p>Et donc : $C(n) = \mathcal{O}(n)$</p>
</div>
</details>     
</div>
<p>Comme la complexité d'ajout d'un élément à une liste n'est pas constante, il nous faut un nouvel outil pour en appréhender sa complexité :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Définition</strong></p>
</div><div class="pl-8 mr-8">
<p>On appelle <em><strong>complexité amortie</strong></em> d'un algorithme la complexité d'effectuer $n$ fois une opération le tout divisé par $n$.</p>
</div>
</div>
<p>Dans le cas d'une structure simple, la complexité amortie est égale à la complexité puisque l'on fait $n$ fois la même chose mais pour des structure plus complexe comme les listes, lorsque l'on ajoute $n$ fois un élément, cette opération n'est coûteuse qu'un petit nombre de fois.</p>
<p>La complexité amortie d'ajout de $n$ éléments dans une liste est alors $\mathcal{O}(1)$. En effet :<br>
${\mbox{complexité d'ajout de n éléments dans une liste }} / {n} = {\mathcal{O}(n)} / {n} = \mathcal{O}(1)$</p>
<p>Il est donc légitime d'admettre  que la complexité d'insertion d'un élément en fin de liste est en $\mathcal{O}(1)$ :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>On considère que La complexité de l'ajout d'un élément en fin de liste est en $\mathcal{O}(1)$ opérations.</p>
</div>
</div>
<p>La complexité amortie est un concept avancé. Il ne faut pas le confondre avec la complexité en moyenne, c'est bien $n$ fois la complexité maximale que l'on considère lorsque l'on effectue les opération successivement. C'est un moyen efficace de calculer la complexité d'un algorithme lorsque l'on utilise des structures dont l'opération coûteuse n'est faite qu'un petit nombre de fois.</p>
<h2>Attention</h2>
<p>Un piège courant lorsque l'on débute avec les liste en python est d'ajouter un élément en fin de liste avec la commande : <code class="language-">l = l + [x]</code>. C'est une erreur car la complexité est beaucoup plus importante que si l'on utilise la méthode <code class="language-">append</code> :</p>
<ul>
<li>complexité de <code class="language-">l = l + [x]</code> : $\mathcal{O}(\mbox{len}(l))$ car on crée une nouvelle liste !</li>
<li>complexité de : <code class="language-">l.append(x)</code> : $\mathcal{O}(1)$ car on ajoute à la fin d'une liste déjà existante</li>
</ul>


</article>

    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1000px] mx-auto px-4">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>