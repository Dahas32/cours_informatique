<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <title>Etude : exponentiation</title>

    <link href=/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css rel="stylesheet">
    <link href=/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css rel="stylesheet">

    <link href=/cours_informatique/assets/stylesheets/main.css rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script type="text/javascript" id="MathJax-script" async
  src=/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js></script>
  
    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1000px] mx-auto px-4">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
          <a class="mx-2" href="/cours_informatique/about">About</a>
        </div>
      </div>
    </header>

    <main class="max-w-[1000px] mx-auto px-4">
      
<article>

  <h1  >Etude : exponentiation</h1>
  <div >
    

    
  </div>

  
    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z" />
</svg>
<div class="pl-8 mr-8">

<a href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a href="/cours_informatique/cours/algorithme-code-théorie/">Algorithme, code et théorie</a><span class="px-1">/</span><a href="/cours_informatique/cours/algorithme-code-théorie/algorithme/">Algorithme</a><span class="px-1">/</span><a href="/cours_informatique/cours/algorithme-code-théorie/algorithme/étude-exponentiation/">Etude : exponentiation</a>

</div></div>

  

  <div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-pink-500 bg-pink-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-pink-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Prérequis</strong> :</p>
</div><div class="pl-8 mr-8">
<ul>
<li><a href="../complexit%C3%A9-max-min">complexité max/min</a></li>
<li><a href="../preuve-algorithme">preuve d'algorithme</a></li>
</ul>
</div></div>
<!-- début résumé -->
<p>On va étudier deux algorithmes permettant de calculer $a^b$  à partir de deux entiers $a$ et $b$. Pour chaque algorithme on étudiera son fonctionnement selon 3 axes :</p>
<ul>
<li>fonctionnement</li>
<li>preuve</li>
<li>complexité</li>
</ul>
<!-- end résumé -->
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
</svg>
<div class="pl-8 mr-8">
<p>On utilisera le python comme langage de pseudo-code</p>
</div></div>
<h2 id="algo-naif">Algorithme naïf</h2>
<p>Le calcul <em>naïf</em> de l'exponentiel est basé sur sa définition mathématique, qui peut être décrite, pour deux entiers positifs $x$ et $y$,  par l'équation suivante :</p>
<div>
$$
x^y = \left\{
    \begin{array}{ll}
        x \cdot x^{y-1} & \mbox{si } y > 0 \\
        1 & \mbox{sinon.}
    \end{array}
\right.
$$
</div>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
<div class="pl-8 mr-8">
<p>Écrivez un algorithme récursif pour résoudre cette équation.</p>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>solution</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">puissance</span><span class="token punctuation">(</span>nombre<span class="token punctuation">,</span> exposant<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> exposant <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">return</span> nombre <span class="token operator">*</span> puissance<span class="token punctuation">(</span>nombre<span class="token punctuation">,</span> exposant <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre>
<p>Cet algorithme est exactement la transcription de la définition mathématique, il est donc correct.</p>
</div>
</details>     
</div>
<p>Pour cette étude, nous allons uniquement utiliser des algorithmes non récursifs (ils sont dit itératifs).</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
<div class="pl-8 mr-8">
<p>Écrivez un algorithme itératif pour calculer $x^y$  avec $x$ et $y$ deux entiers positifs.</p>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>solution</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">puissance</span><span class="token punctuation">(</span>nombre<span class="token punctuation">,</span> exposant<span class="token punctuation">)</span><span class="token punctuation">:</span>
    résultat <span class="token operator">=</span> <span class="token number">1</span>
    compteur <span class="token operator">=</span> exposant
    <span class="token keyword">while</span> compteur <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>
        résultat <span class="token operator">*=</span> nombre
        compteur <span class="token operator">-=</span> <span class="token number">1</span>
    <span class="token keyword">return</span> résultat
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</div>
</details>     
</div>
<p>C'est cet algorithme itératif que nous allons étudier maintenant.</p>
<h3 id="marche-naïf">Est-ce que ça marche ?</h3>
<p>On test l'algorithme itératif sur de petits exemples qui vont nous permettre d'appréhender son fonctionnement :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>On teste sur de petits nombres en se mettant à la place de l'ordinateur.</p>
<ul>
<li>on numérote chaque ligne</li>
<li>on note sur une feuille les variables</li>
<li>on exécute ligne à ligne en notant les différents résultats.</li>
<li>à la fin on vérifie que <code class="language-">résultat</code> vaut bien ce qu'il doit valoir.</li>
</ul>
</div></div>
<p>Les cas simples que l'on peut essayer sans peine, et permet de <strong>tester les cas limites</strong> :</p>
<ul>
<li>exposant vaut 0 ou 1</li>
<li>nombre vaut 2 ou 3 (un peu plus que les cas triviaux)</li>
</ul>
<p>Puis un cas un peu plus compliqué pour <strong>tester si les boucles fonctionnent bien</strong> :</p>
<ul>
<li>exposant vaut 2 ou 3</li>
<li>nombre vaut 2 ou 3</li>
</ul>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-yellow-500 bg-yellow-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-yellow-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
  <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
</svg>
<div class="pl-8 mr-8">
<p>Vérifiez que l'algorithme donne bien les bons résultats sur les exemples ci-dessus.</p>
</div></div>
<p>Une fois qu'on est convaincu que ça fonctionne, on prouvera sa finitude, sa preuve et on calculera sa complexité.</p>
<h3 id="preuve-naif">Preuve</h3>
<p>En deux temps. On commence par montrer qu'il se termine, puis on prouve qu'il calcule bien l'exponentiation.</p>
<h4 id="finitude-naif">Finitude</h4>
<ul>
<li><code class="language-">compteur</code> diminue strictement à chaque boucle et la condition d'arrêt est lorsqu'il vaut 0</li>
<li>condition : il faut que <code class="language-">compteur</code> soit un nombre positif pour que l'algorithme s'arrête. Donc <code class="language-">exposant</code> doit être un nombre positif.</li>
</ul>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>Pour des nombres, on préférera toujours des conditions d'arrêt larges (plus petit que, plus grand que, différent de) plutôt que des conditions sur l'égalité stricte. Ceci pour deux raisons majeures :</p>
<ul>
<li>L'égalité entre réels n'existe pas en informatique par exemple.</li>
<li>dans l'exemple ci-dessus mettre des exposants négatifs ou des nombres réels ne fait pas boucler infiniment notre algorithme</li>
</ul>
</div></div>
<h4>Preuve de l'algorithme</h4>
<p>Le fonctionnement de l'algorithme est <em>à peu prêt</em> clair si les entrées sont des entiers : il multiplie $a$ par lui-même $b$ fois grâce à une boucle. Une preuve par récurrence doit donc fonctionner, mais essayons de faire une <em>jolie</em> preuve en exhibant un invariant de boucle.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>Si <code class="language-">nombre</code> et <code class="language-">exposant</code> sont des entiers naturels, on a l'invariant de boucle :</p>
<blockquote>
<p><code class="language-">résultat * nombre ** compteur = nombre ** exposant</code> (en utilisant l'opération <code class="language-">**</code> qui signifie exposant en python.)</p>
</blockquote>
</div></div>
<p>Prouvons cet invariant.</p>
<p>Juste avant la première itération de la boucle, <code class="language-">résultat = 1</code> et <code class="language-">compteur = exposant</code> notre invariant est donc vérifié. On suppose l'invariant vrai au début de la boucle $i$. Comme expliqué dans la partie sur les [preuves d'algorithmes]../preuve-algorithme), on met un <code>'</code> aux variable après l'itération :</p>
<ul>
<li><code class="language-">nombre' = nombre</code></li>
<li><code class="language-">exposant' = exposant</code></li>
<li><code class="language-">résultat' = résultat * nombre</code></li>
<li><code class="language-">compteur' = compteur - 1</code></li>
</ul>
<p>On a alors :  <code class="language-">résultat' * nombre' ** compteur' = (résultat * nombre) * nombre ** (compteur - 1) = résultat * nombre ** compteur = nombre ** exposant = nombre' ** exposant'</code></p>
<p>On a démontré notre invariant de boucle.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8 mr-8">
<p>Notre invariant est vrai avant et après chaque itération, il est donc également vrai à la fin de l'algorithme, lorsque <code class="language-">compteur = 0</code>. Et là : <code class="language-">résultat * nombre ** compteur = résultat = nombre ** exposant</code></p>
</div></div>
<h3 id="complexité-naif">Complexité</h3>
<p>Ligne à ligne :</p>
<ol>
<li>définition de la fonction : $\mathcal{O}(1)$</li>
<li>une affection : $\mathcal{O}(1)$</li>
<li>une affection : $\mathcal{O}(1)$</li>
<li>une boucle de $\mathcal{O}(\mbox{exposant})$ itération (<code>compteur</code> vaut initialement <code>exposant</code> et décrémente de $1$ à chaque itération)</li>
<li>une multiplication et une affection : $\mathcal{O}(1)$</li>
<li>une soustraction et une affection : $\mathcal{O}(1)$</li>
<li>retour de la fonction : $\mathcal{O}(1)$</li>
</ol>
<p>Ce qui donne une complexité de :</p>
<div>
$$
\begin{array}{lcl}
C & = & \mathcal{O}(1) + \\
&  & \mathcal{O}(1) + \\
& & \mathcal{O}(1) + \\
& & \mathcal{O}(\mbox{exposant}) \cdot ( \\
& & \mathcal{O}(1) + \\
& & \mathcal{O}(1)) + \\
& & \mathcal{O}(1)\\
& = & 3 \cdot \mathcal{O}(1) + \mathcal{O}(\mbox{exposant}) \cdot (2 \cdot \mathcal{O}(1)) + \mathcal{O}(1)\\
&=& 4 \cdot \mathcal{O}(1) + 2 \cdot \mathcal{O}\mbox({exposant})\\
&=& \mathcal{O}(1) + \mathcal{O}(\mbox{exposant})\\
C&=& \mathcal{O}(\mbox{exposant})\\
\end{array}
$$
</div>
<h2 id="algo-rapide">Exponentiation indienne</h2>
<p>Aussi appelé <a href="https://fr.wikipedia.org/wiki/Exponentiation_rapide">exponentiation rapide</a>, cette façon de calculer l'exponentielle est basée sur l'équation suivante, pour deux entiers positifs $x$ et $y$ :</p>
<div>
$$
x^y = \left\{
    \begin{array}{ll}
        1 & \mbox{si } y = 0 \\
        x \cdot x^{y-1}  &\mbox{si } y  \mbox{ est impair}\\
        x^{\frac{y}{2}}  \cdot x^{\frac{y}{2}} = (x^2)^{\frac{y}{2}}  &\mbox{si } y  \mbox{ est pair}\\
    \end{array}
\right.
$$
</div>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
<div class="pl-8 mr-8">
<p>Écrivez un algorithme récursif pour résoudre cette équation.</p>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>solution</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">puissance</span><span class="token punctuation">(</span>nombre<span class="token punctuation">,</span> exposant<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> exposant <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token number">1</span>
    <span class="token keyword">elif</span> compteur <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> nombre <span class="token operator">*</span> puissance<span class="token punctuation">(</span>nombre<span class="token punctuation">,</span> exposant <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> nombre <span class="token operator">*</span> nombre <span class="token operator">*</span> puissance<span class="token punctuation">(</span>nombre<span class="token punctuation">,</span> exposant <span class="token operator">//</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> 
</code></pre>
<p>On a utilisé deux choses :</p>
<ul>
<li>L'opérateur <code class="language-">%</code> signifie <em>modulo</em> en python : il retourne le reste de la division entière. L'algorithme s'en sert pour vérifier si <code class="language-">compteur</code> est pair (reste de la division entière par 2 vaut 0) ou impair (reste de la division entière par 2 vaut 1)</li>
<li>la division entière <code class="language-">//</code> pour s'assurer que exposant reste un entier. Le type de <code class="language-">4 / 2</code> en python est un réel alors que le type de <code class="language-">4 // 2</code> est un entier.</li>
</ul>
<p>Cet algorithme est exactement la transcription de la définition mathématique, il est donc correct.</p>
</div>
</details>     
</div>
<p>Pour cette étude, nous allons uniquement utiliser des algorithmes non récursifs (ils sont dit itératifs).</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-orange-500 bg-orange-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-orange-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8.228 9c.549-1.165 2.03-2 3.772-2 2.21 0 4 1.343 4 3 0 1.4-1.278 2.575-3.006 2.907-.542.104-.994.54-.994 1.093m0 3h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
<div class="pl-8 mr-8">
<p>Écrivez un algorithme itératif utilisant l'exponentiation indienne pour résoudre $x^y$  avec $x$ et $y$ deux entiers positifs.</p>
</div></div>
<div class="relative drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-indigo-500 bg-indigo-100">
<details class="group">
<summary class="list-none py-0.5">
<svg class="group-open:hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
</svg>
<svg class="group-open:block hidden absolute w-7 h-7 pl-1 pt-0.5 text-indigo-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" />
</svg>
<div class="pl-8 font-bold inline-block">
<p>solution</p>
</div>
<svg class="group-open:hidden inline-block pl-3 w-10 text-indigo-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h.01M12 12h.01M19 12h.01M6 12a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0zm7 0a1 1 0 11-2 0 1 1 0 012 0z" />
</svg>
</summary>
<div class="mx-8 pb-2">
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">puissance</span><span class="token punctuation">(</span>nombre<span class="token punctuation">,</span> exposant<span class="token punctuation">)</span><span class="token punctuation">:</span>
    résultat <span class="token operator">=</span> <span class="token number">1</span>
    compteur <span class="token operator">=</span> exposant

    <span class="token keyword">while</span> compteur <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> compteur <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>
            résultat <span class="token operator">*=</span> nombre
            compteur <span class="token operator">-=</span> <span class="token number">1</span>
        <span class="token keyword">else</span><span class="token punctuation">:</span>
            nombre <span class="token operator">*=</span> nombre
            compteur <span class="token operator">/=</span> <span class="token number">2</span>

    <span class="token keyword">return</span> résultat
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</div>
</details>     
</div>
<p>C'est cet algorithme itératif que nous allons étudier maintenant.</p>
<h3 id="marche-rapide">Est-ce que ça marche ?</h3>
<p>Comme pour l'algorithme naïf, on vérifie que tout fonctionne avec les cas simples :</p>
<ul>
<li>exposant vaut 0 ou 1</li>
<li>nombre vaut 2 ou 3 (un peu plus que les cas triviaux)</li>
</ul>
<p>Enfin, comme l'algorithme vérifie si <code class="language-">compteur</code> est pair ou impair, on peut essayer un exposant un peu plus grand, par exemple :</p>
<ul>
<li><code class="language-">exposant = 7</code></li>
<li><code class="language-">nombre = 2</code> (pas trop grand pour pouvoir calculer facilement les résultats de tête)</li>
</ul>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-yellow-500 bg-yellow-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-yellow-500" xmlns="http://www.w3.org/2000/svg"  fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
  <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
</svg>
<div class="pl-8 mr-8">
<p>Vérifiez que l'algorithme donne bien les bons résultats sur les exemples ci-dessus.</p>
</div></div>
<h3 id="finitude-rapide">Preuve de finitude</h3>
<p>De même que pour l'algorithme simple, <code class="language-">compteur</code> diminue strictement à chaque boucle (ou il diminue de <code class="language-">-1</code> ou il est divisé par 2). Si <code class="language-">exposant</code> est un entier naturel en entrée, <code class="language-">compteur</code> reste entier après chaque boucle (on ne le divise par 2 que s'il est pair) et est strictement plus petit : l'algorithme va s'arrêter à un moment.</p>
<h3 id="preuve-rapide">Preuve de l’algorithme</h3>
<p>On va montrer que l'invariant de l'algorithme naïf fonctionne aussi. En notant <code class="language-">compteur_initial</code>, la valeur de compteur en entrée de l'algorithme, on a l'invariant suivant : <code class="language-">résultat * nombre ** compteur = nombre_initial ** exposant</code></p>
<h4 id="invariant-rapide-init">Conditions initiales</h4>
<p>Juste avant la première itération de la boucle, <code class="language-">résultat = 1</code> et <code class="language-">compteur = exposant</code> notre invariant est donc vérifié.</p>
<h4 id="invariant-rapide-preuve">Preuve de l'invariant</h4>
<p>On suppose l'invariant vrai au début de la boucle d'itération $i$. Regardons comment les variables ont été modifiées lors de cette itération :</p>
<ul>
<li>si compteur est impair on a :
<ul>
<li><code class="language-">compteur' = compteur - 1</code></li>
<li><code class="language-">résultat' = résultat * nombre</code></li>
<li><code class="language-">nombre' = nombre</code></li>
<li>l'invariant vaut alors en fin d'itération : <code class="language-">résultat * nombre ** compteur = (résultat * nombre) * nombre ** (compteur - 1) = résultat' * nombre' ** compteur'</code></li>
</ul>
</li>
<li>si compteur est impair on a :
<ul>
<li><code class="language-">compteur' = compteur - 1</code></li>
<li><code class="language-">résultat' = résultat</code></li>
<li><code class="language-">nombre' = nombre * nombre</code></li>
<li>l'invariant vaut alors en fin d'itération : <code class="language-">résultat * nombre ** compteur = résultat * (nombre * nombre) ** (compteur / 2)  = résultat' * nombre' ** compteur'</code></li>
</ul>
</li>
</ul>
<p>Dans tous les cas, l'invariant est toujours vérifié puisqu'en début de boucle notre invariant vaut <code class="language-">résultat * nombre ** compteur = nombre_initial ** exposant</code>.</p>
<h4 id="preuve-rapide">Preuve de l'algorithme</h4>
<p>Notre invariant est vrai avant et après chaque itération, il est donc également vrai à la fin de l'algorithme, lorsque <code>compteur = 0</code>. Et là : <code class="language-">résultat * nombre ** compteur = résultat = nombre_initial ** exposant</code></p>
<h3 id="complexité-rapide">Complexité</h3>
<p>Pourquoi s'embêter avec la parité de compteur ? Parce que ça permet d'aller vachement plus vite !</p>
<p>On va le démontrer petit à petit, mais commençons par analyser ligne à ligne la complexité :</p>
<ol>
<li>définition de fonction $\mathcal{O}(1)$</li>
<li>une affectation : $\mathcal{O}(1)$</li>
<li>une affectation : $\mathcal{O}(1)$</li>
<li>—</li>
<li>une comparaison en $\mathcal{O}(1)$ et $k$ itérations de boucle</li>
<li>une opération de division entière et un test : $\mathcal{O}(1)$</li>
<li>une opération et une affectation : $\mathcal{O}(1)$</li>
<li>une opération et une affectation : $\mathcal{O}(1)$</li>
<li>—</li>
<li>une opération et une affectation : $\mathcal{O}(1)$</li>
<li>une opération et une affectation : $\mathcal{O}(1)$</li>
<li>—</li>
<li>un retour de fonction : $\mathcal{O}(1)$</li>
</ol>
<p>Ce qui donne une complexité de :</p>
<div>
$$
\begin{array}{lcll}
C & = & \mathcal{O}(1) + &\\
&  & \mathcal{O}(1) + &\\
&  & \mathcal{O}(1) + &\\
&  & k \cdot (\mathcal{O}(1) + &\\
& & \mathcal{O}(1) + &\\
& & \mathcal{O}(1) + &\mbox{(ligne 7 ou ligne 10)}\\
& & \mathcal{O}(1) + & \mbox{(ligne 8 ou ligne 11)}\\
& & \mathcal{O}(1)) +&\\
& & \mathcal{O}(1)&\\
&=& 3 \cdot \mathcal{O}(1) + k \cdot (5\cdot \mathcal{O}(1)) + \mathcal{O}(1)&\\
&=& 4 \cdot \mathcal{O}(1) + k \cdot 5 + &\\
C&=&\mathcal{O}(k)&\\
\end{array}
$$
</div>
<p>La complexité est de l'ordre du nombre de fois où l'on rentre dans la boucle <code class="language-">while</code> : c'est à dire le nombre de fois où <code class="language-">compteur</code> a été modifié sans être égal à 0.</p>
<h4>nombre de fois où compteur est impair</h4>
<p>Si à l'itération numéro $i$ compteur est impair, il sera pair à l'itération $i + 1$ car <code class="language-">compteur' = compteur - 1</code> dans ce cas là.</p>
<p>On a donc que : <strong>le nombre d'itérations où compteur est impair est au pire égal au nombre de fois où il est pair</strong></p>
<h4>Nombre de fois où le compteur est pair</h4>
<p>A chaque fois où compteur est pair, on le divise par 2. Si $k$ est le nombre de fois où le compteur a été pair, on a que : $2^k \leq \mbox{nombre}$ (avec  <code class="language-">nombre</code> le paramètre d'entrée).</p>
<p>Comme <code class="language-">nombre</code> est un entier, il existe un nombre $p$ tel que $2^p \leq \mbox{nombre} &lt; 2^{p + 1}$.</p>
<p>On ne peut donc pas diviser par 2 <code class="language-">nombre</code>, ou un nombre plus petit que lui, plus de <code>p</code> fois. Et $p$ vaut la partie entière de $\log_2(\mbox{nombre})$. En effet :</p>
<div>
$$
\begin{array}{lcccl}
    2^p &\leq &\mbox{nombre} &<& 2^{p + 1}\\
    \log_2(2^p) &\leq &\log_2(\mbox{nombre}) &< &\log_2(2^{p + 1}) \mbox{ (car la fonction est croissante)} \\
    p &\leq &\log_2(\mbox{nombre}) &<& p + 1
\end{array}
$$
</div>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
</svg>
<div class="pl-8 mr-8">
<p>Pour tout nombre k, le nombre de fois où l'on peut diviser un nombre $x$ par $k$ est $\log_k(x)$</p>
</div></div>
<p>On a donc que : <strong>le nombre d'itérations où compteur est pair est au pire égal à $\log_2(\mbox{nombre})$</strong></p>
<h4>Nombre de fois où l'on rentre dans la boucle</h4>
<p>Le nombre de fois où l'on rentre dans la boucle est égal au nombre de fois où le compteur est pair plus le nombre de fois où le compteur est impair, c'est donc au pire égal à deux fois le nombre de fois où compteur est pair, c'est à dire $2 \cdot \log_2(\mbox{compteur})$ pour la valeur initiale de compteur.</p>
<p>Comme <code class="language-">compteur</code> vaut initialement <code class="language-">exposant</code>, le nombre de fois où l'on rentre dans la boucle est de l'ordre de $\mathcal{O}(\log_2(\mbox{exposant}))$ donc en $\mathcal{O}(\ln(\mbox{exposant}))$.</p>
<p>Comme les autres lignes sont en $\mathcal{O}(1)$ on a une complexité de l'algorithme en $\mathcal{O}(\ln(\mbox{exposant}))$.</p>
<p>Cette complexité est très faible ! Comparez par exemple : $2^{16} = 65536$ opérations et $\log_2(65536) = 16$ opérations.</p>
<p>Cette différence va aller exponentiellement lorsque compteur augmente, par exemple entre $2^{100} = 1267650600228229401496703205376$ et $100$ opérations</p>
<h2>Conclusions</h2>
<ul>
<li>la procédure utilisée pour l'étude de ces deux algorithmes est générale, vous pouvez (et devez) l'appliquer à l'étude de tout nouvel algorithme.</li>
<li>il ne faut jamais penser que l'on ne peut pas faire mieux pour un algorithme. Si vous ne connaissiez pas l'exponentiation indienne, il vous aurait été difficile de penser que l'on peut faire mieux que l'algorithme naïf pour calculer une exponentielle</li>
<li>un informaticien ferait beaucoup de sacrifices pour obtenir une complexité en $\mathcal{O}(\ln(n))$ tellement c'est efficace.</li>
</ul>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1000px] mx-auto px-4">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
      </div>
    </footer>

  <script>
    MathJax.startup.document.getMathItemsWithin(document.body);
  </script>

  </body>
</html>