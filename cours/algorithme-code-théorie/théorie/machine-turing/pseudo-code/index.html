<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>Équivalence entre pseudo-code et machine de Turing</title>

    <link href="/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet">
    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">

    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>Équivalence entre pseudo-code et machine de Turing</h1>
  <div>
    

    
  </div>

  

    
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-purple-500 bg-purple-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-purple-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z"></path>
</svg>
<div class="pl-8 mr-8">

<a class="interne" href="/cours_informatique/cours/">Cours</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithme-code-théorie/">Algorithme, code et théorie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithme-code-théorie/théorie/">Théorie</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithme-code-théorie/théorie/machine-turing/">Machine de Turing</a><span class="px-1">/</span><a class="interne" href="/cours_informatique/cours/algorithme-code-théorie/théorie/machine-turing/pseudo-code/">Équivalence entre pseudo-code et machine de Turing</a>

</div>
</div>


    
      
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-pink-500 bg-pink-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-pink-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
</svg>
<div class="pl-8  mb-2 mr-8">

<b>Prérequis :</b>

</div><div class="pl-8 mr-8">


      <ul>
              
              <li>
                <a class="interne" href="/cours_informatique/cours/algorithme-code-théorie/algorithme/définition/">Définition d&#39;un algorithme</a>
              </li>
              
              <li>
                <a class="interne" href="/cours_informatique/cours/algorithme-code-théorie/algorithme/pseudo-code/">Pseudo-code</a>
              </li></ul>
      

</div>
</div>

    
  

  <p>Le <a href="../algorithme/pseudo-code/%22">pseudo-code</a> est une façon d'écrire des algorithmes, nous allons voir dans cette partie qu'un pseudo-code est équivalent à une machine de Turing et qu'on (les informaticiens) est même persuadé que c'est aussi équivalent à la notion même d'algorithme.</p>
<p>Nous allons démontrer dans cette partie que les notions de pseudo-code et de Machine de Turing sont les mêmes. IL est équivalent d'écrire ses algorithmes sous la forme de pseudo-code ou de Machine de Turing. On se demande même si la notion même d'algorithme n'est pas équivalente à celle de pseudo-code, c'est la <a href="#th%C3%A8se-Church-Turing">Thèse de Church-Turing</a></p>
<p>Pour cela, nous allons commencer à montrer que tout pseudo-code peut être écrit sous la forme d'une machine de Turing, puis que toute machine de Turing peut être écrite sous la forme de pseudo-code grâce à l'introduction d'une machine particulière, la machine deTuring universelle.</p>
<h2>Turing et pseudo-code minimal</h2>
<p>Le but de cette partie est de montrer l'implication :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Tout <a href="../algorithme/pseudo-code/%22">Pseudo-code</a> peut être simulé par une <a href="../d%C3%A9finition">machine de Turing</a>.</p>
</div>
</div>
<h3>Pseudo-code minimal</h3>
<p>Nous allons donner ici une version expurgé de la notion d'algorithme et de pseudo-code. Cette version, plus compliquée à écrire mas pas plus puissante sera plus facile à mettre en correspondance avec les machines de Turing.</p>
<h4>Objets et opérations d'un algorithme</h4>
<p>On a vu qu'un <a href="../../../algorithme/d%C3%A9finition/" class="interne">algorithme</a> pouvait ne manipuler que des entiers.</p>
<p>Sous sa représentation binaire, un entier étant un tableau de bit, on en conclut :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Les seuls objets qu'un <strong>algorithme</strong> peut utiliser sont les tableaux de bits.</p>
</div>
</div>
<p>De plus, toutes les opérations arithmétiques sur les nombres binaires peuvent se déduire de l'addition et l'addition peut s'écrire en utilisant uniquement l'opération <a href="https://fr.wikipedia.org/wiki/Fonction_NON-ET">NON-ET</a>.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p>Sur comment faire, voir par exemple <a href="https://www.circuits-logiques.polymtl.ca/help/Chapitre05.pdf">https://www.circuits-logiques.polymtl.ca/help/Chapitre05.pdf</a></p>
</div>
</div>
<p>De là :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>La seule opération qu'un <strong>algorithme</strong> peut utiliser est l'opération <a href="https://fr.wikipedia.org/wiki/Fonction_NON-ET">NON-ET</a></p>
</div>
</div>
<p>On peut donc se restreindre aux pseudo-codes pouvant manipuler des bits avec l'opération booléenne NON-ET.</p>
<h4>Structures de contrôles</h4>
<p>Un algorithme dans toute sa généralité n'a pas de définition précise d'une structure de contrôle, mais un <a href="../../../algorithme/pseudo-code/" class="interne">pseudo-code</a>, oui. Il possède :</p>
<ul>
<li>une instruction conditionnelle : SI condition ALORS bloc</li>
<li>une répétition conditionnelle : TANT QUE condition EXÉCUTE bloc</li>
</ul>
<p>Une condition devant être vraie (1) ou fausse (0), on peut se restreindre à :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8 mr-8">
<p>Les seules structures de contrôle nécessaires pour un <strong>pseudo-code</strong> sont :</p>
<ul>
<li>SI v == 0 ALORS  bloc</li>
<li>TANT QUE v == 0 EXÉCUTER bloc</li>
</ul>
</div>
</div>
<h3>Machine de Turing et pseudo-code minimal</h3>
<p>Il est clair que la machine de Turing possède les propriétés nécessaire pour convertir du pseudo code minimal en fonction de transition :</p>
<ul>
<li>le ruban nous permet d'avoir des tableaux de bits</li>
<li>les condition <code>SI r == 0 ALORS  machine</code> a été définie dans la partie <a href="../d%C3%A9finition/#composition-machine" class="interne">composition de machines</a>. Une machine étant pouvant être considéré comme un bloc d'instructions.</li>
<li>l'opération NON-ET peut être est trivialement construite sous la forme d'une fonction de transition</li>
</ul>
<p>Pour gérer les variables, l'équivalence des machines de Turing nous permet d'utiliser une machine à plusieurs rubans, dont 1 est consacré au stockage des variables. Ceci nous permet de définir les opérations :</p>
<ul>
<li>SI v == 0 ALORS  bloc</li>
<li>TANT QUE v == 0 EXÉCUTER bloc</li>
</ul>
<p>Et donc on en conclut :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Tout <a href="../algorithme/pseudo-code/%22">Pseudo-code</a> peut être simulé par une <a href="../d%C3%A9finition">machine de Turing</a>.</p>
</div>
</div>
<h2>Pseudo-code et Turing <span id="mtu"></span></h2>
<p>Il nous reste à montrer l'autre implication :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Toute machine de Turing peut être écrite sous la forme de pseudo-code.</p>
</div>
</div>
<p>La preuve de cette implication est magnifique (on la doit à Turing lui-même) car elle montre qu'un ordinateur - dont le but est d'exécuter des programmes donc des machines - est lui aussi une machine de Turing.</p>
<p>Ce qui différencie une machine de Turing d'une autre c'est la fonction de transition.</p>
<p>Un des résultats les plus surprenant de Turing est qu'en fait on ne peut construire qu'<strong>une seule machine</strong> qui simulera toutes les autres. Cette machine est appelée <a href="https://fr.wikipedia.org/wiki/Machine_de_Turing_universelle">Machine de Turing universelle</a> et possède deux paramètres, le premier, $M$ représentant le programme d'une machine de Turing et le second $E$ une entrée.</p>
<p>Avant de construire effectivement une machine de Turing universelle, essayons de voir comment en encoder une sous la forme d'une ou plusieurs chaînes de 0 et de 1.</p>
<h3>Encodage d'une machine</h3>
<p>Une machine de Turing, est définie par sa fonction de transition. Il nous faut donc un moyen d'encoder les 3 fonctions constituant la fonction de transition :</p>
<ul>
<li>$\delta_e: Q \times \{1, 0\} \mapsto Q$</li>
<li>$\delta_c: Q \times \{1, 0\} \mapsto \{1, 0\}$</li>
<li>$\delta_d: Q \times \{1, 0\} \mapsto \{\leftarrow, \rightarrow\}$</li>
</ul>
<p>Par des suites de <code>0</code> et de <code>1</code>.</p>
<p>On peut pour cela considérer des bijections :</p>
<ul>
<li>$\phi_q: Q \mapsto [\![ 0, |Q|-1]\!]$ telle que :
<ul>
<li>$\phi_q(\text{START}) = 0$</li>
<li>$\phi_q(\text{STOP}) = 1$</li>
</ul>
</li>
<li>$\phi_d: \{\leftarrow, \rightarrow\} \mapsto \{0, 1\}$ telle que :
<ul>
<li>$\phi_d(\leftarrow) = 0$</li>
<li>$\phi_d(\rightarrow) = 1$</li>
</ul>
</li>
</ul>
<p>Encoder une transition par un quintuplet :</p>
<p>$$<br>
T(q, r) = (\phi_q(q), r, \phi_q(\delta_e(q, r)), \delta_c(q, r), \phi_d(\delta_d(q, r)))<br>
$$</p>
<p>Et finalement associer à la fonction de transition le tableau constitué de la concaténation :</p>
<p>$$<br>
T = T(q_1, 0) + CT(q_1, 1) + \dots + CT(q_i, 0) + CT(q_i, 1) + \dots + CT(q_{|Q|}, 0) + CT(q_{|Q|}, 1)<br>
$$</p>
<p>On a alors les correspondances :</p>
<ul>
<li>$\delta_e(q, r) = T[5 \cdot (k + r) + 2]$</li>
<li>$\delta_c(q, r) = T[5 \cdot (k + r) + 3]$</li>
<li>$\delta_d(q, r) = T[5 \cdot (k + r) + 4]$</li>
</ul>
<p>Avec $k$ le plus petit indice tel que $T[5\cdot k] = \phi_q(q)$</p>
<p>Par exemple, <a href="../d%C3%A9finition/#exemple-oscillation">la machine oscillation</a> pourra par exemple être encodée par :</p>
<div>
$$
\begin{array}{r}
T = (0, 0, 2, 0, 0,\\
     2, 0, 3, 1 , 1,\\
     3, 0, 4, 0, 1,\\
     3, 1, 3, 1, 1,\\
     4, 1, 3, 1, 1,\\
     4, 0, 1, 1, 0)\\
\end{array}
$$
</div>
<h3>MTU</h3>
<h4><span id="pseudo-code-MTU"></span>Principe</h4>
<p>Le pseudo-code ci-après décrit le principe d'une machine de Turing universelle.</p>
<pre><code>Nom : MTU
Entrée : 
    T : une fonction de transition sous la forme d'un tableau
Programme :
    Soit R un ruban initialement vide et un curseur c qui pointe sur une de ses cases.
    q = 0

    Tant que q ≠ 1:
      Soit r la valeur de la case du ruban pointée par c    
      Trouver le plus petit k tel que T[5k] = q

      écrire T[5(k+r) + 3] sur R
      déplacer le curseur à droite si T[5(k+r) + 4] == 1 et vers la gauche sinon
      q = T[5(k+r) + 2]

    Rendre R
</code></pre>
<p>On voit que la MTU va simulée toute machine de Turing encodée par T.</p>
<h4>Création effective</h4>
<p>Pour terminer la preuve, il nous reste à montrer que le pseudo-code précédent et T peuvent être converti en une machine de Turing et son entrée.</p>
<p>Ceci est plus facile qu'attendu car :</p>
<ul>
<li>on peut simuler une <a href="../d%C3%A9finitions-alternatives/#MT-01#">machines de Turing <code>01#</code></a> par une machine de Turing.</li>
<li>on peut simuler tout pseudo-code par une machine de Turing</li>
</ul>
<p>Commençons par transformer $T$ en une entrée composée des caractères <code>0</code>, <code>1</code> et <code>#</code> :</p>
<ul>
<li>on sépare chaque élément par des <code>#</code></li>
<li>le seul élément qui n'est pas un <code>0</code> ou un <code>1</code> est l'état qui est un entier. On peut le représenter par sa représentation unaire. Pour représenter $0 \leq q &lt; |Q| on a :
<ul>
<li>$q$ caractères <code>1</code></li>
<li>suivis de $|Q| - 1 - q$ caractères <code>0</code></li>
</ul>
</li>
</ul>
<p>Par exemple, <a href="../d%C3%A9finition/#exemple-oscillation">la machine oscillation</a> sera encodée par la chaîne :</p>
<pre><code>E : 0000#0#1100#0#0#1100#0#1110#1#1#1110#0#1111#0#1#1110#1#1110#1#1#1111#0#1110#1#1#1111#1#1000#1#0
k : 0               1               2               3               4               5
</code></pre>
<p>Cette transformation est l'entrée $E$ de notre MTU.</p>
<p>Puis nous allons simuler la MTU par une machine de Turing <code>01#</code>. Faisons simple et séparons les variables en autant de ruban :</p>
<ul>
<li>un ruban <code>R-Q</code> pour stocker l'état courant <code>q</code> : On supposera que le curseur est toujours placé au début de l'état. On initialisera ce ruban en recopiant le premier élément de l'entrée $E$</li>
<li>cinq rubans permettant de stocker la transition :
<ul>
<li><code>R-T0</code> : un ruban contenant les éléments $E[5\cdot k]$ séparé par des <code>#</code></li>
<li><code>R-T1</code> : un ruban contenant les éléments $E[5\cdot k + 1]$ séparé par des <code>#</code></li>
<li><code>R-T2</code> : un ruban contenant les éléments $E[5\cdot k + 2]$ séparé par des <code>#</code></li>
<li><code>R-T3</code> : un ruban contenant les éléments $E[5\cdot k + 3]$ séparé par des <code>#</code></li>
<li><code>R-T4</code> : un ruban contenant les éléments $E[5\cdot k + 4]$ séparé par des <code>#</code></li>
</ul>
</li>
<li><code>R-S</code> : un ruban contenant le ruban de la machine simulée</li>
<li><code>R-I</code> : un dernier ruban pour les opérations internes de la MTU</li>
</ul>
<p>Enfin, il faut adapter le pseudo-code de la MTU à notre machine. Ceci est aisé puisque :</p>
<ul>
<li>les différents paramètres sont des chaînes formées des caractères <code>0</code> et <code>1</code> séparées par 1 caractères <code>#</code> qui ne sont utilisé que comme séparateur</li>
<li>dés que l'on rencontre la chaîne  <code>##</code>, on est en bout de ruban (la suite à gauche ou à droite sera uniquement composées de <code>#</code>)</li>
<li>on peut bouger les curseurs de façon indépendante et donc avec des sous-programmes qui ne manipulent que certains rubans.</li>
</ul>
<p>On obtient alors l'algorithme ci-après qui est une écriture de l’algorithme de la MTU sous une forme où chaque étape est facilement implémentable avec une machine de Turing <code>01#</code> :</p>
<ol>
<li>Initialisation. Elle peut aisément être fait par une machine de Turing qui dispatche l'entrée sur les différents rubans
<ol>
<li>Le ruban <code>R-Q</code> contient la chaîne <code>00000</code>, avec autant de <code>0</code> que la longueur du premier élément de $E$. Son curseur est placé sur le caractère non <code>#</code> le plus à gauche</li>
<li>le ruban <code>R-T0</code> contient tous les éléments $E[5\cdot k]$, de $k=0$ jusqu'au premier élément $k_\max$ tel que $E[5\cdot k_\max] = \sharp$. Son curseur est placé sur le caractère non <code>#</code> le plus à gauche</li>
<li>le ruban <code>R-T1</code> contient tous les éléments $E[5\cdot k + 1]$, de $k=0$ jusqu'au premier élément $k_\max$ tel que $E[5\cdot k_\max + 1] = \sharp$. Son curseur est placé sur le caractère non <code>#</code> le plus à gauche</li>
<li>le ruban <code>R-T2</code> contient tous les éléments $E[5\cdot k + 2]$, de $k=0$ jusqu'au premier élément $k_\max$ tel que $E[5\cdot k_\max + 2] = \sharp$. Son curseur est placé sur le caractère non <code>#</code> le plus à gauche</li>
<li>le ruban <code>R-T3</code> contient tous les éléments $E[5\cdot k + 3]$, de $k=0$ jusqu'au premier élément $k_\max$ tel que $E[5\cdot k_\max + 3] = \sharp$. Son curseur est placé sur le caractère non <code>#</code> le plus à gauche</li>
<li>le ruban <code>R-T4</code> contient tous les éléments $E[5\cdot k + 4]$, de $k=0$ jusqu'au premier élément $k_\max$ tel que $E[5\cdot k_\max + 4] = \sharp$. Son curseur est placé sur le caractère non <code>#</code> le plus à gauche</li>
<li>les rubans <code>R-S</code> et <code>R-I</code> sont initialement vides.</li>
</ol>
</li>
<li>Trouver la transition courante :
<ol>
<li>recopier le paramètre du ruban <code>R-Q</code> sur <code>R-I</code> se décaler d'un cran à droite sur <code>R-I</code> et se replacer au début du paramètre sur <code>R-Q</code></li>
<li>recopier le paramètre du ruban <code>R-T0</code> sur <code>R-I</code> se décaler sur la gauche sur <code>R-I</code> jusqu'à être au début du ruban (à gauche du curseur il y a deux caractères <code>#</code> à la suite) et se replacer au début du paramètre sur <code>R-T0</code></li>
<li>exécuter un programme qui rend <code>1</code> sur la machine si les deux paramètres du ruban <code>R-I</code> sont égaux et <code>0</code> sinon</li>
<li>Si le résultat vaut <code>0</code> :
<ol>
<li>effacer le ruban <code>R-I</code></li>
<li>décaler les rubans <code>R-T0</code> à <code>R-T4</code> d'un paramètre à droite</li>
</ol>
</li>
<li>Si le résultat vaut `1`` :
<ol>
<li>si la valeur du ruban de <code>R-S</code> vaut la valeur sur le ruban <code>R-T1</code>, aller en 3.</li>
<li>sinon décaler les rubans <code>R-T0</code> à <code>R-T4</code> d'un paramètre à droite et retour en 2.</li>
</ol>
</li>
</ol>
</li>
<li>Faire la transition courante sur <code>R-S</code>
<ol>
<li>nouvel état : efface le ruban <code>R-Q</code> et écriture du paramètre de <code>R-T2</code> sur <code>R-Q</code></li>
<li>écriture du ruban : écriture de la case sous <code>R-T3</code> sur <code>R-I</code></li>
<li>déplacement du ruban : déplacement de <code>R-I</code> vers la droite si la case du ruban <code>R-T4</code> vaut <code>1</code> et déplacement vers la gauche sinon</li>
</ol>
</li>
<li>Retour au début des paramètres pour les rubans <code>R-Q</code> et de <code>R-T0</code> à <code>R-T4</code> (à gauche de chaque curseur il y a deux caractères <code>#</code> à la suite)</li>
<li>retour en 2.</li>
</ol>
<h3>Conclusion</h3>
<p>Nous venons de faire un ordinateur avec une machine de Turing !</p>
<ul>
<li>les registres : état</li>
<li>l'unité arithmétique : le ruban interne</li>
<li>le code : la représentation de la transition sous une forme <em>compilée</em>, compréhensible par un ordinateur.</li>
<li>la mémoire : le ruban de la machine à simuler</li>
</ul>
<p>Le principe que nous venons d'expliciter en créant une MTU est exactement celui qui est utilisé en vrai avec vos ordinateurs.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Théorème fondamental de l'algorithmie</strong></p>
</div><div class="pl-8 mr-8">
<p>On peut encoder toute machine de Turing $M$ par une chaîne $E$ composée de <code>0</code> et de <code>1</code>, de telle sorte que l'exécution de la machine de Turing universelle $\text{MTU}(E)$ simule l'exécution de $M$.</p>
</div>
</div>
<p>La machine de Turing universelle est donc <a href="https://fr.wikipedia.org/wiki/Anneau_unique">la machine qui les gouverne toutes</a>.</p>
<p>Attention cependant, On a l'impression qu'on a besoin de rien, que toutes les machines de Turing sont en faite une seule. Ce n'est pas exactement le cas car l'encodage cache la machine. C'est un petit peu comme dans la blague ci-dessous. Un numéro n'est drôle que parce qu'il code une blague !</p>
<pre class="language-text " style="counter-reset: linenumber 0"><code class="language-text">Une famille qui connaît toutes les blagues de la planète 
les a classées et numérotées. Ainsi, le seul numéro suffit 
à les faire rire.

Lors d' un repas le père s'exclame : "12" !
Tout le monde pouffe de rire.
La mère dit : "32" !
Et ils éclatent de rire.
Le petit sort alors : "104" !
Et personne ne rit.
Son frère lui dit alors : " Tu la racontes mal !"
</code></pre>
<p>Grâce à la machine de Turing universelle, démontrer qu'un langage est <a href="https://fr.wikipedia.org/wiki/Turing-complet">Turing complet</a> c'est à dire qu'il permet de calculer tout ce qu'une machine de Turing peut calculer revient à montrer qu'on peut simuler une machine de Turing. Comme il est facile de simuler une MTU en pseudo-code (on l'a fait <a href="#pseudo-code-MTU">juste avant</a>) on en conclut :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Proposition</strong></p>
</div><div class="pl-8 mr-8">
<p>Tout ce qui peut s'écrire avec une machine de Turing peut s'écrire avec un pseudo-code.</p>
</div>
</div>
<h2>Turing complet</h2>
<p>Les deux parties précédentes ont permit de démontrer les deux implication du théorème suivant :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>théorème</strong></p>
</div><div class="pl-8 mr-8">
<p><a href="../algorithme/pseudo-code/%22">Pseudo-code</a> et <a href="../d%C3%A9finition">machine de Turing</a> sont deux notions équivalentes.</p>
</div>
</div>
<p>Mais le pseudo-code n'est pas le seul système qui permet de simuler toutes les machines de Turing.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>définition</strong></p>
</div><div class="pl-8 mr-8">
<p>Un système est dit <a href="https:/fr.wikipedia.org/wiki/Turing-complet">Turing complet</a> s'il permet de faire tout ce qu'une machine de Turing peut faire.</p>
</div>
</div>
<p>Une façon de montrer qu'un système est Turing complet est de faire ce qu'on a fait pour le pseudo--code, montrer qu'il peut simuler l'exécution d'une machine de Turing. De là il peut simuler l'exécution d'une machine de Turing Universelle et donc faire tout ce que peut faire une machine de Turing.</p>
<p>Cette preuve permet de montrer que les systèmes suivant sont Turing complet :</p>
<ul>
<li>un processeur</li>
<li>la quasi-totalité des langages de programmation</li>
<li>excel</li>
<li>factorio</li>
<li>minecraft</li>
<li>...</li>
</ul>
<p>Ce qu'il faut retenir de tout ça, c'est qu'il est très facile d'être Turing Complet !</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p>L'exemple de système Turing complet le plus simple que je connaisse est l'automate uni-dimensionnel respectant la <a href="https://en.wikipedia.org/wiki/Rule_110">règle 110</a>.</p>
<p>Jetez-y un coup d'œil, c'est assez bluffant.</p>
</div>
</div>
<p>Bien qu'il soit très facile pour un système d'être Turing Complet, toute les tentatives de généralisation  se sont révéler vaines.<br>
La notion de Machine de Turing semble capturer l'essence même de ce qu'est un algorithme.</p>
<h2><span id="thèse-Church-Turing"></span>Thèse de Church-Turing</h2>
<p>Une machine de Turing (et donc le pseudo-code) est a priori un cas particulier d'algorithme puisque l'on se limite à un nombre fixé d'instructions et à une construction rigide et normée de ceux ci. Mais toutes les tentatives de généralisation ont échoués : elle n'ont jamais permis de faire des algorithmes impossible à réaliser en pseudo-code.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-emerald-500 bg-emerald-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
  <path stroke-linecap="round" stroke-linejoin="round" d="M13.19 8.688a4.5 4.5 0 011.242 7.244l-4.5 4.5a4.5 4.5 0 01-6.364-6.364l1.757-1.757m13.35-.622l1.757-1.757a4.5 4.5 0 00-6.364-6.364l-4.5 4.5a4.5 4.5 0 001.242 7.244"></path>
</svg>
<div class="pl-8 mr-8">
<p>Si ces considérations vous intéressent, n'hésitez pas à jeter un coup d'œil à ce lien :<br>
<a href="https://plato.stanford.edu/entries/turing-machine/#ThesDefiAxioTheo">https://plato.stanford.edu/entries/turing-machine/#ThesDefiAxioTheo</a></p>
<p>C'est en Anglais, mais c'est très bien.</p>
</div>
</div>
<p>On pense donc (mais ce n'est pas démontré) que :</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Thèse de Church-Turing</strong></p>
</div><div class="pl-8 mr-8">
<p>Les notions d'algorithme et de pseudo-code sont équivalentes.</p>
<p>Tout algorithme peut être écrit en pseudo-code.</p>
</div>
</div>
<p>En bon informaticien, on considérera la thèse de Church-Turing vérifiée et :</p>
<ul>
<li>on écrira tous nos algorithmes en pseudo-code</li>
<li>pseudo-code et algorithme seront considérés comme synonyme.</li>
</ul>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>