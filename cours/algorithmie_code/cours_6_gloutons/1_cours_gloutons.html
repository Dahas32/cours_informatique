<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Algorithmes gloutons | cours d’informatique</title>
<meta name="generator" content="Jekyll v4.2.0">
<meta property="og:title" content="Algorithmes gloutons">
<meta name="author" content="François Brucker">
<meta property="og:locale" content="en_US">
<meta name="description" content="Support de cours/td d’informatique de François Brucker.">
<meta property="og:description" content="Support de cours/td d’informatique de François Brucker.">
<link rel="canonical" href="/cours_informatique/cours/algorithmie_code/cours_6_gloutons/1_cours_gloutons.html">
<meta property="og:url" content="/cours_informatique/cours/algorithmie_code/cours_6_gloutons/1_cours_gloutons.html">
<meta property="og:site_name" content="cours d’informatique">
<meta property="og:type" content="website">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="Algorithmes gloutons">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"François Brucker"},"description":"Support de cours/td d’informatique de François Brucker.","headline":"Algorithmes gloutons","url":"/cours_informatique/cours/algorithmie_code/cours_6_gloutons/1_cours_gloutons.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/cours_informatique/assets/main.css">

  <link rel="stylesheet" href="/cours_informatique/assets/custom.css">

  <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
<link type="application/atom+xml" rel="alternate" href="/cours_informatique/feed.xml" title="cours d'informatique">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

<body>
<header class="site-header" role="banner">

  <div class="wrapper">
<a class="site-title" rel="author" href="/cours_informatique/">cours d'informatique</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger">
            <a class="page-link" href="/cours_informatique/about"> about </a>
        </div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
    <h1 class="post-title">Algorithmes gloutons</h1>Auteur : <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">François Brucker</span></span>
  </header>

  <div class="post-content">
    <h2 id="but">But</h2>

<p>Montrer l’intérêt des algorithmes gloutons, la façon de les construire et de prouver qu’ils fonctionnent. On s’attachera dans cette séance tableau à prouver qu’ils rendent une solution optimale à un problème donné.</p>

<p>On va voir la construction et la preuve des algorithmes gloutons à l’aide d’exemples, de plus en plus complexes :</p>

<ol>
  <li><a href="#exemple--le-rendu-de-pi%C3%A8ces">le rendu de pièce</a></li>
  <li><a href="#exemple--allocation-de-salles-de-cin%C3%A9ma">l’allocation de ressources</a></li>
  <li><a href="#exemple--ordonnancement">ordonnancement</a></li>
</ol>

<h2 id="algorithmes-gloutons">Algorithmes gloutons</h2>

<p>Un <a href="https://fr.wikipedia.org/wiki/Algorithme_glouton">algorithme glouton</a> choisit à chaque étape la meilleure possibilité localement. Ce type d’algorithmes est très utilisé pour résoudre des problèmes où l’on veut une réponse rapide, mais pas forcément une réponse optimale. D’un point de vue théorique, ces algorithmes sont extrêmement importants. Il sont, par exemple, en bijection avec la <a href="https://fr.wikipedia.org/wiki/Matro%C3%AFde">structure de matroïde</a>.</p>

<p>Intérêt :</p>

<ul>
  <li>donne toujours un résultat</li>
  <li>souvent de complexité faible</li>
</ul>

<p>Problème :</p>

<ul>
  <li>ne donne pas forcément le meilleur résultat : une <em>heuristique</em>
</li>
  <li>pas forcément de solution unique</li>
</ul>

<p>Pour beaucoup de problèmes d’optimisation, un algorithme glouton est optimal pour une version simplifiée du problème. Comme l’algorithme va vite, on peut recommencer plusieurs fois pour trouver une meilleure solution.</p>

<h3 id="optimalité-et-glouton">optimalité et glouton</h3>

<p>Les problèmes d’optimalité demandent de trouver, parmi un ensemble de solutions possible, une solution minimisant (ou maximisant) un critère. Par exemple :</p>

<ul>
  <li>pour un ensemble de coûts de constructions possibles d’une voiture, trouver celle qui minimise le coûts tout en maximisant la qualité totale des pièces,</li>
  <li>parmi tous les parcours passant par un ensemble de villes donné, choisir celui qui minimise le nombre de kilomètres parcourus</li>
  <li>maximiser le nombre de films projetés dans un multiplexe de cinéma</li>
  <li>…</li>
</ul>

<p>La difficulté de ces problèmes vient du fait que l’on ne peut a priori pas trouver la meilleure solution sans les examiner toutes. Et s’il y a beaucoup de solutions ça peut prendre vraiment beaucoup de temps.</p>

<p>Certains problèmes cependant permettent d’être résolus en construisant petit à petit une solution, sans jamais remettre en cause ses choix. On peut alors souvent trouver très rapidement la meilleure solution possible. On peut également utiliser cette solution construite petit à petit pour trouver une solution approchée à un problème plus général. Cette classe d’algorithmes qui construit itérativement d’une solution est appelée <em>algorithmes gloutons</em>.</p>

<h3 id="condition-nécessaire-et-suffisante-doptimalité">condition nécessaire et suffisante d’optimalité</h3>

<p>Pour qu’un algorithme glouton <strong>trouve une solution optimale</strong> il faut :</p>

<ul>
  <li>
<strong>initialisation</strong> : montrer qu’il existe une solution optimale contenant le 1er choix de l’algorithme</li>
  <li>
<strong>récurrence</strong> : montrer que la première différence entre une solution optimale et la solution de l’algorithme ne peut résulter en une meilleure solution. Pour cela on cherchera une solution optimale dont les choix coïncident le plus longtemps possible avec la solution donnée par notre algorithme et on prouvera qu’elles coïncident jusqu’à la fin.</li>
</ul>

<h2 id="exemple--le-rendu-de-pièces">exemple : le rendu de pièces</h2>

<h3 id="un-système-de-pièce-particulier">Un système de pièce particulier</h3>

<p>Proposons un algorithme glouton permettant de rendre la monnaie d’un achat en un nombre minimum de pièces valant 5, 2 et 1 pokédollar.</p>

<p>Cet algorithme doit répéter : choisir la pièce de plus grande valeur $v$ qui ne dépasse pas la somme restante R puis poser R = R - v”.</p>

<h4 id="algorithme--rendu-de-pièce">algorithme : rendu de pièce</h4>

<ul>
  <li>
<strong>Problème</strong> : “comment rendre R sous en un nombre minimum de pièces”</li>
  <li>
<strong>algo glouton</strong> :
    <ol>
      <li>choisir la plus grande valeur $v$ de pièce plus petite que $R$</li>
      <li>donner $p = R // v$ pièces</li>
      <li>$R = R - p * v$</li>
      <li>revenir en 1. si R &gt; 0</li>
    </ol>
  </li>
  <li>
<strong>complexité</strong> : tri des valeur de pièce + une opération par pièce (division puis soustraction). Comme il suffit de trier une fois pour toute, la complexité peut être de l’ordre du nombre de pièces.</li>
</ul>

<h4 id="preuve-doptimalité-pour-un-système-de-pièce-valant-1-2-et-5">Preuve d’optimalité pour un système de pièce valant 1, 2 et 5</h4>

<p>Si on a une solution optimale pour un problème donné, quelques cas seulement sont possibles pour le nombre de pièces de 2 et de 1 :</p>

<ul>
  <li>pas plus de 2 pièces de 2 : on peut rendre moins de pièce en transformant 3 pièces de 2 en 1 pièce de 5 plus une pièce de 1</li>
  <li>pas plus de 1 pièce de 1 : sinon on transforme 2 pièces de 1 en 1 pièce de 2</li>
  <li>on ne peux pas avoir 2 pièces de 2 et 1 pièce de 1 : sinon on peut convertir 2 pièces de 2 et 1 pièce de 1 en 1 pièce de 5.</li>
</ul>

<p>Ceci prouve que la somme d’argent rendu en pièce de 2 et de 1 ne peut dépasser 4.</p>

<p>Pour prouver l’algorithme on doit prouver les 2 propriétés :</p>

<ul>
  <li>initialisation : On regarde le 1er choix de l’algorithme.
    <ul>
      <li>Si le nombre de pièce à rendre est 0, 1, 2, 3 ou 4, notre algorithme va rendre à chaque fois le nombre optimal de pièce. Son premier choix est donc toujours contenu dans une solution optimale : la propriété est ok.</li>
      <li>si le nombre de pièce est plus grand ou égal à 5, l’algorithme va choisir de rendre $p = R // 5$ pièces de 5.  si on suppose que toute solution optimale rend un nombre différent de $p$ pièces de 5, toute solution optimale en rend forcement strictement moins que $p$ puisque $(p+1) * 5$ est strictement plus grand que le nombre de sous à rendre initial. Mais si les solutions optimales rendent moins de $p$ pièces de 5 la somme à rendre en pièce de 2 et de 1 est strictement plus grande que 5 ce qui est impossible : la propriété est ok.</li>
    </ul>
  </li>
  <li>récurrence : Les solutions optimales choisissent toute le même nombre de pièce de 5 que notre algorithme. La valeur totale des pièces de 2 et de 1 ne peut donc pas excéder 4 pour les solutions optimales et donc le nombre de pièces coïncide avec notre algorithme (puisqu’il est optimal lorsqu’il faut rendre 4 ou moins).
Démontrez que votre algorithme est bien optimal.</li>
</ul>

<h3 id="système-de-pièces-quelconque-">système de pièces quelconque ?</h3>

<p>On peut démontrer que <a href="https://cm2.ens.fr/sites/default/files/Algorithmes%20gloutons%20avec%20la%20classe_v4.pdf">le système de pièce européen fonctionne</a> (page 7. Mais tout le reste est bien intéressant aussi) avec les pièces et billets de : 1, 2, 5, 10, 20, 50, 100 et 200.</p>

<p>Attention, ne marche pas pour tous les systèmes de pièces :</p>

<ul>
  <li>exemple 1, 3, 4. Pour rendre 6 il donne 4 + 1 + 1 alors que c’est 3 + 3 le mieux.</li>
  <li>1, 6, 11, 19 ne fonctionne pas non plus pour 22 par exemple (le système est cependant super-croissant).</li>
</ul>

<p><strong>Remarques</strong> :</p>

<ul>
  <li>c’est pourquoi il n’y a pas de billets de 7 euros (10 = 7 + 2 + 1, mais surtout 5 + 5). Dingue, non ?</li>
  <li>ce n’est pas la seule solution puisque les américains ont des pièces de 25c (les quarter)</li>
  <li>peut poser des soucis : les machines à café vous indiquent qu’elles ne peuvent plus vous rendre la monnaie car il n’y a plus de pièces d’une valeur particulière, alors qu’en réalité elle disposent de la somme à rendre en utilisant une autre combinaison.</li>
</ul>

<h2 id="exemple--allocation-de-salles-de-cinéma">exemple : allocation de salles de cinéma</h2>

<p>Un gérant de cinéma a en sa possession $m$ films caractérisés chacun par des couples ($d_i$, $f_i$) où $d_i$ est l’heure de début du film et $f_i$ l’heure de fin. Il se pose 2 problèmes :</p>

<ul>
  <li>Quel est le nombre maximum de films que je peux voir en une journée ?</li>
  <li>Quel est le nombre minimum de salles à avoir pour visionner tous les films en stock.</li>
</ul>

<p>Chaque film est décrit par un couple $(d, f)$ où $d$ est la date de début du film et $f$ la date de fin.</p>

<h3 id="voir-un-maximum-de-films">voir un maximum de films</h3>

<p>On cherche à rendre une liste maximale de films à voir en une journée.</p>

<p>On va construire l’algorithme glouton en utilisant la création classique de ceux-ci : on trouve un ordre dans lequel classer les entrées puis on regarde les entrées dans cet ordre et on les ajoute à la solution si c’est possible.</p>

<p>L’ordre que l’on va choisir est celui de la date de fin croissante.</p>

<p>En effet, si l’on classe les séances de cinéma par :</p>

<ul>
  <li>durée croissante : l’ensemble de films $[(1, 3), (3, 5), (5, 7), (2.5, 3.5), (4.5, 5.5)]$ produit un contre exemple,</li>
  <li>date de début croissante : l’ensemble de films $[(1, 10), (2, 3), (3, 4)]$ produit un contre exemple,</li>
</ul>

<h4 id="algorithme--maximum-de-films">algorithme : maximum de films</h4>

<ul>
  <li>entrée : liste de films, chaque liste étant une liste <code class="language-plaintext highlighter-rouge">[depart, fin, nom]</code>.</li>
  <li>sortie : liste d’indices de films où indice est l’indice du film dans la liste d’entrée.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">nombre_films_maximal</span><span class="p">(</span><span class="n">films</span><span class="p">):</span>

    <span class="n">films</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">films_a_voir</span> <span class="o">=</span> <span class="p">[</span><span class="n">films</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">film</span> <span class="ow">in</span> <span class="n">films</span><span class="p">:</span>
        <span class="n">fin_dernier_film</span> <span class="o">=</span> <span class="n">films_a_voir</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">début_nouveau_film</span> <span class="o">=</span> <span class="n">film</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fin_dernier_film</span> <span class="o">&lt;=</span> <span class="n">début_nouveau_film</span><span class="p">:</span>
            <span class="n">films_a_voir</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">film</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">films_a_voir</span>
</code></pre></div></div>

<p>La sortie de l’algorithme glouton correspond à un ordre de visionnage de films maximisant le nombre de films vus.</p>

<p><strong>remarques</strong> : On a utilisé quelques astuces de programmation python :</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">l[-1]</code> rend le dernier élément d’une liste.
boucle <code class="language-plaintext highlighter-rouge">for</code>.</li>
  <li>on a un peu fait de magie noire sur les tris en utilisant le paramètre <a href="https://docs.python.org/fr/3/howto/sorting.html#key-functions">key</a> qui permet de passer une fonction en paramètre. Cette fonction est appelé pour chaque élément. C’est pratique pour ne trier que selon 1 élément d’une liste (ici le 2ème élément).</li>
</ul>

<p>On utilise aussi l’écriture lambda qui permet de créer des fonction d’une ligne anonyme. Notre fonction lambda est équivalente à :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">truc</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></div>

<h4 id="preuve-de-lalgorithme--maximum-de-films">preuve de l’algorithme : maximum de films</h4>

<p>On prouve notre algorithme comme tout algorithme glouton : on suppose que l’algorithme glouton ne donne pas une solution optimale et on considère une solution optimale coïncidant le plus longtemps possible avec la solution donnée par celui-ci.</p>

<p>Soit $i$ l’indice de la première différence. On note $f_i$ le film choisi par le glouton et $f’_i$ le film (différent de $f_i$) choisi par la solution optimale :</p>

<ul>
  <li>la date de fin de $f’_i$ est plus grande que la date de fin de $f_i$ par construction de la solution par l’algorithme glouton.</li>
  <li>la date de début de $f’_i$ est avant la date de fin de $f_i$ sinon on pourrait ajouter $f_i$ à la solution optimale et rendre une solution avec strictement  plus de films</li>
</ul>

<p>Les deux remarques ci-dessus amènent au fait que l’on peut construire une nouvelle solution en échangeant $f’_i$ par $f_i$ dans la solution optimale. Comme cette nouvelle solution a autant de films que la solution optimale, elle est aussi optimale. Ceci est impossible par hypothèse (on prend une solution optimale coïncidant le plus longtemps possible avec la solution de l’algorithme glouton) : notre hypothèse était fausse, l’algorithme glouton est optimal.</p>

<h3 id="nombre-minimum-de-salles-pour-placer-tous-les-films-en-stock">nombre minimum de salles pour placer tous les films en stock</h3>

<p>On essaie ici de trouver le nombre minimum de salles à construire pour pouvoir projeter tous les films</p>

<h4 id="algorithme--nombre-de-salle-minimum">algorithme : nombre de salle minimum</h4>

<p>On va ici classer les films par date de début croissante. On commence par 0 salles de cinéma.</p>

<p>En analysant dans cet ordre les films, on cherche s’il existe une salle à laquelle on peut rajouter le film (la date de fin du dernier film de la salle est plus tôt que le début du nouveau film). Si oui on rajoute le film à cette salle, si non on crée une nouvelle salle.</p>

<h4 id="preuve-de-lalgorithme--minimum-de-salles">preuve de l’algorithme : minimum de salles</h4>

<p>La preuve est ici aisée car si on rajoute une salle pour loger un nouveau film $f$, ca veut dire que pour toutes les $k$ salles actuelle il y a un film qui n’est pas fini pendant le début du nouveau film. Ca signifie qu’il existe $k$ films dont le début est avant $f$ et la fin après $f$ : il faut donc au moins $k+1$ salles pour jouer tous ces films en parallèle.</p>

<h2 id="exemple--ordonnancement">exemple : ordonnancement</h2>

<p>Les problèmes d’ordonnancement sont multiples. Certains sont durs d’autres faciles. Mais un algorithme glouton permet de trouver souvent une solution acceptable pour beaucoup d’entres eux et même parfois optimale pour certains problèmes.</p>

<p>Le problème suivant est résoluble par un algorithme glouton : On considère $m$ produits de durée 1 à fabriquer. Si le produit $i$ est réalisée avant la date $d_i$ on peut le vendre pour un prix $p_i$, sinon il est invendable. Proposez un algorithme permettant de maximiser les profits en considérant que l’on a qu’un seul ouvrier.</p>

<p>Il faut procéder en deux temps :</p>

<ul>
  <li>on doit tout d’abord se doter d’un algorithme permettant de savoir si on peut vendre tous les éléments d’un ensemble de produit donné</li>
  <li>créer un ensemble maximum de produits dont on peut vendre tous les éléments.</li>
</ul>

<h3 id="ensemble-compatible">ensemble compatible</h3>

<p>Un ensemble de produits est dit <em>compatible</em> s’il existe un ordonnancement de leur production permettant de tous les vendre (chaque produit est fabriqué avant sa date de péremption).</p>

<p>On montre qu’un ensemble de produits est compatible si et seulement si l’ordonnancement par date $d_i$ croissante permet de tous les vendre. En effet :</p>

<ul>
  <li>si l’ordonnancement par date croissante permet de tout vendre il est compatible</li>
  <li>s’il existe un autre ordonnancement avec la tâche $j$ placé avant la tâche $i$ alors que $d_j &gt; d_i$, on peut échanger la tâche $i$ et la tâche $j$ et l’ordonnancement reste compatible</li>
</ul>

<h3 id="algorithme--ensemble-compatible-maximum">algorithme : ensemble compatible maximum</h3>

<p>Montrons que l’algorithme glouton suivant est optimal :</p>

<ol>
  <li>on trie les produits par prix décroissant</li>
  <li>ensemble = {}</li>
  <li>pour chaque produit x dans cet ordre : on ajoute x à ensemble s’il reste compatible</li>
  <li>rendre ensemble (qui est un ensemble de profit maximal)</li>
</ol>

<h3 id="preuve--ensemble-compatible-maximum">preuve : ensemble compatible maximum</h3>

<ul>
  <li>initialisation : si une solution ne contient pas l’élément de prix maximum on l’échange avec le 1er élément choisi et la solution reste compatible tout en ayant un profit plus grand</li>
  <li>récurrence : clair. S’il reste dans les solutions possible l’élément qu’on rajoute à l’étape $i$ on peut toujours le rendre à la place de celui pris par l’autre solution pour augmenter le profit.</li>
</ul>

  </div>

</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/cours_informatique/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">cours d'informatique</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">cours d'informatique</li>
</ul>
      </div>

      <div class="footer-col footer-col-2">
<ul class="social-media-list"><li><a href="https://github.com/FrancoisBrucker"><svg class="svg-icon"><use xlink:href="/cours_informatique/assets/minima-social-icons.svg#github"></use></svg> <span class="username">FrancoisBrucker</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Support de cours/td d'informatique de François Brucker.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
