<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <title>DS 1 : mines-ponts 2017</title>

    <link href=/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css rel="stylesheet">
    <link href=/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css rel="stylesheet">

    <link href=/cours_informatique/assets/stylesheets/main.css rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" 
  src=/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1  >DS 1 : mines-ponts 2017</h1>
  <div >
    

    
  </div>

  

  

  <div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Sujet</strong></p>
</div><div class="pl-8 mr-8">
<p>Le sujet du DS 1 est <a href="mines-info-2017-sujet.pdf">L'épreuve commune d'informatique mines/ponts 2017</a> (sans la partie VI).</p>
<p>La durée du contrôle était de 3h, c'est à dire le double de celui normalement alloué à l'épreuve.</p>
</div>
</div>
<h2>Barème</h2>
<blockquote>
<p>TBD</p>
</blockquote>
<h2>Remarques</h2>
<p>Comme en code (maxime de Kent Beck) :</p>
<ol>
<li>make if work</li>
<li>make it right</li>
<li>make it fast</li>
</ol>
<p>Pour l'instant, on se concentre sur le 1 et 2, vous aviez ainsi 3h pour un sujet de 1h30. Si vous avez bien compris et réussi le sujet, il vous faut travailler la rapidité en L2 et L3.</p>
<h3>Remarques Q2</h3>
<p>1 != True</p>
<p>Comme A = cte, alors O(1). Ne fonctionne que pour A par pour une autre liste.</p>
<h3>Remarques Q3</h3>
<p>on ne teste pas la véracité des booléen, on l'utilise.</p>
<h3>Remarques Q5</h3>
<p>Attention aux tailles des listes.</p>
<pre><code>def compare(L1, L2):
    for i in range(len(L1)):
        if L1[i] != L2[i]:
        return False
    return True
</code></pre>
<p>Produit une erreur si <code class="language-">len((L2)) &lt; len(L1)</code> et est faux si <code class="language-">len((L2)) &gt; len(L1)</code> (par exemple <code class="language-">L1= [1, 2]</code> et <code class="language-">L2 = [1]</code>).</p>
<h3>Remarques Q7</h3>
<p>Le terme est booléen. Dire juste <code class="language-">True</code> ou <code class="language-">False</code> n'est pas suffisant.</p>
<h3>Remarques Q8-Q11</h3>
<p>Le sujet donne des fonctions à coder, il faut les utiliser. En plus, les algorithmes deviennent plus simple.</p>
<p>Attention aux complexité. La concaténation crée une nouvelle liste, sa complexité est égale à la somme des tailles des 2 listes.</p>
<h2>Correction</h2>
<h3>Q1</h3>
<p>Une suite de $n$ cases successives se modélise par une liste de longueur $n$. Comme les voitures sont indifférenciées et qu'il n' peut y avoir qu'une voiture au maximum par case, on peut modéliser une file de voiture par une liste $A$ :</p>
<ul>
<li>de longueur $n$</li>
<li>s'il y a une voiture dans la case $i$ de la file on note <code class="language-">A[i] = True</code></li>
<li>s'il n'y a pas de voiture dans la case $i$ de la file on note <code class="language-">A[i] = False</code></li>
</ul>
<h3>Q2</h3>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">,</span> <span class="token boolean">True</span><span class="token punctuation">]</span>
</code></pre>
<p>Ou si on veut la créer :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">A <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    A<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>
</code></pre>
<p>La complexité de l'algorithme précédent est en $\mathcal{O}(1)$ car il ne fonctionne <strong>que</strong> pour $A$ qui est de taille $11$.</p>
<h3>Q3</h3>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">occupe</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
</code></pre>
<p>La complexité de fonction <code>occupe(L, i)</code> est $\mathcal{O}(1)$ puisque'il suffit accéder à un élément d'une liste. Elle donne bien le résultat attendu si $L$ est conforme à Q1.</p>
<h3>Q4</h3>
<p>Chaque case pouvant être occupée ou non, il y a deux possibilités pour chacune des $n$ cases d'une liste : il y a $2^n$ possibilités.</p>
<h3>Q5</h3>
<p>Les deux solutions suivantes sont équivalentes :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> égal<span class="token punctuation">(</span>L1<span class="token punctuation">,</span> L2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>L1<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>L2<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>L1<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> L1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> L2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
    <span class="token keyword">return</span> <span class="token boolean">True</span>
</code></pre>
<p>et</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> égal<span class="token punctuation">(</span>L1<span class="token punctuation">,</span> L2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> L1 <span class="token operator">==</span> L2
</code></pre>
<p>Les deux fonctions vérifient que les longueurs des deux listes sont égales et que leurs éléments coïncident.</p>
<h3>Q6</h3>
<p>A part la boucle <code class="language-">for</code> toutes les autres opérations de la méthode <code class="language-">égal</code> sont en $\mathcal{O}(1)$. Si les deux listes à comparer sont égales, il faut parcourir tous les éléments de la liste : la complexité est donc en $\mathcal{O}(n)$ où $n$ est la longueur de la liste <code class="language-">L1</code>.</p>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
</svg>
<div class="pl-8 mr-8">
<p>Les complexités des deux fonctions <strong>sont les mêmes</strong>. La comparaison de deux listes en python avec l'opérateur <code>==</code> est de complexité égal à la taille de la plus petite des listes.</p>
</div>
</div>
<h3>Q7</h3>
<p>Le retour de la fonction <code class="language-">égal</code> est un booléen.</p>
<h3>Q8</h3>
<p>Procédons par étape. Position initiale <code class="language-">A = [True, False, True, True, False, False, False, False, False, False, True]</code> :</p>
<pre><code>A  : ⇨▢⇨⇨▢▢▢▢▢▢⇨
</code></pre>
<p>L'instruction <code class="language-">P2 = avancer(avancer(A, False), True)</code> revient à exécuter <code>avancer(P1, True)</code> où <code class="language-">P1=avancer(A, False)</code>. Il faut donc commencer par déterminer <code>P1</code> avant de calculer <code>avancer(P1, P2)</code>.</p>
<p>On a que <code class="language-">P1 = avancer(A, False)</code> vaut <code class="language-">[False, True, False, True, True, False, False, False, False, False, False]</code>.</p>
<pre><code>A  : ⇨▢⇨⇨▢▢▢▢▢▢⇨
P1 : ▢⇨▢⇨⇨▢▢▢▢▢▢
</code></pre>
<p>De là, <code class="language-">avancer(P1, True)</code> vaut alors : <code class="language-">[True, False, True, False, True, True, False, False, False, False, False]</code></p>
<pre><code>A  : ⇨▢⇨⇨▢▢▢▢▢▢⇨
P1 : ▢⇨▢⇨⇨▢▢▢▢▢▢
P2 : ⇨▢⇨▢⇨⇨▢▢▢▢▢
</code></pre>
<h3>Q9</h3>
<p>En python :</p>
<ul>
<li>$L[:m]$ correspond aux $m$ premiers éléments de la liste, donc ceux allant de l'indice 0 à l'indice $m-1$</li>
<li>$L[m:]$ correspond aux derniers éléments de la liste en commençant par celui d'indice $m$.</li>
</ul>
<p>Il faut faire avancer les dernier éléments de la liste (avec <code class="language-">avancer</code>) sans toucher au  prmeirs éléments :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">avancer_fin</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> L<span class="token punctuation">[</span><span class="token punctuation">:</span>m<span class="token punctuation">]</span> <span class="token operator">+</span> avancer<span class="token punctuation">(</span>L<span class="token punctuation">[</span>m<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token boolean">False</span><span class="token punctuation">)</span>
</code></pre>
<p>La complexité de la fonction précédente est en $\mathcal{O}(n)$ où $n$ est la taille de la liste. Car la créations<br>
des listes partielles et la fonction avancer sont toutes de complexités égales à la longueur des listes qu'elles manipulent.</p>
<h3>Q10</h3>
<p>La case $L[m]$ étant inoccupée, faire avancer le début de la liste ne va pas faire <em>déborder</em>de voiture. On peut alors procéder exactement de la même manière que pour la question précédente (en faisant attention à l'indice de fin du découpage), ce qui donne une complexité égale à $\mathcal{O}(n)$.</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">avancer_debut</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> b<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> avancer<span class="token punctuation">(</span>L<span class="token punctuation">[</span><span class="token punctuation">:</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">+</span> L<span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
</code></pre>
<h3>Q11</h3>
<p>On remonte la liste de l'indice $i=m-1 à $i=0$ jusqu'à trouver une case non occupée. Une fois celle ci trouvée on utilise <code class="language-">avancer_debut</code> de la question précédente.</p>
<p>Si aucune case n'est libre (on arrive à la fin de la boucle <code class="language-">for</code>),une telle case n'existe pas on rend uniquement une copie de la liste puisque rien ne peut bouger.</p>
<p>La remontée de l'indice $i$ prenant au maximum $\mathcal{O}(m)$ opérations et comme <code class="language-">avancer_debut</code> est de complexité proportionnelle à la taille de sa liste en entrée, la complexité totale est en $\mathcal{O}(m)$.</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">avance_debut_bloque</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> b<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> occupe<span class="token punctuation">(</span>L<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> avancer_debut<span class="token punctuation">(</span>L<span class="token punctuation">,</span> b<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token builtin">list</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token comment"># copie de la liste</span>
</code></pre>
<p>Il y a aussi la version récursive qui se rappelle s'il n'est pas possible de résoudre le problème directement :</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">avance_debut_bloque</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> b<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> m <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token builtin">list</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span> <span class="token comment"># copie de la liste    </span>
    <span class="token keyword">elif</span> <span class="token keyword">not</span> occupe<span class="token punctuation">(</span>L<span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> avancer_debut<span class="token punctuation">(</span>L<span class="token punctuation">,</span> b<span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> avance_debut_bloque<span class="token punctuation">(</span>L<span class="token punctuation">,</span> b<span class="token punctuation">,</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre>
<div class="quote relative py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-red-500 bg-red-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
</svg>
<div class="pl-8 mr-8">
<p>Le sujet demande de rendre une <strong>copie</strong> de la liste.</p>
</div>
</div>
<h3>Q12</h3>
<p>On procède comme indiqué dans le sujet :</p>
<ol>
<li>on avance la file $L1$ et la file $L$2 à partir du croisement, aucun blocage ne peut arriver</li>
<li>la case du croisement est forcément libre pour $L1$ et $L2$ après la première étape, on peut donc avancer le début de la file $L1$</li>
<li>si le croisement est libre (la case m n'est pas occupée pour $L1$) on peut avancer le début de $L2$, sinon on effectue un avancement avec le début bloqué.</li>
</ol>
<p>Comme il y a un nombre constant de fonction dépendant de la taille des listes en entrée, on en déduit que la complexité totale est en $\mathcal{O}(n)$ où $n$ est la taille des listes.</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">avancer_files</span><span class="token punctuation">(</span>L1<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> L2<span class="token punctuation">,</span> b2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    m <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>L1<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>
    
    R1 <span class="token operator">=</span> avancer_fin<span class="token punctuation">(</span>L1<span class="token punctuation">,</span> m<span class="token punctuation">)</span>
    R2 <span class="token operator">=</span> avancer_fin<span class="token punctuation">(</span>L2<span class="token punctuation">,</span> m<span class="token punctuation">)</span>
    
    R1 <span class="token operator">=</span> avance_debut<span class="token punctuation">(</span>R1<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> m<span class="token punctuation">)</span>

    <span class="token keyword">if</span> occupe<span class="token punctuation">(</span>R1<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span>
        R2 <span class="token operator">=</span> avance_debut_bloque<span class="token punctuation">(</span>R2<span class="token punctuation">,</span> b2<span class="token punctuation">,</span> m<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        R2 <span class="token operator">=</span> avance_debut<span class="token punctuation">(</span>R2<span class="token punctuation">,</span> b2<span class="token punctuation">,</span> m<span class="token punctuation">)</span>
    
    <span class="token keyword">return</span> <span class="token punctuation">[</span>R1<span class="token punctuation">,</span> R2<span class="token punctuation">]</span>
</code></pre>
<h3>Q13</h3>
<p>Position initiale :</p>
<pre><code>    E
    ▢
    ⇩ 
D ▢⇨⇩⇨▢
    ▢
    ▢
</code></pre>
<p>Après utilisation de la fonction <code class="language-">avancer-files(D, False, E, False)</code> on obtient :</p>
<pre><code>    E
    ▢
    ⇩ 
D ▢▢⇨▢⇨
    ⇩
    ▢
</code></pre>
<p>Ce qui donne comme listes :</p>
<ul>
<li><code class="language-">D = [False, False, True, False, True]</code></li>
<li><code class="language-">E = [False, True, False, True, False]</code></li>
</ul>
<h3>Q14</h3>
<p>Si la file $L1$ est pleine et qu'à chaque étape on ajoute une voiture, le croisement (d'indice $m$) sera toujours occupé par une voiture de $L1$ : aucun voiture de la file $L2$ ne pourra dépasser le croisement. Si la file $L2$ est pleine jusqu'à l'indice précédent le croisement, aucune ce ces voitures ne pourra se déplacer.</p>
<pre><code>     L2
     ⇩
     ⇩ 
L1 ⇨⇨⇨⇨⇨
     ▢
     ▢
</code></pre>
<h3>Q15</h3>
<p>Position initiale :</p>
<pre><code>      L2
       ⇩
       ⇩
       ⇩
       ⇩ 
L1 ⇨⇨⇨⇨▢▢▢▢▢
       ▢
       ▢
       ▢
       ▢
</code></pre>
<p>La file $L1$ étant prioritaire, les voitures de la file $L2$ ne peuvent avancer pendant les 4 premières étapes.  Puis il faut les déplacer, donc encore au moins 5 étapes. Le nombre minimal d'opérations est aisni d'au moins 4 + 5 = 9 opérations.</p>
<p>Ceci est suffisant :</p>
<p>On commence par faire 5 fois <code class="language-">avancer_files(L1, False, L2, False)</code>. Les 4 voitures de $L1$ ont dépassé le croisement et la première voiture de $L2$ est sur le croisement :</p>
<pre><code>      L2
       ▢
       ⇩
       ⇩
       ⇩ 
L1 ▢▢▢▢⇩⇨⇨⇨⇨
       ▢
       ▢
       ▢
       ▢
</code></pre>
<p>Puis on ajoute les nouvelles voitures de $L1$ en faisant 4 fois <code class="language-">avancer_files(L1, True, L2, False)</code> :</p>
<pre><code>      L2
       ▢
       ▢
       ▢
       ▢
L1 ⇨⇨⇨⇨▢▢▢▢▢
       ⇩
       ⇩
       ⇩
       ⇩ 
</code></pre>
<h3>Q16</h3>
<p>Cette étape finale est impossible à obtenir car la file $L1$ est prioritaire. A l'étape précédente il y a forcément une voiture de la file $L1$ sur le croisement, ce qui laisse un <em>trou</em> au croisement sur la file $L2$ :</p>
<pre><code>      L2
       ▢
       ▢
       ▢
       ⇩
L1 ▢▢▢▢⇨⇨⇨⇨?
       ⇩
       ⇩
       ⇩
       ? 
</code></pre>
<p>Ce <em>trou</em> ne peut être comblé en une étape : la position de l'étape (c) est impossible à obtenir.</p>
<h3>Q17</h3>
<p>La liste étant triée, un doublon est tel que $L[i] = L[i+1]$. On peut alors supprimer les doublons en parcourant la liste $L$ et en ne considérant que les éléments tels que $L[i] &gt; L[i-1]$. Ceci donne l'algorithme suivant :</p>
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> élimine_double<span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">:</span>
    L2 <span class="token operator">=</span> <span class="token punctuation">[</span>L<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token builtin">len</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> L<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> L<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>
            L2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token keyword">return</span> L2
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<div class="quote relative  py-2 drop-shadow rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-cyan-500 bg-cyan-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-cyan-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" />
</svg>
<div class="pl-8 mr-8">
<p>Pour une liste $L$, <code class="language-">L[-1]</code> renvoie son dernier élément. C'est équivalent à <code class="language-">L[len(L) - 1]</code>.</p>
</div>
</div>
<p>Comme la complexité de la méthode de liste <code class="language">append</code> est en $\mathcal{O}(1)$, la complexité du corps de la boucle for (lignes 5-6) est en $\mathcal{O}(1)$. Le nombre d'itération de cette boucle est en $\mathcal{O}(n)$, avec $n$ la taille de la liste, donc la complexité totale de l'algorithme est en $\mathcal{O}(n)$.</p>
<h3>Q18</h3>
<p>La fonction <code class="language-">doublons</code> rend une liste triée sans doublons de la liste triée passée en paramètre. Cette fonction étant récursive, nous allons le prover par récurrence sur la taille $n$ de la liste.</p>
<p>Si $n \leq 1$ on rend la liste en entrée, Ok. On suppose la propriété pour $n \geq 1$. A $n+1$.</p>
<p>Si $L[0] \neq L[1]$, $L[0]$ est le 1er élément de la liste triée sans doublons issue de $L$ et comme :</p>
<ul>
<li>tous les éléments de $L[1:]$ sont strictement plus grand que $L[0]$</li>
<li>par hypothèse de récurrence, <code class="language-">doublons(L[1:])</code> rendra la liste sans doublons de la liste triée $L[1:]$</li>
</ul>
<p>La liste triée sans doublons issue de $L$ est bien égale à $[L[0]] + doublons(L[1:]).</p>
<p>Si $L[0] \neq L[1]$ la liste triée sans doublons de $L$ est égale à la liste triée sans doublons de la liste $L$ privée de son élément $L[1]$. Ok</p>
<p>On a démontrée que <code class="language-">doublons</code> est une fonction qui rend une liste triée sans doublons de la liste triée passée en argument. Donc elle rendra <code class="language-">[1, 2, 3, 5]</code> pour la liste triée <code class="language-">[1, 1, 2, 2, 3, 3, 3, 5]</code> passée en paramètre.</p>
<h3>Q19</h3>
<p>Non, car elle rendrait $[1, 2, 1]$ pour la même liste en entrée.</p>
<div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>pour aller plus loin</strong></p>
</div><div class="pl-8 mr-8">
<p>La fonction <code class="language-">doublons(L)</code> est affreuse !</p>
<p>Déjà, sa complexité est de l'ordre de$\mathcal{O}(n^2)$ si la liste passée en entrée est triée et sans doublons.</p>
<p>Mais de façon bien plus affreuse, elle n'est pas cohérente sur son retour. Parfois elle rend la liste passée en paramètre (si $n \leq 1$), parfois elle rend une copie (si $L[0] &lt; L[1]$) et parfois elle rend une copie <strong>et</strong> modifie la liste passée en paramètre (si $L[0] == L[1]$). Bref, c'est du très mauvais code. Il faut <strong>toujours</strong> être consistant. Soit on modifie les paramètre en entrée et dans ce cas là on ne rend rien, <strong>soit</strong> on rend quelque chose et dans ce cas là on ne modifie pas les paramètres d'entrée.</p>
</div>
</div>
<h3>Q20</h3>
<ul>
<li>la fonction <code class="language-">recherche</code> rend un booléen</li>
<li><code class="language-">but</code> est une liste de deux éléments formant le croisement. Il correspond à l'état qe l'on cherche à atteindre</li>
<li><code class="language-">espace</code> est une liste de croisements (qui sont des listes à deux éléments). Cette liste correspond à tous les états que l'on peut atteindre à partir de init(qui est une liste de 2 liste formant un croisement)</li>
<li><code class="language-">successeurs</code> rend une liste de croisements (qui sont des listes à deux éléments).</li>
</ul>
<h3>Q21</h3>
<p><code class="language-">in2</code> correspond à une recherche dichotomique, dont la complexité est de l'ordre de $\mathcal{O}(log_2(n))$, alors que <code class="language-">in1</code> est une recherche linéaire dont la complexité est de l'ordre de $\mathcal{O}(n)$.</p>
<p>Il est donc <strong>beaucoup</strong> plus judicieux de d'utiliser <code class="language-">in2</code> plutôt que <code class="language-">in1</code>.</p>
<h3>Q22</h3>
<p>un entier $x$ se représente de façon binaire par l'équation :</p>
<p>$$<br>
x = \sum_{i=0}^{i = \log_2(x)} x_i 2^i<br>
$$</p>
<p>Où les $x_i$ valent soit $1$ soit $0$. L'entier $x$ est représenté par $\log_2(x)$ bits valant chacun $x_i$.</p>
<p>On peut alors associer à une liste $L$ de $n$ booléens les $x^L_i$ valant $1$ si <code class="language-">L[n-1-i] == True</code> et 0 si <code class="language-">L[i] == False</code>. La représentation binaire de $L$ est alors représentée par le nombre :</p>
<p>$$<br>
N(l) = \sum_{i=0}^n x^L_i 2^i<br>
$$</p>
<p>Pour $L = [True, False, False]$ on a $0 \cdot 2^0 + 0 \cdot 2^1 + 1 \cdot 2^2$, ce qui correspond au nombre binaire $100$ qui vaut 4.</p>
<p>L'algorithme ci-après en est un calcul. Sa complexité est en $\mathcal{O}(n)$</p>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python"><span class="token keyword">def</span> <span class="token function">versEntier</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span><span class="token punctuation">:</span>
    n <span class="token operator">=</span> <span class="token builtin">len</span><span class="token punctuation">(</span>L<span class="token punctuation">)</span>
    entier <span class="token operator">=</span> <span class="token number">0</span>
    
    puissance_2 <span class="token operator">=</span> <span class="token number">1</span>
    
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>

        <span class="token keyword">if</span> L<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            entier <span class="token operator">+=</span> puissance_2 
        puissance_2 <span class="token operator">*=</span> <span class="token number">2</span>
    
    <span class="token keyword">return</span> entier  
</code></pre>
<h3>Q23</h3>
<p>Il faut que la taille de <code class="language-">L</code> soit au minimum égal à la valeur entière du $\log_2(n)$.<br>
Il faut que <code class="language-">i &gt;= 0</code> pour que la boucle de fasse pas d'erreur lors de l'affectation à <code class="language-">res[i]</code>.</p>
<h3>Q24</h3>
<p>Comme on supprime les doublons et que l'on s'arrête si l'espace de solutions n'a pas grossi, au pire, l'algorithme s'arrêtera lorsque tous les croisements possibles seront vus, comme il y en a un nombre fini (borné par $2 * 2^n$ listes de 2 files au maximum) l'algorithme va s'arrêter.</p>
<h3>Q25</h3>
<p>A chaque étape, les nouvelles solutions sont trouvées à partir d'éléments obtenus à l'étape précédente, sinon elles seraient déjà présent dans l'ensemble des solutions.</p>
<p>Le nombre minimum d'étape pour trouver une solution est donc le nombre de fois où l'on a bouclé sur le <code>while</code> de la fonction recherche.</p>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>