<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>DS 1</title>

    <link href="/cours_informatique/assets/node_modules/prismjs/themes/prism-solarizedlight.min.css" rel="stylesheet">
    <link href="/cours_informatique/assets/node_modules/prismjs/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet">

    <link href="/cours_informatique/assets/stylesheets/main.css" rel="stylesheet">

  </head>
  <body>
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [
            [
              '$', '$'
            ],
            [
              '\\(', '\\)'
            ]
          ]
        },
        svg: {
          fontCache: 'global'
        }
      };

      function goTop() {
        window.scrollTo({top: 0});
      }
      function goBottom() {
        window.scrollTo({top: document.body.scrollHeight});
      }
    </script>
    <script type="text/javascript" id="MathJax-script" src="/cours_informatique/assets/node_modules/mathjax/es5/tex-svg-full.js"></script>

    <header class="border-b-2 border-gray-200 mb-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-between items-center">
          <a class="mx-2" href="/cours_informatique/">Home</a>
        </div>

        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <a class="mx-2" href="/cours_informatique/about">About</a>
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </header>

    <main class="max-w-[1200px] mx-auto px-4">
      
<article>

  <h1>DS 1</h1>
  <div>
    

    
  </div>

  

  <div class="quote relative drop-shadow  py-2 pr-2 rounded rounded-tl-none rounded-bl-none border-solid border-l-8 border-amber-800 bg-amber-100">
<svg class="absolute w-7 h-7 pl-1 pt-0.5 pb-0.5 text-amber-800" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
  <path stroke-linecap="round" stroke-linejoin="round" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
</svg>
<div class="pl-8  mb-2 mr-8">
<p><strong>Sujet</strong></p>
</div><div class="pl-8 mr-8">
<p><a href="ds1_2023_2024.pdf" class="fichier">Étude de l'élément majoritaire</a></p>
<p>Durée du contrôle : 3h.</p>
</div>
</div>
<h2>Barème</h2>
<blockquote>
<p>TBD</p>
</blockquote>
<h2>Corrigé</h2>
<h3>Exercice 1 : encadrement du problême</h3>
<h4>1.1</h4>
<p>Il ne peut y avoir qu'un seul élément majoritaire car il contient strictement plus de la moitié des éléments.</p>
<h4>1.2.1</h4>
<p>Pour tout $n &gt; 2$ on a $\frac{n}{2} + 1 &lt; n$, on peut donc créer un tableau de taille $n$ ayant un deux valeurs distinctes et un élément majoritaire. On peut alors toujour s'arranger pour que $T[i]$ ne soit pas l'élément majoritaire.</p>
<h4>1.2.2</h4>
<p>Le tableau avec une unique valeur répond trivialement à la question.</p>
<h4>1.2.3</h4>
<p>La question 1.2.1 nous montre que l'on peut créer un tableau possédant un élément majoritaire et tel que $T[i]$ ne soit pas cet élément. On peut de plus s'arranger pour que cet élément majoritaire soit exactement présent la partie entière de $\frac{n}{2}$ plus 1 fois (on remplace si nécessaire les éléments surnuméraires par $T[i]$).</p>
<p>Le tableau $T'$ tel que :</p>
<ul>
<li>$T[j] = T'[j]$ pour tout $j \neq i$</li>
<li>$T'[i]$ vaut l'élément majoritaire de $T$</li>
</ul>
<p>Répond à la question.</p>
<h4>1.2.4</h4>
<p>On procède comme dans le cours pour démontrer <a href="/cours_informatique/cours/algorithmie/complexit%C3%A9-probl%C3%A8me/#complexit%C3%A9-recherche">la complexité du problème de la recherche</a>.</p>
<p>On suppose qu'il existe un algorithme prenant strictement moins que $n$ opérations pour trouver l'élément majoritaire de tout tableau de taille $n &gt; N_0$. Prenons un tableau $T$ comme dans la question précédente. On a alors deux cas :</p>
<ul>
<li>soit l'algorithme a parcouru toutes les cases de $T$ possédant l'élément majoritaire et il a eu besoin d'au moins $\frac{n}{2} + 1 = \Omega(n)$ opérations,</li>
<li>soit il n'a pas parcouru toutes les cases de $T$ possédant l'élément majoritaire, disons $T[i]$, et on crée le tableau $T'$ identique à $T$ sauf pour la case d'indice $i$ : $T'$ ne possède pas d'élément majoritaire mais l'algorithme va donner la même réponse que pour $T$. Contradiction.</li>
</ul>
<h4>1.3.1</h4>
<pre class="language-python " style="counter-reset: linenumber 0"><code class="language-python">
<span class="token keyword">def</span> <span class="token function">compte</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">:</span>

    nombre <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> element <span class="token keyword">in</span> T<span class="token punctuation">:</span>
        <span class="token keyword">if</span> element <span class="token operator">==</span> x<span class="token punctuation">:</span>
            nombre <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">return</span> nombre
</code></pre>
<p>La complexité de la fonction est en $\mathcal{O}(n)$ où $n$ est la taille de $T$ puisque :</p>
<ul>
<li>toutes les lignes sont de complexité $\mathcal{O}(1)$</li>
<li>la boucle <code class="language-">for</code> est exécutée la taille de $T$ fois, c'est à dire $\mathcal{O}(n)$ fois.</li>
</ul>
<p>L'invariant de boucle que l'on va utiliser pour prouver l'algorithme <code class="language-">compte</code> est : au bout de la $i$ ème itération, <code class="language-">nombre</code> vaut le nombres de fois où <code class="language-">x</code> est présent dans les $i$ premières cases de $T$.</p>
<ol>
<li>l'invariant est clairement vérifié à la fin de la première itération</li>
<li>si l'invariant est vérifié à la fin de la $i$ ème itération, , comme la $i+1$ itération vérifie si <code class="language-">x == T[i]</code> et ajoute 1 à <code class="language-">nombre</code> si c'est le cas, l'invariant est toujours vérifié à la fin de la $i + 1$ ème itération.</li>
<li>l'invariant est vrai en sortie de boucle, c'est à dire après avoir parcouru tous les éléments de $T$ : <code class="language-">nombre</code> vaut bien le nombre de fois où <code class="language-">x</code> est présent dans $T$.</li>
</ol>
<h4>1.3.2</h4>
<pre class="language-python line-numbers" style="counter-reset: linenumber 0"><code class="language-python">
<span class="token keyword">def</span> élément_majoritaire<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> x <span class="token keyword">in</span> T<span class="token punctuation">:</span>
        <span class="token keyword">if</span> compte<span class="token punctuation">(</span>T<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token builtin">len</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> x
    <span class="token keyword">return</span> <span class="token boolean">None</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Le test de la ligne 4 est en $\mathcal{O}(n)$ où $n$ est la taille de $T$ puisqu'il faut exécuter <code class="language-">compte</code>. Toutes les autres lignes sont de complexité $\mathcal{O}(1)$ et comme la boucle <code class="language-">for</code> est exécutée la taille de $T$ fois, on exécute <code class="language-">compte</code> $n$ fois ce qui porte la complexité de l'algorithme à $\mathcal{O}(n^2)$.</p>
<p>L'invariant de boucle que l'on va utiliser pour prouver l'algorithme <code class="language-">élément_majoritaire</code> est : au bout de la $i$ ème itération,aucun des $i$ premières cases de $T$ n'est un élément majoritaire.</p>
<ol>
<li>l'invariant est clairement vérifié à la fin de la première itération</li>
<li>si l'invariant est vérifié à la fin de la $i$ ème itération, comme la $i+1$ itération vérifie si <code class="language-">T[i]</code> est un élément majoritaire, l'invariant est toujours vérifié à la fin de la $i + 1$ ème itération.</li>
<li>l'invariant est vrai en sortie de boucle, c'est à dire après avoir parcouru tous les éléments de $T$ : si on arrive en ligne 6, c'est que $T$ n'a pas d'élément majoritaire. Si l'on s'arrête à la fin de la $i$ ème itération c'est que <code class="language-">T[i-1]</code> est l'élément majoritaire de $T$.</li>
</ol>
<h4>1.3.3</h4>
<p>En utilisant le premier tableau, la fonction va parcourir tous les éléments de $T$ et pour chacun effectuer la fonction <code class="language-">compte</code> sans trouver d'élément présent 5 fois ou plus.</p>
<p>En utilisant le premier tableau, la fonction sortir au bout de la première itération puisque 2 est l'élément majoritaire de $T$.</p>
<h4>1.3.4</h4>
<p>L'algorithme de la question 1.3.2 résoud le problème de la recherche d'un élément majoritaire, sa complexité est donc un majorant de la complexité du problème.</p>
<h3>Exercice 2 : Tris</h3>
<h3>Exercice 3 : Diviser pour régner</h3>
<h3>Exercice 4 : Piles</h3>


</article>
    </main>

    <footer class="min-h-[50px] border-t-2 border-gray-200 mt-4">
      <div class="max-w-[1200px] mx-auto px-4 relative">
        <div class="min-h-[50px] flex justify-center items-center">
          <p>
            Cours d'informatique à l'école centrale Marseille
          </p>
        </div>
        <div class="min-h-[50px] flex justify-center items-center absolute right-0 top-0">
          <button onclick="goTop()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M15 11.25l-3-3m0 0l-3 3m3-3v7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>

          <button onclick="goBottom()" id="myBtn" title="Go to top">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75l3 3m0 0l3-3m-3 3v-7.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
          </button>
        </div>

      </div>
    </footer>

    <script>
      MathJax
        .startup
        .document
        .getMathItemsWithin(document.body);
    </script>

  </body>
</html>